# -*- coding: utf-8 -*-
"""
coe_gen_xml.py

Output EtherCATInfo ESI XML file from CoE data

Created on Wed Nov 06 10:02:12 2013

@author: Dave Page, Dynamic Systems Inc.

@copyright MIT License
Copyright (C) 2013 Dynamic Systems Inc.
Permission is hereby granted, free of charge, to any person obtaining 
a copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to 
the following conditions:
The above copyright notice and this permission notice shall be included 
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR 
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
OTHER DEALINGS IN THE SOFTWARE.
"""

import sys
# ethercatinfo was generated by generateDS.py from EtherCATInfo.xsd
import ethercatinfo as eci
from coe_defs import *

def hexdecvaluetoint(hdv):
    """Convert HexDecValue to int. Will fail if argument has leading zeroes"""
    return int(hdv.replace('#x','0x'),0)
    
def hexdec(i):
    """
    Convert some integer form to HexDecValue, hexidecimal version
    """
    return hex(i).replace('0x','#x')

def make(world, *args):
    coe_dict = world.coe_dict
    settings = world.settings
    
    "Modify ESI file based on our application dictionary"
    esi = eci.parse(args[0],silence=True)
    
    # Identify Device node
    device = next((n for n in esi.Descriptions.Devices.Device if 
        next((m for m in n.Name if 
            m.LcId==1033 and m.valueOf_==settings['TYPE_NAME']), None)), None)
    
    if device is None:
        print 'Device not found in XML'
        return
        
    #ET9300 6.5.2.1 Adaptation steps

    #Step 9: modify ESI XML file
    def purge_fill_map(pdomap,addr,sm):
        del pdomap[:]
        default_size = 0
        for pdo_map_entry in (obj for obj in coe_dict if (obj.index&0xff00)==addr):
            pdo_xml = eci.PdoType(Mandatory=True, Fixed=True, Sm=str(sm), 
                Index=eci.IndexType35(valueOf_=pdo_map_entry.xml_index()),
                Name=[
                    eci.NameType(LcId=1033,valueOf_=pdo_map_entry.description)
                ])
            
            pdo_xml.Entry = []
            for mso in pdo_map_entry.subs[1:]:
                so = find_by_map_loc(coe_dict,mso.default)
            
                pdo_xml.Entry.append(eci.EntryType36(
                    Index=eci.IndexType33(valueOf_=so.xml_index()),
                    SubIndex=str(so.subindex),
                    BitLen=so.pdo_bitsize(), 
                    Name=[
                        eci.NameType(LcId=1033,valueOf_=so.description)
                    ],
                    DataType=eci.DataTypeType34(valueOf_=so.btype)
                )) 
                default_size += so.pdo_bitsize()
            pdomap.append( pdo_xml )

        return default_size

    # Purge and refill Device/RxPdo on SM2
    rxpdo_default_size = purge_fill_map(device.RxPdo,0x1600,2)
    
    # Purge and refill Device/TxPdo on SM3
    txpdo_default_size = purge_fill_map(device.TxPdo,0x1a00,3)

    #Step 10: Update size of sync manager
    # Update default size for SM2
    print 'RxPDO bit size',rxpdo_default_size
    device.Sm[2].DefaultSize=str((rxpdo_default_size+7)/8)
    # Update default size for SM3
    print 'TxPDO bit size',txpdo_default_size
    device.Sm[3].DefaultSize=str((txpdo_default_size+7)/8)
    
    #Step [missing]: Define Profile/Dictionary/DataTypes
    # Loop over existing types and build a dictionary on Name 
    data_types = {}
    for dtt in device.Profile[0].Dictionary.DataTypes.DataType:
        if dtt.Name=='DT1018':
            data_types[dtt.Name] = dtt
    
    # Insert or update our known Basic types to dictionary
    for btype,coetype in coe_types.iteritems():
        #print btype,coetype
        data_types[btype] = eci.DataTypeType(Name=btype,BitSize=coetype.pdo_bitsize)
    
    def make_flags_type(subobject):
        access = subobject.access_code
        if access&0x38 and access&0x07:
            at = 'rw'
        elif access&0x38:
            at = 'wo'
        else:
            at = 'ro'
            
        return eci.FlagsType(Access=eci.AccessType21(valueOf_=at),Category='o',
            PdoMapping=(None,'R','T','TR')[(access&0xc0)>>6],
            Backup=1 if (access&0x100)>>8 else None,
            Setting=1 if (access&0x200)>>9 else None,
            SafetyMapping=(None,'SI','SO','SIO','SP','SP','SP','SP')[(access&0x1c00)>>10])
    
    # Loop over our mesi defined objects and create their corresponding types
    for obj in coe_dict:
        name = 'DT%04X' % obj.index
        
        # VARIABLE is ignored, as the type is merely specified as a basic 
        # type in the ObjectType element
    
        if obj.is_record():
            # Save data type name for later XML use
            obj.data_type = name

            data_types[name] = eci.DataTypeType(
                Name=name,BitSize=obj.sdo_bitsize(),SubItem=[
                    eci.SubItemType(SubIdx=str(so.subindex), Name=so.description,
                                Type=so.btype,BitSize=so.pdo_bitsize(),
                                BitOffs=obj.sdo_bitoffset(so.subindex), 
                                Flags=make_flags_type(so) )
                    for so in obj.subs])
        if obj.is_array():
            # Save data type name for later XML use
            obj.data_type = name

            name_arr = name+'ARR'
            so0,so1 = obj.subs[0:2]
            data_types[name] = eci.DataTypeType(
                Name=name,BitSize=obj.sdo_bitsize(),SubItem=[
                    eci.SubItemType(SubIdx='0', Name=so0.description,
                                Type=so0.btype,BitSize=so0.pdo_bitsize(),
                                BitOffs=obj.sdo_bitoffset(0), 
                                Flags=make_flags_type(so0) ),
                    eci.SubItemType(SubIdx='1', Name='Elements',
                                Type=name_arr,BitSize=obj.pdo_data_bitsize(),
                                BitOffs=obj.sdo_bitoffset(1), 
                                Flags=make_flags_type(so1) )])
            data_types[name_arr] = eci.DataTypeType(
                Name=name_arr,BitSize=obj.sdo_bitsize(),BaseType=so1.btype,
                    ArrayInfo=[
                        eci.ArrayInfoType(LBound=1,Elements=obj.max_subindex())
                    ])
    
    # Map updated DataTypes back to sorted list and update XML
    device.Profile[0].Dictionary.DataTypes.DataType = sorted(
        data_types.itervalues(), key=lambda x: x.Name)
    
    # Debug report
    #device.Profile[0].Dictionary.DataTypes.export(sys.stdout, 0, pretty_print=True)

    # Defined object types
    def make_flags_type24(subobject):
        access = subobject.access()
        if 'w' in access and 'r' in access:
            at = 'rw'
        elif 'w' in access:
            at = 'wo'
        else:
            at = 'ro'
            
        return eci.FlagsType24(Access=eci.AccessType25(valueOf_=at),Category='o')

    #Step [missing]: Define Profile/Dictionary/Objects
    # Loop over existing types and build a dictionary on Index 
    dictionary_objects = {}
    for ot in device.Profile[0].Dictionary.Objects.Object:
        index = hexdecvaluetoint(ot.Index.valueOf_)
        # discard existing assigns, mappings, and pdos
        if index < 0x1100:
            dictionary_objects[hexdecvaluetoint(ot.Index.valueOf_)] = ot
        
    # Loop over our mesi defined objects and create their corresponding Objects
    for obj in coe_dict:
        index = obj.xml_index()
        
        if obj.is_variable():
            so0 = obj.subs[0]
            dictionary_objects[hexdecvaluetoint(index)] = eci.ObjectType(
                Index=eci.IndexType(valueOf_=index),
                Name=[eci.NameType(LcId=1033,valueOf_=obj.description)],
                Type=so0.btype,
                BitSize=so0.pdo_bitsize(),
                Info=eci.ObjectInfoType(DefaultData=so0.hexbinary_default()),
                Flags=make_flags_type24(so0)
            )
    
        if obj.is_record() or obj.is_array():
            dictionary_objects[hexdecvaluetoint(index)] = eci.ObjectType(
                Index=eci.IndexType(valueOf_=index),
                Name=[eci.NameType(LcId=1033,valueOf_=obj.description)],
                Type=obj.data_type,
                BitSize=obj.sdo_bitsize(),
                Info=eci.ObjectInfoType(SubItem=[
                    eci.SubItemType32(
                        Name=so.description, 
                        Info=eci.ObjectInfoType(DefaultData=so.hexbinary_default())
                    ) for so in obj.subs]),
                Flags=make_flags_type24(obj.subs[0])
            )

    # Map updated Objects back to sorted list and update XML
    device.Profile[0].Dictionary.Objects.Object = sorted(
        dictionary_objects.itervalues(), key=lambda x: x.Index.valueOf_.lower())
   
    # Set ether port interface type
    device.Physics=settings['physics'] 
    
    # Set device type identification
    device.Type.ProductCode = hexdec(settings['PRODUCT_CODE'])
    device.Type.RevisionNo = hexdec(settings['REVISION_NUMBER'])
    device.Type.valueOf_ = settings['TYPE_NAME']
    
    # FMMU
    del device.Fmmu[:]
    for i in xrange(8):
        fmmu = settings.get('fmmu%d.mode'%i, 0xff)
        if fmmu==1:
            device.Fmmu.append( eci.FmmuType(valueOf_='Outputs'))
        if fmmu==2:
            device.Fmmu.append( eci.FmmuType(valueOf_='Inputs'))
        if fmmu==3:
            device.Fmmu.append( eci.FmmuType(valueOf_='MBoxState'))

    # Sync Masters
    del device.Sm[:]
    for i in xrange(8):
        pre = 'sm%d.' % i
        
        if pre+'enable' in settings: 
            def prop(key):
                return settings.get(pre+key,0)

            device.Sm.append(eci.SmType(
                Enable=prop('enable'),
                DefaultSize=prop('size'),
                ControlByte=hexdec(prop('control')),
                MinSize=settings.get(pre+'min_size',None),
                MaxSize=settings.get(pre+'max_size',None),
                StartAddress=hexdec(prop('start_addr')),
                valueOf_=[None,'MBoxOut','MBoxIn','Outputs','Inputs'][prop('type')]))

    # Distributed Clock
    del device.Dc.OpMode[:]
    for i in xrange(8):
        pre = 'dc%d.' % i
        
        if pre+'name' in settings: # Name is mandatory
            def prop(key):
                return settings.get(pre+key,0)

            device.Dc.OpMode.append(eci.OpModeType(
                Name=str(prop('name')),
                Desc=str(prop('desc')),
                AssignActivate=str(prop('assign_activate')),
                CycleTimeSync0=eci.CycleTimeSync0Type(
                    Factor=prop('sync0_cycle_factor'),
                    valueOf_ = str(prop('sync0_cycle')),
                ),
                ShiftTimeSync0=eci.ShiftTimeSync0Type(
                    valueOf_ = str(prop('sync0_shift')),
                ),
                CycleTimeSync1=eci.CycleTimeSync1Type(
                    Factor=prop('sync1_cycle_factor'),
                    valueOf_ = str(prop('sync1_cycle')),
                ),
                ShiftTimeSync1=eci.ShiftTimeSync1Type(
                    valueOf_ = str(prop('sync1_shift')),
                )))

    # SII EERPOM
    device.Eeprom=eci.EepromType16(
        ByteSize=settings['ESC_EEPROM_SIZE'],
        ConfigData=settings['config_data'],
        BootStrap=settings['bootstrap'])

    # Debug report
    #print type(device.Sm[0])
    #device.Sm[0].exportLiteral(sys.stdout,0)
    
    ### Output modified XML
    with open(args[1],'w') as outfile:
        namespacedef = 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="EtherCATInfo.xsd"'
        esi.export(outfile,0,'','EtherCATInfo',namespacedef,False)
    