#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Oct 31 16:00:48 2013 by generateDS.py version 2.12a.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class EtherCATInfo(GeneratedsSuper):
    """Schema Version (1.8.2) based on ETG.2000 1.0.4 with new elements and
    scaling information"""
    subclass = None
    superclass = None
    def __init__(self, Version=None, InfoReference=None, Vendor=None, Descriptions=None):
        self.Version = _cast(None, Version)
        if InfoReference is None:
            self.InfoReference = []
        else:
            self.InfoReference = InfoReference
        self.Vendor = Vendor
        self.Descriptions = Descriptions
    def factory(*args_, **kwargs_):
        if EtherCATInfo.subclass:
            return EtherCATInfo.subclass(*args_, **kwargs_)
        else:
            return EtherCATInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InfoReference(self): return self.InfoReference
    def set_InfoReference(self, InfoReference): self.InfoReference = InfoReference
    def add_InfoReference(self, value): self.InfoReference.append(value)
    def insert_InfoReference(self, index, value): self.InfoReference[index] = value
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Descriptions(self): return self.Descriptions
    def set_Descriptions(self, Descriptions): self.Descriptions = Descriptions
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.InfoReference or
            self.Vendor is not None or
            self.Descriptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EtherCATInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EtherCATInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EtherCATInfo'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_format_string(quote_attrib(self.Version).encode(ExternalEncoding), input_name='Version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EtherCATInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InfoReference_ in self.InfoReference:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInfoReference>%s</%sInfoReference>%s' % (namespace_, self.gds_format_string(quote_xml(InfoReference_).encode(ExternalEncoding), input_name='InfoReference'), namespace_, eol_))
        if self.Vendor is not None:
            self.Vendor.export(outfile, level, namespace_, name_='Vendor', pretty_print=pretty_print)
        if self.Descriptions is not None:
            self.Descriptions.export(outfile, level, namespace_, name_='Descriptions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EtherCATInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            showIndent(outfile, level)
            outfile.write('Version="%s",\n' % (self.Version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InfoReference=[\n')
        level += 1
        for InfoReference_ in self.InfoReference:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InfoReference_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=model_.VendorType1(\n')
            self.Vendor.exportLiteral(outfile, level, name_='Vendor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Descriptions is not None:
            showIndent(outfile, level)
            outfile.write('Descriptions=model_.DescriptionsType(\n')
            self.Descriptions.exportLiteral(outfile, level, name_='Descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InfoReference':
            InfoReference_ = child_.text
            InfoReference_ = self.gds_validate_string(InfoReference_, node, 'InfoReference')
            self.InfoReference.append(InfoReference_)
        elif nodeName_ == 'Vendor':
            obj_ = VendorType1.factory()
            obj_.build(child_)
            self.Vendor = obj_
        elif nodeName_ == 'Descriptions':
            obj_ = DescriptionsType.factory()
            obj_.build(child_)
            self.Descriptions = obj_
# end class EtherCATInfo


class DeviceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, HideType=None, AlternativeType=None, SubDevice=None, Name=None, Comment=None, URL=None, Info=None, GroupType=None, Profile=None, Fmmu=None, Sm=None, Su=None, RxPdo=None, TxPdo=None, Mailbox=None, Dc=None, Slots=None, ESC=None, Eeprom=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, extensiontype_=None):
        self.Type = Type
        if HideType is None:
            self.HideType = []
        else:
            self.HideType = HideType
        if AlternativeType is None:
            self.AlternativeType = []
        else:
            self.AlternativeType = AlternativeType
        if SubDevice is None:
            self.SubDevice = []
        else:
            self.SubDevice = SubDevice
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
        self.Info = Info
        self.GroupType = GroupType
        if Profile is None:
            self.Profile = []
        else:
            self.Profile = Profile
        if Fmmu is None:
            self.Fmmu = []
        else:
            self.Fmmu = Fmmu
        if Sm is None:
            self.Sm = []
        else:
            self.Sm = Sm
        if Su is None:
            self.Su = []
        else:
            self.Su = Su
        if RxPdo is None:
            self.RxPdo = []
        else:
            self.RxPdo = RxPdo
        if TxPdo is None:
            self.TxPdo = []
        else:
            self.TxPdo = TxPdo
        self.Mailbox = Mailbox
        self.Dc = Dc
        self.Slots = Slots
        self.ESC = ESC
        self.Eeprom = Eeprom
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DeviceType.subclass:
            return DeviceType.subclass(*args_, **kwargs_)
        else:
            return DeviceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_HideType(self): return self.HideType
    def set_HideType(self, HideType): self.HideType = HideType
    def add_HideType(self, value): self.HideType.append(value)
    def insert_HideType(self, index, value): self.HideType[index] = value
    def get_AlternativeType(self): return self.AlternativeType
    def set_AlternativeType(self, AlternativeType): self.AlternativeType = AlternativeType
    def add_AlternativeType(self, value): self.AlternativeType.append(value)
    def insert_AlternativeType(self, index, value): self.AlternativeType[index] = value
    def get_SubDevice(self): return self.SubDevice
    def set_SubDevice(self, SubDevice): self.SubDevice = SubDevice
    def add_SubDevice(self, value): self.SubDevice.append(value)
    def insert_SubDevice(self, index, value): self.SubDevice[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL(self, index, value): self.URL[index] = value
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_GroupType(self): return self.GroupType
    def set_GroupType(self, GroupType): self.GroupType = GroupType
    def get_Profile(self): return self.Profile
    def set_Profile(self, Profile): self.Profile = Profile
    def add_Profile(self, value): self.Profile.append(value)
    def insert_Profile(self, index, value): self.Profile[index] = value
    def get_Fmmu(self): return self.Fmmu
    def set_Fmmu(self, Fmmu): self.Fmmu = Fmmu
    def add_Fmmu(self, value): self.Fmmu.append(value)
    def insert_Fmmu(self, index, value): self.Fmmu[index] = value
    def get_Sm(self): return self.Sm
    def set_Sm(self, Sm): self.Sm = Sm
    def add_Sm(self, value): self.Sm.append(value)
    def insert_Sm(self, index, value): self.Sm[index] = value
    def get_Su(self): return self.Su
    def set_Su(self, Su): self.Su = Su
    def add_Su(self, value): self.Su.append(value)
    def insert_Su(self, index, value): self.Su[index] = value
    def get_RxPdo(self): return self.RxPdo
    def set_RxPdo(self, RxPdo): self.RxPdo = RxPdo
    def add_RxPdo(self, value): self.RxPdo.append(value)
    def insert_RxPdo(self, index, value): self.RxPdo[index] = value
    def get_TxPdo(self): return self.TxPdo
    def set_TxPdo(self, TxPdo): self.TxPdo = TxPdo
    def add_TxPdo(self, value): self.TxPdo.append(value)
    def insert_TxPdo(self, index, value): self.TxPdo[index] = value
    def get_Mailbox(self): return self.Mailbox
    def set_Mailbox(self, Mailbox): self.Mailbox = Mailbox
    def get_Dc(self): return self.Dc
    def set_Dc(self, Dc): self.Dc = Dc
    def get_Slots(self): return self.Slots
    def set_Slots(self, Slots): self.Slots = Slots
    def get_ESC(self): return self.ESC
    def set_ESC(self, ESC): self.ESC = ESC
    def get_Eeprom(self): return self.Eeprom
    def set_Eeprom(self, Eeprom): self.Eeprom = Eeprom
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Type is not None or
            self.HideType or
            self.AlternativeType or
            self.SubDevice or
            self.Name or
            self.Comment or
            self.URL or
            self.Info is not None or
            self.GroupType is not None or
            self.Profile or
            self.Fmmu or
            self.Sm or
            self.Su or
            self.RxPdo or
            self.TxPdo or
            self.Mailbox is not None or
            self.Dc is not None or
            self.Slots is not None or
            self.ESC is not None or
            self.Eeprom is not None or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        for HideType_ in self.HideType:
            HideType_.export(outfile, level, namespace_, name_='HideType', pretty_print=pretty_print)
        for AlternativeType_ in self.AlternativeType:
            AlternativeType_.export(outfile, level, namespace_, name_='AlternativeType', pretty_print=pretty_print)
        for SubDevice_ in self.SubDevice:
            SubDevice_.export(outfile, level, namespace_, name_='SubDevice', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for URL_ in self.URL:
            URL_.export(outfile, level, namespace_, name_='URL', pretty_print=pretty_print)
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
        if self.GroupType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroupType>%s</%sGroupType>%s' % (namespace_, self.gds_format_string(quote_xml(self.GroupType).encode(ExternalEncoding), input_name='GroupType'), namespace_, eol_))
        for Profile_ in self.Profile:
            Profile_.export(outfile, level, namespace_, name_='Profile', pretty_print=pretty_print)
        for Fmmu_ in self.Fmmu:
            Fmmu_.export(outfile, level, namespace_, name_='Fmmu', pretty_print=pretty_print)
        for Sm_ in self.Sm:
            Sm_.export(outfile, level, namespace_, name_='Sm', pretty_print=pretty_print)
        for Su_ in self.Su:
            Su_.export(outfile, level, namespace_, name_='Su', pretty_print=pretty_print)
        for RxPdo_ in self.RxPdo:
            RxPdo_.export(outfile, level, namespace_, name_='RxPdo', pretty_print=pretty_print)
        for TxPdo_ in self.TxPdo:
            TxPdo_.export(outfile, level, namespace_, name_='TxPdo', pretty_print=pretty_print)
        if self.Mailbox is not None:
            self.Mailbox.export(outfile, level, namespace_, name_='Mailbox', pretty_print=pretty_print)
        if self.Dc is not None:
            self.Dc.export(outfile, level, namespace_, name_='Dc', pretty_print=pretty_print)
        if self.Slots is not None:
            self.Slots.export(outfile, level, namespace_, name_='Slots', pretty_print=pretty_print)
        if self.ESC is not None:
            self.ESC.export(outfile, level, namespace_, name_='ESC', pretty_print=pretty_print)
        if self.Eeprom is not None:
            self.Eeprom.export(outfile, level, namespace_, name_='Eeprom', pretty_print=pretty_print)
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeviceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.TypeType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('HideType=[\n')
        level += 1
        for HideType_ in self.HideType:
            showIndent(outfile, level)
            outfile.write('model_.HideTypeType(\n')
            HideType_.exportLiteral(outfile, level, name_='HideTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AlternativeType=[\n')
        level += 1
        for AlternativeType_ in self.AlternativeType:
            showIndent(outfile, level)
            outfile.write('model_.AlternativeTypeType(\n')
            AlternativeType_.exportLiteral(outfile, level, name_='AlternativeTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SubDevice=[\n')
        level += 1
        for SubDevice_ in self.SubDevice:
            showIndent(outfile, level)
            outfile.write('model_.SubDeviceType(\n')
            SubDevice_.exportLiteral(outfile, level, name_='SubDeviceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            URL_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.InfoType(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroupType is not None:
            showIndent(outfile, level)
            outfile.write('GroupType=%s,\n' % quote_python(self.GroupType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Profile=[\n')
        level += 1
        for Profile_ in self.Profile:
            showIndent(outfile, level)
            outfile.write('model_.ProfileType5(\n')
            Profile_.exportLiteral(outfile, level, name_='ProfileType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Fmmu=[\n')
        level += 1
        for Fmmu_ in self.Fmmu:
            showIndent(outfile, level)
            outfile.write('model_.FmmuType(\n')
            Fmmu_.exportLiteral(outfile, level, name_='FmmuType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sm=[\n')
        level += 1
        for Sm_ in self.Sm:
            showIndent(outfile, level)
            outfile.write('model_.SmType(\n')
            Sm_.exportLiteral(outfile, level, name_='SmType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Su=[\n')
        level += 1
        for Su_ in self.Su:
            showIndent(outfile, level)
            outfile.write('model_.SuType(\n')
            Su_.exportLiteral(outfile, level, name_='SuType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RxPdo=[\n')
        level += 1
        for RxPdo_ in self.RxPdo:
            showIndent(outfile, level)
            outfile.write('model_.PdoType(\n')
            RxPdo_.exportLiteral(outfile, level, name_='PdoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TxPdo=[\n')
        level += 1
        for TxPdo_ in self.TxPdo:
            showIndent(outfile, level)
            outfile.write('model_.PdoType(\n')
            TxPdo_.exportLiteral(outfile, level, name_='PdoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mailbox is not None:
            showIndent(outfile, level)
            outfile.write('Mailbox=model_.MailboxType(\n')
            self.Mailbox.exportLiteral(outfile, level, name_='Mailbox')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dc is not None:
            showIndent(outfile, level)
            outfile.write('Dc=model_.DcType(\n')
            self.Dc.exportLiteral(outfile, level, name_='Dc')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Slots is not None:
            showIndent(outfile, level)
            outfile.write('Slots=model_.SlotsType(\n')
            self.Slots.exportLiteral(outfile, level, name_='Slots')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ESC is not None:
            showIndent(outfile, level)
            outfile.write('ESC=model_.ESCType(\n')
            self.ESC.exportLiteral(outfile, level, name_='ESC')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Eeprom is not None:
            showIndent(outfile, level)
            outfile.write('Eeprom=model_.EepromType16(\n')
            self.Eeprom.exportLiteral(outfile, level, name_='Eeprom')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = TypeType.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'HideType':
            obj_ = HideTypeType.factory()
            obj_.build(child_)
            self.HideType.append(obj_)
        elif nodeName_ == 'AlternativeType':
            obj_ = AlternativeTypeType.factory()
            obj_.build(child_)
            self.AlternativeType.append(obj_)
        elif nodeName_ == 'SubDevice':
            obj_ = SubDeviceType.factory()
            obj_.build(child_)
            self.SubDevice.append(obj_)
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'URL':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.URL.append(obj_)
        elif nodeName_ == 'Info':
            obj_ = InfoType.factory()
            obj_.build(child_)
            self.Info = obj_
        elif nodeName_ == 'GroupType':
            GroupType_ = child_.text
            GroupType_ = self.gds_validate_string(GroupType_, node, 'GroupType')
            self.GroupType = GroupType_
        elif nodeName_ == 'Profile':
            obj_ = ProfileType5.factory()
            obj_.build(child_)
            self.Profile.append(obj_)
        elif nodeName_ == 'Fmmu':
            obj_ = FmmuType.factory()
            obj_.build(child_)
            self.Fmmu.append(obj_)
        elif nodeName_ == 'Sm':
            obj_ = SmType.factory()
            obj_.build(child_)
            self.Sm.append(obj_)
        elif nodeName_ == 'Su':
            obj_ = SuType.factory()
            obj_.build(child_)
            self.Su.append(obj_)
        elif nodeName_ == 'RxPdo':
            obj_ = PdoType.factory()
            obj_.build(child_)
            self.RxPdo.append(obj_)
        elif nodeName_ == 'TxPdo':
            obj_ = PdoType.factory()
            obj_.build(child_)
            self.TxPdo.append(obj_)
        elif nodeName_ == 'Mailbox':
            obj_ = MailboxType.factory()
            obj_.build(child_)
            self.Mailbox = obj_
        elif nodeName_ == 'Dc':
            obj_ = DcType.factory()
            obj_.build(child_)
            self.Dc = obj_
        elif nodeName_ == 'Slots':
            obj_ = SlotsType.factory()
            obj_.build(child_)
            self.Slots = obj_
        elif nodeName_ == 'ESC':
            obj_ = ESCType.factory()
            obj_.build(child_)
            self.ESC = obj_
        elif nodeName_ == 'Eeprom':
            obj_ = EepromType16.factory()
            obj_.build(child_)
            self.Eeprom = obj_
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class DeviceType


class GroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, Comment=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, extensiontype_=None):
        self.Type = Type
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if GroupType.subclass:
            return GroupType.subclass(*args_, **kwargs_)
        else:
            return GroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Name or
            self.Comment or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class GroupType


class EepromType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Data=None, ByteSize=None, ConfigData=None, BootStrap=None, Category=None, VendorSpecific=None, extensiontype_=None):
        self.Data = Data
        self.ByteSize = ByteSize
        self.ConfigData = ConfigData
        self.BootStrap = BootStrap
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EepromType.subclass:
            return EepromType.subclass(*args_, **kwargs_)
        else:
            return EepromType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_ByteSize(self): return self.ByteSize
    def set_ByteSize(self, ByteSize): self.ByteSize = ByteSize
    def get_ConfigData(self): return self.ConfigData
    def set_ConfigData(self, ConfigData): self.ConfigData = ConfigData
    def get_BootStrap(self): return self.BootStrap
    def set_BootStrap(self, BootStrap): self.BootStrap = BootStrap
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category(self, index, value): self.Category[index] = value
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Data is not None or
            self.ByteSize is not None or
            self.ConfigData is not None or
            self.BootStrap is not None or
            self.Category or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EepromType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EepromType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EepromType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EepromType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.ByteSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sByteSize>%s</%sByteSize>%s' % (namespace_, self.gds_format_integer(self.ByteSize, input_name='ByteSize'), namespace_, eol_))
        if self.ConfigData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConfigData>%s</%sConfigData>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConfigData).encode(ExternalEncoding), input_name='ConfigData'), namespace_, eol_))
        if self.BootStrap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBootStrap>%s</%sBootStrap>%s' % (namespace_, self.gds_format_string(quote_xml(self.BootStrap).encode(ExternalEncoding), input_name='BootStrap'), namespace_, eol_))
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EepromType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.ByteSize is not None:
            showIndent(outfile, level)
            outfile.write('ByteSize=%d,\n' % self.ByteSize)
        if self.ConfigData is not None:
            showIndent(outfile, level)
            outfile.write('ConfigData=%s,\n' % quote_python(self.ConfigData).encode(ExternalEncoding))
        if self.BootStrap is not None:
            showIndent(outfile, level)
            outfile.write('BootStrap=%s,\n' % quote_python(self.BootStrap).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'ByteSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ByteSize')
            self.ByteSize = ival_
        elif nodeName_ == 'ConfigData':
            ConfigData_ = child_.text
            ConfigData_ = self.gds_validate_string(ConfigData_, node, 'ConfigData')
            self.ConfigData = ConfigData_
        elif nodeName_ == 'BootStrap':
            BootStrap_ = child_.text
            BootStrap_ = self.gds_validate_string(BootStrap_, node, 'BootStrap')
            self.BootStrap = BootStrap_
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class EepromType


class InfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Electrical=None, StateMachine=None, Mailbox=None, EtherCATController=None, Port=None, ExecutionUnit=None, VendorSpecific=None, StationAliasSupported=None, IdentificationAdo=None, IdentificationReg134=None, DeviceFeature=None):
        self.Electrical = Electrical
        self.StateMachine = StateMachine
        self.Mailbox = Mailbox
        self.EtherCATController = EtherCATController
        if Port is None:
            self.Port = []
        else:
            self.Port = Port
        if ExecutionUnit is None:
            self.ExecutionUnit = []
        else:
            self.ExecutionUnit = ExecutionUnit
        self.VendorSpecific = VendorSpecific
        self.StationAliasSupported = StationAliasSupported
        self.IdentificationAdo = IdentificationAdo
        self.IdentificationReg134 = IdentificationReg134
        if DeviceFeature is None:
            self.DeviceFeature = []
        else:
            self.DeviceFeature = DeviceFeature
    def factory(*args_, **kwargs_):
        if InfoType.subclass:
            return InfoType.subclass(*args_, **kwargs_)
        else:
            return InfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Electrical(self): return self.Electrical
    def set_Electrical(self, Electrical): self.Electrical = Electrical
    def get_StateMachine(self): return self.StateMachine
    def set_StateMachine(self, StateMachine): self.StateMachine = StateMachine
    def get_Mailbox(self): return self.Mailbox
    def set_Mailbox(self, Mailbox): self.Mailbox = Mailbox
    def get_EtherCATController(self): return self.EtherCATController
    def set_EtherCATController(self, EtherCATController): self.EtherCATController = EtherCATController
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def add_Port(self, value): self.Port.append(value)
    def insert_Port(self, index, value): self.Port[index] = value
    def get_ExecutionUnit(self): return self.ExecutionUnit
    def set_ExecutionUnit(self, ExecutionUnit): self.ExecutionUnit = ExecutionUnit
    def add_ExecutionUnit(self, value): self.ExecutionUnit.append(value)
    def insert_ExecutionUnit(self, index, value): self.ExecutionUnit[index] = value
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_StationAliasSupported(self): return self.StationAliasSupported
    def set_StationAliasSupported(self, StationAliasSupported): self.StationAliasSupported = StationAliasSupported
    def get_IdentificationAdo(self): return self.IdentificationAdo
    def set_IdentificationAdo(self, IdentificationAdo): self.IdentificationAdo = IdentificationAdo
    def get_IdentificationReg134(self): return self.IdentificationReg134
    def set_IdentificationReg134(self, IdentificationReg134): self.IdentificationReg134 = IdentificationReg134
    def get_DeviceFeature(self): return self.DeviceFeature
    def set_DeviceFeature(self, DeviceFeature): self.DeviceFeature = DeviceFeature
    def add_DeviceFeature(self, value): self.DeviceFeature.append(value)
    def insert_DeviceFeature(self, index, value): self.DeviceFeature[index] = value
    def validate_StationAliasSupportedType(self, value):
        # Validate type StationAliasSupportedType, a restriction on xs:NMTOKEN.
        pass
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Electrical is not None or
            self.StateMachine is not None or
            self.Mailbox is not None or
            self.EtherCATController is not None or
            self.Port or
            self.ExecutionUnit or
            self.VendorSpecific is not None or
            self.StationAliasSupported is not None or
            self.IdentificationAdo is not None or
            self.IdentificationReg134 is not None or
            self.DeviceFeature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Electrical is not None:
            self.Electrical.export(outfile, level, namespace_, name_='Electrical', pretty_print=pretty_print)
        if self.StateMachine is not None:
            self.StateMachine.export(outfile, level, namespace_, name_='StateMachine', pretty_print=pretty_print)
        if self.Mailbox is not None:
            self.Mailbox.export(outfile, level, namespace_, name_='Mailbox', pretty_print=pretty_print)
        if self.EtherCATController is not None:
            self.EtherCATController.export(outfile, level, namespace_, name_='EtherCATController', pretty_print=pretty_print)
        for Port_ in self.Port:
            Port_.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
        for ExecutionUnit_ in self.ExecutionUnit:
            ExecutionUnit_.export(outfile, level, namespace_, name_='ExecutionUnit', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
        if self.StationAliasSupported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStationAliasSupported>%s</%sStationAliasSupported>%s' % (namespace_, self.gds_format_string(quote_xml(self.StationAliasSupported).encode(ExternalEncoding), input_name='StationAliasSupported'), namespace_, eol_))
        if self.IdentificationAdo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentificationAdo>%s</%sIdentificationAdo>%s' % (namespace_, self.gds_format_string(quote_xml(self.IdentificationAdo).encode(ExternalEncoding), input_name='IdentificationAdo'), namespace_, eol_))
        if self.IdentificationReg134 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentificationReg134>%s</%sIdentificationReg134>%s' % (namespace_, self.gds_format_boolean(self.IdentificationReg134, input_name='IdentificationReg134'), namespace_, eol_))
        for DeviceFeature_ in self.DeviceFeature:
            DeviceFeature_.export(outfile, level, namespace_, name_='DeviceFeature', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Electrical is not None:
            showIndent(outfile, level)
            outfile.write('Electrical=model_.ElectricalType(\n')
            self.Electrical.exportLiteral(outfile, level, name_='Electrical')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StateMachine is not None:
            showIndent(outfile, level)
            outfile.write('StateMachine=model_.StateMachineType(\n')
            self.StateMachine.exportLiteral(outfile, level, name_='StateMachine')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Mailbox is not None:
            showIndent(outfile, level)
            outfile.write('Mailbox=model_.MailboxType17(\n')
            self.Mailbox.exportLiteral(outfile, level, name_='Mailbox')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EtherCATController is not None:
            showIndent(outfile, level)
            outfile.write('EtherCATController=model_.EtherCATControllerType(\n')
            self.EtherCATController.exportLiteral(outfile, level, name_='EtherCATController')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Port=[\n')
        level += 1
        for Port_ in self.Port:
            showIndent(outfile, level)
            outfile.write('model_.PortType(\n')
            Port_.exportLiteral(outfile, level, name_='PortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ExecutionUnit=[\n')
        level += 1
        for ExecutionUnit_ in self.ExecutionUnit:
            showIndent(outfile, level)
            outfile.write('model_.ExecutionUnitType(\n')
            ExecutionUnit_.exportLiteral(outfile, level, name_='ExecutionUnitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StationAliasSupported is not None:
            showIndent(outfile, level)
            outfile.write('StationAliasSupported=%s,\n' % quote_python(self.StationAliasSupported).encode(ExternalEncoding))
        if self.IdentificationAdo is not None:
            showIndent(outfile, level)
            outfile.write('IdentificationAdo=%s,\n' % quote_python(self.IdentificationAdo).encode(ExternalEncoding))
        if self.IdentificationReg134 is not None:
            showIndent(outfile, level)
            outfile.write('IdentificationReg134=%s,\n' % self.IdentificationReg134)
        showIndent(outfile, level)
        outfile.write('DeviceFeature=[\n')
        level += 1
        for DeviceFeature_ in self.DeviceFeature:
            showIndent(outfile, level)
            outfile.write('model_.DeviceFeatureType(\n')
            DeviceFeature_.exportLiteral(outfile, level, name_='DeviceFeatureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Electrical':
            obj_ = ElectricalType.factory()
            obj_.build(child_)
            self.Electrical = obj_
        elif nodeName_ == 'StateMachine':
            obj_ = StateMachineType.factory()
            obj_.build(child_)
            self.StateMachine = obj_
        elif nodeName_ == 'Mailbox':
            obj_ = MailboxType17.factory()
            obj_.build(child_)
            self.Mailbox = obj_
        elif nodeName_ == 'EtherCATController':
            obj_ = EtherCATControllerType.factory()
            obj_.build(child_)
            self.EtherCATController = obj_
        elif nodeName_ == 'Port':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.Port.append(obj_)
        elif nodeName_ == 'ExecutionUnit':
            obj_ = ExecutionUnitType.factory()
            obj_.build(child_)
            self.ExecutionUnit.append(obj_)
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
        elif nodeName_ == 'StationAliasSupported':
            StationAliasSupported_ = child_.text
            StationAliasSupported_ = self.gds_validate_string(StationAliasSupported_, node, 'StationAliasSupported')
            self.StationAliasSupported = StationAliasSupported_
            self.validate_StationAliasSupportedType(self.StationAliasSupported)    # validate type StationAliasSupportedType
        elif nodeName_ == 'IdentificationAdo':
            IdentificationAdo_ = child_.text
            IdentificationAdo_ = self.gds_validate_string(IdentificationAdo_, node, 'IdentificationAdo')
            self.IdentificationAdo = IdentificationAdo_
            self.validate_HexDecValue(self.IdentificationAdo)    # validate type HexDecValue
        elif nodeName_ == 'IdentificationReg134':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IdentificationReg134')
            self.IdentificationReg134 = ival_
        elif nodeName_ == 'DeviceFeature':
            obj_ = DeviceFeatureType.factory()
            obj_.build(child_)
            self.DeviceFeature.append(obj_)
# end class InfoType


class SlotType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SlotPdoIncrement=None, SlotIndexIncrement=None, MaxInstances=None, SlotGroupIndexIncrement=None, MinInstances=None, TreeView=None, SlotGroup=None, SlotGroupPdoIncrement=None, Name=None, ModuleIdent=None, ModuleClass=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None):
        self.SlotPdoIncrement = _cast(None, SlotPdoIncrement)
        self.SlotIndexIncrement = _cast(None, SlotIndexIncrement)
        self.MaxInstances = _cast(None, MaxInstances)
        self.SlotGroupIndexIncrement = _cast(None, SlotGroupIndexIncrement)
        self.MinInstances = _cast(None, MinInstances)
        self.TreeView = _cast(None, TreeView)
        self.SlotGroup = _cast(None, SlotGroup)
        self.SlotGroupPdoIncrement = _cast(None, SlotGroupPdoIncrement)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if ModuleIdent is None:
            self.ModuleIdent = []
        else:
            self.ModuleIdent = ModuleIdent
        if ModuleClass is None:
            self.ModuleClass = []
        else:
            self.ModuleClass = ModuleClass
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
    def factory(*args_, **kwargs_):
        if SlotType.subclass:
            return SlotType.subclass(*args_, **kwargs_)
        else:
            return SlotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_ModuleIdent(self): return self.ModuleIdent
    def set_ModuleIdent(self, ModuleIdent): self.ModuleIdent = ModuleIdent
    def add_ModuleIdent(self, value): self.ModuleIdent.append(value)
    def insert_ModuleIdent(self, index, value): self.ModuleIdent[index] = value
    def get_ModuleClass(self): return self.ModuleClass
    def set_ModuleClass(self, ModuleClass): self.ModuleClass = ModuleClass
    def add_ModuleClass(self, value): self.ModuleClass.append(value)
    def insert_ModuleClass(self, index, value): self.ModuleClass[index] = value
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def get_SlotPdoIncrement(self): return self.SlotPdoIncrement
    def set_SlotPdoIncrement(self, SlotPdoIncrement): self.SlotPdoIncrement = SlotPdoIncrement
    def get_SlotIndexIncrement(self): return self.SlotIndexIncrement
    def set_SlotIndexIncrement(self, SlotIndexIncrement): self.SlotIndexIncrement = SlotIndexIncrement
    def get_MaxInstances(self): return self.MaxInstances
    def set_MaxInstances(self, MaxInstances): self.MaxInstances = MaxInstances
    def get_SlotGroupIndexIncrement(self): return self.SlotGroupIndexIncrement
    def set_SlotGroupIndexIncrement(self, SlotGroupIndexIncrement): self.SlotGroupIndexIncrement = SlotGroupIndexIncrement
    def get_MinInstances(self): return self.MinInstances
    def set_MinInstances(self, MinInstances): self.MinInstances = MinInstances
    def get_TreeView(self): return self.TreeView
    def set_TreeView(self, TreeView): self.TreeView = TreeView
    def get_SlotGroup(self): return self.SlotGroup
    def set_SlotGroup(self, SlotGroup): self.SlotGroup = SlotGroup
    def get_SlotGroupPdoIncrement(self): return self.SlotGroupPdoIncrement
    def set_SlotGroupPdoIncrement(self, SlotGroupPdoIncrement): self.SlotGroupPdoIncrement = SlotGroupPdoIncrement
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name or
            self.ModuleIdent or
            self.ModuleClass or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SlotType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SlotType'):
        if self.SlotPdoIncrement is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            outfile.write(' SlotPdoIncrement=%s' % (quote_attrib(self.SlotPdoIncrement), ))
        if self.SlotIndexIncrement is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            outfile.write(' SlotIndexIncrement=%s' % (quote_attrib(self.SlotIndexIncrement), ))
        if self.MaxInstances is not None and 'MaxInstances' not in already_processed:
            already_processed.add('MaxInstances')
            outfile.write(' MaxInstances=%s' % (quote_attrib(self.MaxInstances), ))
        if self.SlotGroupIndexIncrement is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            outfile.write(' SlotGroupIndexIncrement=%s' % (quote_attrib(self.SlotGroupIndexIncrement), ))
        if self.MinInstances is not None and 'MinInstances' not in already_processed:
            already_processed.add('MinInstances')
            outfile.write(' MinInstances=%s' % (quote_attrib(self.MinInstances), ))
        if self.TreeView is not None and 'TreeView' not in already_processed:
            already_processed.add('TreeView')
            outfile.write(' TreeView=%s' % (self.gds_format_string(quote_attrib(self.TreeView).encode(ExternalEncoding), input_name='TreeView'), ))
        if self.SlotGroup is not None and 'SlotGroup' not in already_processed:
            already_processed.add('SlotGroup')
            outfile.write(' SlotGroup=%s' % (quote_attrib(self.SlotGroup), ))
        if self.SlotGroupPdoIncrement is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            outfile.write(' SlotGroupPdoIncrement=%s' % (quote_attrib(self.SlotGroupPdoIncrement), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SlotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for ModuleIdent_ in self.ModuleIdent:
            ModuleIdent_.export(outfile, level, namespace_, name_='ModuleIdent', pretty_print=pretty_print)
        for ModuleClass_ in self.ModuleClass:
            ModuleClass_.export(outfile, level, namespace_, name_='ModuleClass', pretty_print=pretty_print)
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SlotType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SlotPdoIncrement is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            showIndent(outfile, level)
            outfile.write('SlotPdoIncrement="%s",\n' % (self.SlotPdoIncrement,))
        if self.SlotIndexIncrement is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            showIndent(outfile, level)
            outfile.write('SlotIndexIncrement="%s",\n' % (self.SlotIndexIncrement,))
        if self.MaxInstances is not None and 'MaxInstances' not in already_processed:
            already_processed.add('MaxInstances')
            showIndent(outfile, level)
            outfile.write('MaxInstances="%s",\n' % (self.MaxInstances,))
        if self.SlotGroupIndexIncrement is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            showIndent(outfile, level)
            outfile.write('SlotGroupIndexIncrement="%s",\n' % (self.SlotGroupIndexIncrement,))
        if self.MinInstances is not None and 'MinInstances' not in already_processed:
            already_processed.add('MinInstances')
            showIndent(outfile, level)
            outfile.write('MinInstances="%s",\n' % (self.MinInstances,))
        if self.TreeView is not None and 'TreeView' not in already_processed:
            already_processed.add('TreeView')
            showIndent(outfile, level)
            outfile.write('TreeView="%s",\n' % (self.TreeView,))
        if self.SlotGroup is not None and 'SlotGroup' not in already_processed:
            already_processed.add('SlotGroup')
            showIndent(outfile, level)
            outfile.write('SlotGroup="%s",\n' % (self.SlotGroup,))
        if self.SlotGroupPdoIncrement is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            showIndent(outfile, level)
            outfile.write('SlotGroupPdoIncrement="%s",\n' % (self.SlotGroupPdoIncrement,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ModuleIdent=[\n')
        level += 1
        for ModuleIdent_ in self.ModuleIdent:
            showIndent(outfile, level)
            outfile.write('model_.ModuleIdentType(\n')
            ModuleIdent_.exportLiteral(outfile, level, name_='ModuleIdentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ModuleClass=[\n')
        level += 1
        for ModuleClass_ in self.ModuleClass:
            showIndent(outfile, level)
            outfile.write('model_.ModuleClassType(\n')
            ModuleClass_.exportLiteral(outfile, level, name_='ModuleClassType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SlotPdoIncrement', node)
        if value is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            self.SlotPdoIncrement = value
            self.validate_HexDecValue(self.SlotPdoIncrement)    # validate type HexDecValue
        value = find_attr_value_('SlotIndexIncrement', node)
        if value is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            self.SlotIndexIncrement = value
            self.validate_HexDecValue(self.SlotIndexIncrement)    # validate type HexDecValue
        value = find_attr_value_('MaxInstances', node)
        if value is not None and 'MaxInstances' not in already_processed:
            already_processed.add('MaxInstances')
            self.MaxInstances = value
            self.validate_HexDecValue(self.MaxInstances)    # validate type HexDecValue
        value = find_attr_value_('SlotGroupIndexIncrement', node)
        if value is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            self.SlotGroupIndexIncrement = value
            self.validate_HexDecValue(self.SlotGroupIndexIncrement)    # validate type HexDecValue
        value = find_attr_value_('MinInstances', node)
        if value is not None and 'MinInstances' not in already_processed:
            already_processed.add('MinInstances')
            self.MinInstances = value
            self.validate_HexDecValue(self.MinInstances)    # validate type HexDecValue
        value = find_attr_value_('TreeView', node)
        if value is not None and 'TreeView' not in already_processed:
            already_processed.add('TreeView')
            self.TreeView = value
        value = find_attr_value_('SlotGroup', node)
        if value is not None and 'SlotGroup' not in already_processed:
            already_processed.add('SlotGroup')
            self.SlotGroup = value
            self.validate_HexDecValue(self.SlotGroup)    # validate type HexDecValue
        value = find_attr_value_('SlotGroupPdoIncrement', node)
        if value is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            self.SlotGroupPdoIncrement = value
            self.validate_HexDecValue(self.SlotGroupPdoIncrement)    # validate type HexDecValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'ModuleIdent':
            obj_ = ModuleIdentType.factory()
            obj_.build(child_)
            self.ModuleIdent.append(obj_)
        elif nodeName_ == 'ModuleClass':
            obj_ = ModuleClassType.factory()
            obj_.build(child_)
            self.ModuleClass.append(obj_)
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
# end class SlotType


class AccessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReadRestrictions=None, WriteRestrictions=None, valueOf_=None, extensiontype_=None):
        self.ReadRestrictions = _cast(None, ReadRestrictions)
        self.WriteRestrictions = _cast(None, WriteRestrictions)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AccessType.subclass:
            return AccessType.subclass(*args_, **kwargs_)
        else:
            return AccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReadRestrictions(self): return self.ReadRestrictions
    def set_ReadRestrictions(self, ReadRestrictions): self.ReadRestrictions = ReadRestrictions
    def get_WriteRestrictions(self): return self.WriteRestrictions
    def set_WriteRestrictions(self, WriteRestrictions): self.WriteRestrictions = WriteRestrictions
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessType'):
        if self.ReadRestrictions is not None and 'ReadRestrictions' not in already_processed:
            already_processed.add('ReadRestrictions')
            outfile.write(' ReadRestrictions=%s' % (self.gds_format_string(quote_attrib(self.ReadRestrictions).encode(ExternalEncoding), input_name='ReadRestrictions'), ))
        if self.WriteRestrictions is not None and 'WriteRestrictions' not in already_processed:
            already_processed.add('WriteRestrictions')
            outfile.write(' WriteRestrictions=%s' % (self.gds_format_string(quote_attrib(self.WriteRestrictions).encode(ExternalEncoding), input_name='WriteRestrictions'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AccessType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AccessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ReadRestrictions is not None and 'ReadRestrictions' not in already_processed:
            already_processed.add('ReadRestrictions')
            showIndent(outfile, level)
            outfile.write('ReadRestrictions="%s",\n' % (self.ReadRestrictions,))
        if self.WriteRestrictions is not None and 'WriteRestrictions' not in already_processed:
            already_processed.add('WriteRestrictions')
            showIndent(outfile, level)
            outfile.write('WriteRestrictions="%s",\n' % (self.WriteRestrictions,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ReadRestrictions', node)
        if value is not None and 'ReadRestrictions' not in already_processed:
            already_processed.add('ReadRestrictions')
            self.ReadRestrictions = value
        value = find_attr_value_('WriteRestrictions', node)
        if value is not None and 'WriteRestrictions' not in already_processed:
            already_processed.add('WriteRestrictions')
            self.WriteRestrictions = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccessType


class ArrayInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LBound=None, Elements=None):
        self.LBound = LBound
        self.Elements = Elements
    def factory(*args_, **kwargs_):
        if ArrayInfoType.subclass:
            return ArrayInfoType.subclass(*args_, **kwargs_)
        else:
            return ArrayInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LBound(self): return self.LBound
    def set_LBound(self, LBound): self.LBound = LBound
    def get_Elements(self): return self.Elements
    def set_Elements(self, Elements): self.Elements = Elements
    def hasContent_(self):
        if (
            self.LBound is not None or
            self.Elements is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ArrayInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LBound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLBound>%s</%sLBound>%s' % (namespace_, self.gds_format_integer(self.LBound, input_name='LBound'), namespace_, eol_))
        if self.Elements is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sElements>%s</%sElements>%s' % (namespace_, self.gds_format_integer(self.Elements, input_name='Elements'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ArrayInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LBound is not None:
            showIndent(outfile, level)
            outfile.write('LBound=%d,\n' % self.LBound)
        if self.Elements is not None:
            showIndent(outfile, level)
            outfile.write('Elements=%d,\n' % self.Elements)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LBound':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LBound')
            self.LBound = ival_
        elif nodeName_ == 'Elements':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Elements')
            self.Elements = ival_
# end class ArrayInfoType


class DataTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, Name=None, BaseType=None, Comment=None, BitSize=None, ArrayInfo=None, SubItem=None, EnumInfo=None, Properties=None, Xml=None):
        self.Index = Index
        self.Name = Name
        self.BaseType = BaseType
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.BitSize = BitSize
        if ArrayInfo is None:
            self.ArrayInfo = []
        else:
            self.ArrayInfo = ArrayInfo
        if SubItem is None:
            self.SubItem = []
        else:
            self.SubItem = SubItem
        if EnumInfo is None:
            self.EnumInfo = []
        else:
            self.EnumInfo = EnumInfo
        self.Properties = Properties
        self.Xml = Xml
    def factory(*args_, **kwargs_):
        if DataTypeType.subclass:
            return DataTypeType.subclass(*args_, **kwargs_)
        else:
            return DataTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_BaseType(self): return self.BaseType
    def set_BaseType(self, BaseType): self.BaseType = BaseType
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_BitSize(self): return self.BitSize
    def set_BitSize(self, BitSize): self.BitSize = BitSize
    def get_ArrayInfo(self): return self.ArrayInfo
    def set_ArrayInfo(self, ArrayInfo): self.ArrayInfo = ArrayInfo
    def add_ArrayInfo(self, value): self.ArrayInfo.append(value)
    def insert_ArrayInfo(self, index, value): self.ArrayInfo[index] = value
    def get_SubItem(self): return self.SubItem
    def set_SubItem(self, SubItem): self.SubItem = SubItem
    def add_SubItem(self, value): self.SubItem.append(value)
    def insert_SubItem(self, index, value): self.SubItem[index] = value
    def get_EnumInfo(self): return self.EnumInfo
    def set_EnumInfo(self, EnumInfo): self.EnumInfo = EnumInfo
    def add_EnumInfo(self, value): self.EnumInfo.append(value)
    def insert_EnumInfo(self, index, value): self.EnumInfo[index] = value
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    def get_Xml(self): return self.Xml
    def set_Xml(self, Xml): self.Xml = Xml
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Name is not None or
            self.BaseType is not None or
            self.Comment or
            self.BitSize is not None or
            self.ArrayInfo or
            self.SubItem or
            self.EnumInfo or
            self.Properties is not None or
            self.Xml is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.BaseType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBaseType>%s</%sBaseType>%s' % (namespace_, self.gds_format_string(quote_xml(self.BaseType).encode(ExternalEncoding), input_name='BaseType'), namespace_, eol_))
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.BitSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitSize>%s</%sBitSize>%s' % (namespace_, self.gds_format_integer(self.BitSize, input_name='BitSize'), namespace_, eol_))
        for ArrayInfo_ in self.ArrayInfo:
            ArrayInfo_.export(outfile, level, namespace_, name_='ArrayInfo', pretty_print=pretty_print)
        for SubItem_ in self.SubItem:
            SubItem_.export(outfile, level, namespace_, name_='SubItem', pretty_print=pretty_print)
        for EnumInfo_ in self.EnumInfo:
            EnumInfo_.export(outfile, level, namespace_, name_='EnumInfo', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
        if self.Xml is not None:
            self.Xml.export(outfile, level, namespace_, name_='Xml', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.BaseType is not None:
            showIndent(outfile, level)
            outfile.write('BaseType=%s,\n' % quote_python(self.BaseType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BitSize is not None:
            showIndent(outfile, level)
            outfile.write('BitSize=%d,\n' % self.BitSize)
        showIndent(outfile, level)
        outfile.write('ArrayInfo=[\n')
        level += 1
        for ArrayInfo_ in self.ArrayInfo:
            showIndent(outfile, level)
            outfile.write('model_.ArrayInfoType(\n')
            ArrayInfo_.exportLiteral(outfile, level, name_='ArrayInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SubItem=[\n')
        level += 1
        for SubItem_ in self.SubItem:
            showIndent(outfile, level)
            outfile.write('model_.SubItemType(\n')
            SubItem_.exportLiteral(outfile, level, name_='SubItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EnumInfo=[\n')
        level += 1
        for EnumInfo_ in self.EnumInfo:
            showIndent(outfile, level)
            outfile.write('model_.EnumInfoType(\n')
            EnumInfo_.exportLiteral(outfile, level, name_='EnumInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Properties is not None:
            showIndent(outfile, level)
            outfile.write('Properties=model_.PropertiesType(\n')
            self.Properties.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Xml is not None:
            showIndent(outfile, level)
            outfile.write('Xml=model_.XmlType(\n')
            self.Xml.exportLiteral(outfile, level, name_='Xml')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
            self.validate_HexDecValue(self.Index)    # validate type HexDecValue
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'BaseType':
            BaseType_ = child_.text
            BaseType_ = self.gds_validate_string(BaseType_, node, 'BaseType')
            self.BaseType = BaseType_
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'BitSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BitSize')
            self.BitSize = ival_
        elif nodeName_ == 'ArrayInfo':
            obj_ = ArrayInfoType.factory()
            obj_.build(child_)
            self.ArrayInfo.append(obj_)
        elif nodeName_ == 'SubItem':
            obj_ = SubItemType.factory()
            obj_.build(child_)
            self.SubItem.append(obj_)
        elif nodeName_ == 'EnumInfo':
            obj_ = EnumInfoType.factory()
            obj_.build(child_)
            self.EnumInfo.append(obj_)
        elif nodeName_ == 'Properties':
            obj_ = PropertiesType.factory()
            obj_.build(child_)
            self.Properties = obj_
        elif nodeName_ == 'Xml':
            obj_ = XmlType.factory()
            obj_.build(child_)
            self.Xml = obj_
# end class DataTypeType


class PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None, Desc=None):
        self.Name = Name
        self.Value = Value
        self.Desc = Desc
    def factory(*args_, **kwargs_):
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Desc(self): return self.Desc
    def set_Desc(self, Desc): self.Desc = Desc
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None or
            self.Desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.Desc is not None:
            self.Desc.export(outfile, level, namespace_, name_='Desc', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.Desc is not None:
            showIndent(outfile, level)
            outfile.write('Desc=model_.NameType(\n')
            self.Desc.exportLiteral(outfile, level, name_='Desc')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'Desc':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Desc = obj_
# end class PropertyType


class SubItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SubIdx=None, Name=None, DisplayName=None, Type=None, Comment=None, BitSize=None, BitOffs=None, DefaultString=None, DefaultData=None, MinValue=None, MaxValue=None, DefaultValue=None, Flags=None, Property=None, Xml=None):
        self.SubIdx = SubIdx
        self.Name = Name
        if DisplayName is None:
            self.DisplayName = []
        else:
            self.DisplayName = DisplayName
        self.Type = Type
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.BitSize = BitSize
        self.BitOffs = BitOffs
        self.DefaultString = DefaultString
        self.DefaultData = DefaultData
        self.MinValue = MinValue
        self.MaxValue = MaxValue
        self.DefaultValue = DefaultValue
        self.Flags = Flags
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        self.Xml = Xml
    def factory(*args_, **kwargs_):
        if SubItemType.subclass:
            return SubItemType.subclass(*args_, **kwargs_)
        else:
            return SubItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubIdx(self): return self.SubIdx
    def set_SubIdx(self, SubIdx): self.SubIdx = SubIdx
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def add_DisplayName(self, value): self.DisplayName.append(value)
    def insert_DisplayName(self, index, value): self.DisplayName[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_BitSize(self): return self.BitSize
    def set_BitSize(self, BitSize): self.BitSize = BitSize
    def get_BitOffs(self): return self.BitOffs
    def set_BitOffs(self, BitOffs): self.BitOffs = BitOffs
    def get_DefaultString(self): return self.DefaultString
    def set_DefaultString(self, DefaultString): self.DefaultString = DefaultString
    def get_DefaultData(self): return self.DefaultData
    def set_DefaultData(self, DefaultData): self.DefaultData = DefaultData
    def get_MinValue(self): return self.MinValue
    def set_MinValue(self, MinValue): self.MinValue = MinValue
    def get_MaxValue(self): return self.MaxValue
    def set_MaxValue(self, MaxValue): self.MaxValue = MaxValue
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Flags(self): return self.Flags
    def set_Flags(self, Flags): self.Flags = Flags
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def get_Xml(self): return self.Xml
    def set_Xml(self, Xml): self.Xml = Xml
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SubIdx is not None or
            self.Name is not None or
            self.DisplayName or
            self.Type is not None or
            self.Comment or
            self.BitSize is not None or
            self.BitOffs is not None or
            self.DefaultString is not None or
            self.DefaultData is not None or
            self.MinValue is not None or
            self.MaxValue is not None or
            self.DefaultValue is not None or
            self.Flags is not None or
            self.Property or
            self.Xml is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubItemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubItemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubIdx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubIdx>%s</%sSubIdx>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubIdx).encode(ExternalEncoding), input_name='SubIdx'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        for DisplayName_ in self.DisplayName:
            DisplayName_.export(outfile, level, namespace_, name_='DisplayName', pretty_print=pretty_print)
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.BitSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitSize>%s</%sBitSize>%s' % (namespace_, self.gds_format_integer(self.BitSize, input_name='BitSize'), namespace_, eol_))
        if self.BitOffs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitOffs>%s</%sBitOffs>%s' % (namespace_, self.gds_format_integer(self.BitOffs, input_name='BitOffs'), namespace_, eol_))
        if self.DefaultString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultString>%s</%sDefaultString>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultString).encode(ExternalEncoding), input_name='DefaultString'), namespace_, eol_))
        if self.DefaultData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultData>%s</%sDefaultData>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultData).encode(ExternalEncoding), input_name='DefaultData'), namespace_, eol_))
        if self.MinValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinValue>%s</%sMinValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MinValue).encode(ExternalEncoding), input_name='MinValue'), namespace_, eol_))
        if self.MaxValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxValue>%s</%sMaxValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MaxValue).encode(ExternalEncoding), input_name='MaxValue'), namespace_, eol_))
        if self.DefaultValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultValue>%s</%sDefaultValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), namespace_, eol_))
        if self.Flags is not None:
            self.Flags.export(outfile, level, namespace_, name_='Flags', pretty_print=pretty_print)
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        if self.Xml is not None:
            self.Xml.export(outfile, level, namespace_, name_='Xml', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubItemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SubIdx is not None:
            showIndent(outfile, level)
            outfile.write('SubIdx=%s,\n' % quote_python(self.SubIdx).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('DisplayName=[\n')
        level += 1
        for DisplayName_ in self.DisplayName:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            DisplayName_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BitSize is not None:
            showIndent(outfile, level)
            outfile.write('BitSize=%d,\n' % self.BitSize)
        if self.BitOffs is not None:
            showIndent(outfile, level)
            outfile.write('BitOffs=%d,\n' % self.BitOffs)
        if self.DefaultString is not None:
            showIndent(outfile, level)
            outfile.write('DefaultString=%s,\n' % quote_python(self.DefaultString).encode(ExternalEncoding))
        if self.DefaultData is not None:
            showIndent(outfile, level)
            outfile.write('DefaultData=%s,\n' % quote_python(self.DefaultData).encode(ExternalEncoding))
        if self.MinValue is not None:
            showIndent(outfile, level)
            outfile.write('MinValue=%s,\n' % quote_python(self.MinValue).encode(ExternalEncoding))
        if self.MaxValue is not None:
            showIndent(outfile, level)
            outfile.write('MaxValue=%s,\n' % quote_python(self.MaxValue).encode(ExternalEncoding))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('DefaultValue=%s,\n' % quote_python(self.DefaultValue).encode(ExternalEncoding))
        if self.Flags is not None:
            showIndent(outfile, level)
            outfile.write('Flags=model_.FlagsType(\n')
            self.Flags.exportLiteral(outfile, level, name_='Flags')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Xml is not None:
            showIndent(outfile, level)
            outfile.write('Xml=model_.XmlType23(\n')
            self.Xml.exportLiteral(outfile, level, name_='Xml')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubIdx':
            SubIdx_ = child_.text
            SubIdx_ = self.gds_validate_string(SubIdx_, node, 'SubIdx')
            self.SubIdx = SubIdx_
            self.validate_HexDecValue(self.SubIdx)    # validate type HexDecValue
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'DisplayName':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DisplayName.append(obj_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'BitSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BitSize')
            self.BitSize = ival_
        elif nodeName_ == 'BitOffs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BitOffs')
            self.BitOffs = ival_
        elif nodeName_ == 'DefaultString':
            DefaultString_ = child_.text
            DefaultString_ = self.gds_validate_string(DefaultString_, node, 'DefaultString')
            self.DefaultString = DefaultString_
        elif nodeName_ == 'DefaultData':
            DefaultData_ = child_.text
            DefaultData_ = self.gds_validate_string(DefaultData_, node, 'DefaultData')
            self.DefaultData = DefaultData_
        elif nodeName_ == 'MinValue':
            MinValue_ = child_.text
            MinValue_ = self.gds_validate_string(MinValue_, node, 'MinValue')
            self.MinValue = MinValue_
            self.validate_HexDecValue(self.MinValue)    # validate type HexDecValue
        elif nodeName_ == 'MaxValue':
            MaxValue_ = child_.text
            MaxValue_ = self.gds_validate_string(MaxValue_, node, 'MaxValue')
            self.MaxValue = MaxValue_
            self.validate_HexDecValue(self.MaxValue)    # validate type HexDecValue
        elif nodeName_ == 'DefaultValue':
            DefaultValue_ = child_.text
            DefaultValue_ = self.gds_validate_string(DefaultValue_, node, 'DefaultValue')
            self.DefaultValue = DefaultValue_
            self.validate_HexDecValue(self.DefaultValue)    # validate type HexDecValue
        elif nodeName_ == 'Flags':
            obj_ = FlagsType.factory()
            obj_.build(child_)
            self.Flags = obj_
        elif nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
        elif nodeName_ == 'Xml':
            obj_ = XmlType23.factory()
            obj_.build(child_)
            self.Xml = obj_
# end class SubItemType


class EnumInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text=None, Enum=None, Comment=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        self.Enum = Enum
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if EnumInfoType.subclass:
            return EnumInfoType.subclass(*args_, **kwargs_)
        else:
            return EnumInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_Enum(self): return self.Enum
    def set_Enum(self, Enum): self.Enum = Enum
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Text or
            self.Enum is not None or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnumInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnumInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnumInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EnumInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
        if self.Enum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnum>%s</%sEnum>%s' % (namespace_, self.gds_format_integer(self.Enum, input_name='Enum'), namespace_, eol_))
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EnumInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Text_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Enum is not None:
            showIndent(outfile, level)
            outfile.write('Enum=%d,\n' % self.Enum)
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Text.append(obj_)
        elif nodeName_ == 'Enum':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Enum')
            self.Enum = ival_
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
# end class EnumInfoType


class NameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LcId=1033, valueOf_=None, extensiontype_=None):
        self.LcId = _cast(int, LcId)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LcId(self): return self.LcId
    def set_LcId(self, LcId): self.LcId = LcId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameType'):
        if self.LcId is not None and 'LcId' not in already_processed:
            already_processed.add('LcId')
            outfile.write(' LcId="%s"' % self.gds_format_integer(self.LcId, input_name='LcId'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='NameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LcId is not None and 'LcId' not in already_processed:
            already_processed.add('LcId')
            showIndent(outfile, level)
            outfile.write('LcId=%d,\n' % (self.LcId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LcId', node)
        if value is not None and 'LcId' not in already_processed:
            already_processed.add('LcId')
            try:
                self.LcId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType


class DictionaryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitTypes=None, DataTypes=None, Objects=None):
        self.UnitTypes = UnitTypes
        self.DataTypes = DataTypes
        self.Objects = Objects
    def factory(*args_, **kwargs_):
        if DictionaryType.subclass:
            return DictionaryType.subclass(*args_, **kwargs_)
        else:
            return DictionaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitTypes(self): return self.UnitTypes
    def set_UnitTypes(self, UnitTypes): self.UnitTypes = UnitTypes
    def get_DataTypes(self): return self.DataTypes
    def set_DataTypes(self, DataTypes): self.DataTypes = DataTypes
    def get_Objects(self): return self.Objects
    def set_Objects(self, Objects): self.Objects = Objects
    def hasContent_(self):
        if (
            self.UnitTypes is not None or
            self.DataTypes is not None or
            self.Objects is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DictionaryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DictionaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DictionaryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DictionaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitTypes is not None:
            self.UnitTypes.export(outfile, level, namespace_, name_='UnitTypes', pretty_print=pretty_print)
        if self.DataTypes is not None:
            self.DataTypes.export(outfile, level, namespace_, name_='DataTypes', pretty_print=pretty_print)
        if self.Objects is not None:
            self.Objects.export(outfile, level, namespace_, name_='Objects', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DictionaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.UnitTypes is not None:
            showIndent(outfile, level)
            outfile.write('UnitTypes=model_.UnitTypesType(\n')
            self.UnitTypes.exportLiteral(outfile, level, name_='UnitTypes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataTypes is not None:
            showIndent(outfile, level)
            outfile.write('DataTypes=model_.DataTypesType(\n')
            self.DataTypes.exportLiteral(outfile, level, name_='DataTypes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Objects is not None:
            showIndent(outfile, level)
            outfile.write('Objects=model_.ObjectsType(\n')
            self.Objects.exportLiteral(outfile, level, name_='Objects')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitTypes':
            obj_ = UnitTypesType.factory()
            obj_.build(child_)
            self.UnitTypes = obj_
        elif nodeName_ == 'DataTypes':
            obj_ = DataTypesType.factory()
            obj_.build(child_)
            self.DataTypes = obj_
        elif nodeName_ == 'Objects':
            obj_ = ObjectsType.factory()
            obj_.build(child_)
            self.Objects = obj_
# end class DictionaryType


class ObjectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, Name=None, Comment=None, Type=None, BitSize=None, Info=None, Flags=None, Properties=None, Xml=None):
        self.Index = Index
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Type = Type
        self.BitSize = BitSize
        self.Info = Info
        self.Flags = Flags
        self.Properties = Properties
        self.Xml = Xml
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_BitSize(self): return self.BitSize
    def set_BitSize(self, BitSize): self.BitSize = BitSize
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_Flags(self): return self.Flags
    def set_Flags(self, Flags): self.Flags = Flags
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    def get_Xml(self): return self.Xml
    def set_Xml(self, Xml): self.Xml = Xml
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Name or
            self.Comment or
            self.Type is not None or
            self.BitSize is not None or
            self.Info is not None or
            self.Flags is not None or
            self.Properties is not None or
            self.Xml is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            self.Index.export(outfile, level, namespace_, name_='Index', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.BitSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitSize>%s</%sBitSize>%s' % (namespace_, self.gds_format_integer(self.BitSize, input_name='BitSize'), namespace_, eol_))
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
        if self.Flags is not None:
            self.Flags.export(outfile, level, namespace_, name_='Flags', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
        if self.Xml is not None:
            self.Xml.export(outfile, level, namespace_, name_='Xml', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=model_.IndexType(\n')
            self.Index.exportLiteral(outfile, level, name_='Index')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.BitSize is not None:
            showIndent(outfile, level)
            outfile.write('BitSize=%d,\n' % self.BitSize)
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.ObjectInfoType(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Flags is not None:
            showIndent(outfile, level)
            outfile.write('Flags=model_.FlagsType24(\n')
            self.Flags.exportLiteral(outfile, level, name_='Flags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Properties is not None:
            showIndent(outfile, level)
            outfile.write('Properties=model_.PropertiesType30(\n')
            self.Properties.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Xml is not None:
            showIndent(outfile, level)
            outfile.write('Xml=model_.XmlType31(\n')
            self.Xml.exportLiteral(outfile, level, name_='Xml')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            obj_ = IndexType.factory()
            obj_.build(child_)
            self.Index = obj_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'BitSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BitSize')
            self.BitSize = ival_
        elif nodeName_ == 'Info':
            obj_ = ObjectInfoType.factory()
            obj_.build(child_)
            self.Info = obj_
        elif nodeName_ == 'Flags':
            obj_ = FlagsType24.factory()
            obj_.build(child_)
            self.Flags = obj_
        elif nodeName_ == 'Properties':
            obj_ = PropertiesType30.factory()
            obj_.build(child_)
            self.Properties = obj_
        elif nodeName_ == 'Xml':
            obj_ = XmlType31.factory()
            obj_.build(child_)
            self.Xml = obj_
# end class ObjectType


class ObjectInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DefaultString=None, MinData=None, MaxData=None, DefaultData=None, MinValue=None, MaxValue=None, DefaultValue=None, SubItem=None, Unit=None):
        self.DefaultString = DefaultString
        self.MinData = MinData
        self.MaxData = MaxData
        self.DefaultData = DefaultData
        self.MinValue = MinValue
        self.MaxValue = MaxValue
        self.DefaultValue = DefaultValue
        if SubItem is None:
            self.SubItem = []
        else:
            self.SubItem = SubItem
        self.Unit = Unit
    def factory(*args_, **kwargs_):
        if ObjectInfoType.subclass:
            return ObjectInfoType.subclass(*args_, **kwargs_)
        else:
            return ObjectInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultString(self): return self.DefaultString
    def set_DefaultString(self, DefaultString): self.DefaultString = DefaultString
    def get_MinData(self): return self.MinData
    def set_MinData(self, MinData): self.MinData = MinData
    def get_MaxData(self): return self.MaxData
    def set_MaxData(self, MaxData): self.MaxData = MaxData
    def get_DefaultData(self): return self.DefaultData
    def set_DefaultData(self, DefaultData): self.DefaultData = DefaultData
    def get_MinValue(self): return self.MinValue
    def set_MinValue(self, MinValue): self.MinValue = MinValue
    def get_MaxValue(self): return self.MaxValue
    def set_MaxValue(self, MaxValue): self.MaxValue = MaxValue
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_SubItem(self): return self.SubItem
    def set_SubItem(self, SubItem): self.SubItem = SubItem
    def add_SubItem(self, value): self.SubItem.append(value)
    def insert_SubItem(self, index, value): self.SubItem[index] = value
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DefaultString is not None or
            self.MinData is not None or
            self.MaxData is not None or
            self.DefaultData is not None or
            self.MinValue is not None or
            self.MaxValue is not None or
            self.DefaultValue is not None or
            self.SubItem or
            self.Unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultString>%s</%sDefaultString>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultString).encode(ExternalEncoding), input_name='DefaultString'), namespace_, eol_))
        if self.MinData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinData>%s</%sMinData>%s' % (namespace_, self.gds_format_string(quote_xml(self.MinData).encode(ExternalEncoding), input_name='MinData'), namespace_, eol_))
        if self.MaxData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxData>%s</%sMaxData>%s' % (namespace_, self.gds_format_string(quote_xml(self.MaxData).encode(ExternalEncoding), input_name='MaxData'), namespace_, eol_))
        if self.DefaultData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultData>%s</%sDefaultData>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultData).encode(ExternalEncoding), input_name='DefaultData'), namespace_, eol_))
        if self.MinValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinValue>%s</%sMinValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MinValue).encode(ExternalEncoding), input_name='MinValue'), namespace_, eol_))
        if self.MaxValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxValue>%s</%sMaxValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MaxValue).encode(ExternalEncoding), input_name='MaxValue'), namespace_, eol_))
        if self.DefaultValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultValue>%s</%sDefaultValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), namespace_, eol_))
        for SubItem_ in self.SubItem:
            SubItem_.export(outfile, level, namespace_, name_='SubItem', pretty_print=pretty_print)
        if self.Unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_format_string(quote_xml(self.Unit).encode(ExternalEncoding), input_name='Unit'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ObjectInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefaultString is not None:
            showIndent(outfile, level)
            outfile.write('DefaultString=%s,\n' % quote_python(self.DefaultString).encode(ExternalEncoding))
        if self.MinData is not None:
            showIndent(outfile, level)
            outfile.write('MinData=%s,\n' % quote_python(self.MinData).encode(ExternalEncoding))
        if self.MaxData is not None:
            showIndent(outfile, level)
            outfile.write('MaxData=%s,\n' % quote_python(self.MaxData).encode(ExternalEncoding))
        if self.DefaultData is not None:
            showIndent(outfile, level)
            outfile.write('DefaultData=%s,\n' % quote_python(self.DefaultData).encode(ExternalEncoding))
        if self.MinValue is not None:
            showIndent(outfile, level)
            outfile.write('MinValue=%s,\n' % quote_python(self.MinValue).encode(ExternalEncoding))
        if self.MaxValue is not None:
            showIndent(outfile, level)
            outfile.write('MaxValue=%s,\n' % quote_python(self.MaxValue).encode(ExternalEncoding))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('DefaultValue=%s,\n' % quote_python(self.DefaultValue).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SubItem=[\n')
        level += 1
        for SubItem_ in self.SubItem:
            showIndent(outfile, level)
            outfile.write('model_.SubItemType32(\n')
            SubItem_.exportLiteral(outfile, level, name_='SubItemType32')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Unit is not None:
            showIndent(outfile, level)
            outfile.write('Unit=%s,\n' % quote_python(self.Unit).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultString':
            DefaultString_ = child_.text
            DefaultString_ = self.gds_validate_string(DefaultString_, node, 'DefaultString')
            self.DefaultString = DefaultString_
        elif nodeName_ == 'MinData':
            MinData_ = child_.text
            MinData_ = self.gds_validate_string(MinData_, node, 'MinData')
            self.MinData = MinData_
        elif nodeName_ == 'MaxData':
            MaxData_ = child_.text
            MaxData_ = self.gds_validate_string(MaxData_, node, 'MaxData')
            self.MaxData = MaxData_
        elif nodeName_ == 'DefaultData':
            DefaultData_ = child_.text
            DefaultData_ = self.gds_validate_string(DefaultData_, node, 'DefaultData')
            self.DefaultData = DefaultData_
        elif nodeName_ == 'MinValue':
            MinValue_ = child_.text
            MinValue_ = self.gds_validate_string(MinValue_, node, 'MinValue')
            self.MinValue = MinValue_
            self.validate_HexDecValue(self.MinValue)    # validate type HexDecValue
        elif nodeName_ == 'MaxValue':
            MaxValue_ = child_.text
            MaxValue_ = self.gds_validate_string(MaxValue_, node, 'MaxValue')
            self.MaxValue = MaxValue_
            self.validate_HexDecValue(self.MaxValue)    # validate type HexDecValue
        elif nodeName_ == 'DefaultValue':
            DefaultValue_ = child_.text
            DefaultValue_ = self.gds_validate_string(DefaultValue_, node, 'DefaultValue')
            self.DefaultValue = DefaultValue_
            self.validate_HexDecValue(self.DefaultValue)    # validate type HexDecValue
        elif nodeName_ == 'SubItem':
            obj_ = SubItemType32.factory()
            obj_.build(child_)
            self.SubItem.append(obj_)
        elif nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit = Unit_
            self.validate_HexDecValue(self.Unit)    # validate type HexDecValue
# end class ObjectInfoType


class EntryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, SubIndex=None, BitLen=None, Name=None, Comment=None, DataType=None, extensiontype_=None):
        self.Index = Index
        self.SubIndex = SubIndex
        self.BitLen = BitLen
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Comment = Comment
        self.DataType = DataType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntryType.subclass:
            return EntryType.subclass(*args_, **kwargs_)
        else:
            return EntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_SubIndex(self): return self.SubIndex
    def set_SubIndex(self, SubIndex): self.SubIndex = SubIndex
    def get_BitLen(self): return self.BitLen
    def set_BitLen(self, BitLen): self.BitLen = BitLen
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Index is not None or
            self.SubIndex is not None or
            self.BitLen is not None or
            self.Name or
            self.Comment is not None or
            self.DataType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            self.Index.export(outfile, level, namespace_, name_='Index', pretty_print=pretty_print)
        if self.SubIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubIndex>%s</%sSubIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubIndex).encode(ExternalEncoding), input_name='SubIndex'), namespace_, eol_))
        if self.BitLen is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitLen>%s</%sBitLen>%s' % (namespace_, self.gds_format_integer(self.BitLen, input_name='BitLen'), namespace_, eol_))
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
        if self.DataType is not None:
            self.DataType.export(outfile, level, namespace_, name_='DataType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=model_.IndexType33(\n')
            self.Index.exportLiteral(outfile, level, name_='Index')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubIndex is not None:
            showIndent(outfile, level)
            outfile.write('SubIndex=%s,\n' % quote_python(self.SubIndex).encode(ExternalEncoding))
        if self.BitLen is not None:
            showIndent(outfile, level)
            outfile.write('BitLen=%d,\n' % self.BitLen)
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
        if self.DataType is not None:
            showIndent(outfile, level)
            outfile.write('DataType=model_.DataTypeType34(\n')
            self.DataType.exportLiteral(outfile, level, name_='DataType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            obj_ = IndexType33.factory()
            obj_.build(child_)
            self.Index = obj_
        elif nodeName_ == 'SubIndex':
            SubIndex_ = child_.text
            SubIndex_ = self.gds_validate_string(SubIndex_, node, 'SubIndex')
            self.SubIndex = SubIndex_
            self.validate_HexDecValue(self.SubIndex)    # validate type HexDecValue
        elif nodeName_ == 'BitLen':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BitLen')
            self.BitLen = ival_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
        elif nodeName_ == 'DataType':
            obj_ = DataTypeType34.factory()
            obj_.build(child_)
            self.DataType = obj_
# end class EntryType


class PdoType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, Mandatory=None, OSMax=None, OSIndexInc=None, OverwrittenByModule=None, Su=None, OSMin=None, PdoOrder=None, Virtual=None, Sm=None, OSFac=None, Fixed=None, SRA_Parameter=None, Index=None, Name=None, Exclude=None, Entry=None, ExcludedSm=None):
        self.Mandatory = _cast(bool, Mandatory)
        self.OSMax = _cast(int, OSMax)
        self.OSIndexInc = _cast(int, OSIndexInc)
        self.OverwrittenByModule = _cast(bool, OverwrittenByModule)
        self.Su = _cast(int, Su)
        self.OSMin = _cast(int, OSMin)
        self.PdoOrder = _cast(int, PdoOrder)
        self.Virtual = _cast(bool, Virtual)
        self.Sm = _cast(int, Sm)
        self.OSFac = _cast(int, OSFac)
        self.Fixed = _cast(bool, Fixed)
        self.SRA_Parameter = _cast(bool, SRA_Parameter)
        self.Index = Index
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Exclude is None:
            self.Exclude = []
        else:
            self.Exclude = Exclude
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
        if ExcludedSm is None:
            self.ExcludedSm = []
        else:
            self.ExcludedSm = ExcludedSm
    def factory(*args_, **kwargs_):
        if PdoType.subclass:
            return PdoType.subclass(*args_, **kwargs_)
        else:
            return PdoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Exclude(self): return self.Exclude
    def set_Exclude(self, Exclude): self.Exclude = Exclude
    def add_Exclude(self, value): self.Exclude.append(value)
    def insert_Exclude(self, index, value): self.Exclude[index] = value
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry(self, index, value): self.Entry[index] = value
    def get_ExcludedSm(self): return self.ExcludedSm
    def set_ExcludedSm(self, ExcludedSm): self.ExcludedSm = ExcludedSm
    def add_ExcludedSm(self, value): self.ExcludedSm.append(value)
    def insert_ExcludedSm(self, index, value): self.ExcludedSm[index] = value
    def get_Mandatory(self): return self.Mandatory
    def set_Mandatory(self, Mandatory): self.Mandatory = Mandatory
    def get_OSMax(self): return self.OSMax
    def set_OSMax(self, OSMax): self.OSMax = OSMax
    def get_OSIndexInc(self): return self.OSIndexInc
    def set_OSIndexInc(self, OSIndexInc): self.OSIndexInc = OSIndexInc
    def get_OverwrittenByModule(self): return self.OverwrittenByModule
    def set_OverwrittenByModule(self, OverwrittenByModule): self.OverwrittenByModule = OverwrittenByModule
    def get_Su(self): return self.Su
    def set_Su(self, Su): self.Su = Su
    def get_OSMin(self): return self.OSMin
    def set_OSMin(self, OSMin): self.OSMin = OSMin
    def get_PdoOrder(self): return self.PdoOrder
    def set_PdoOrder(self, PdoOrder): self.PdoOrder = PdoOrder
    def get_Virtual(self): return self.Virtual
    def set_Virtual(self, Virtual): self.Virtual = Virtual
    def get_Sm(self): return self.Sm
    def set_Sm(self, Sm): self.Sm = Sm
    def get_OSFac(self): return self.OSFac
    def set_OSFac(self, OSFac): self.OSFac = OSFac
    def get_Fixed(self): return self.Fixed
    def set_Fixed(self, Fixed): self.Fixed = Fixed
    def get_SRA_Parameter(self): return self.SRA_Parameter
    def set_SRA_Parameter(self, SRA_Parameter): self.SRA_Parameter = SRA_Parameter
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Name or
            self.Exclude or
            self.Entry or
            self.ExcludedSm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PdoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PdoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PdoType'):
        if self.Mandatory is not None and 'Mandatory' not in already_processed:
            already_processed.add('Mandatory')
            outfile.write(' Mandatory="%s"' % self.gds_format_boolean(self.Mandatory, input_name='Mandatory'))
        if self.OSMax is not None and 'OSMax' not in already_processed:
            already_processed.add('OSMax')
            outfile.write(' OSMax="%s"' % self.gds_format_integer(self.OSMax, input_name='OSMax'))
        if self.OSIndexInc is not None and 'OSIndexInc' not in already_processed:
            already_processed.add('OSIndexInc')
            outfile.write(' OSIndexInc="%s"' % self.gds_format_integer(self.OSIndexInc, input_name='OSIndexInc'))
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            outfile.write(' OverwrittenByModule="%s"' % self.gds_format_boolean(self.OverwrittenByModule, input_name='OverwrittenByModule'))
        if self.Su is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            outfile.write(' Su="%s"' % self.gds_format_integer(self.Su, input_name='Su'))
        if self.OSMin is not None and 'OSMin' not in already_processed:
            already_processed.add('OSMin')
            outfile.write(' OSMin="%s"' % self.gds_format_integer(self.OSMin, input_name='OSMin'))
        if self.PdoOrder is not None and 'PdoOrder' not in already_processed:
            already_processed.add('PdoOrder')
            outfile.write(' PdoOrder="%s"' % self.gds_format_integer(self.PdoOrder, input_name='PdoOrder'))
        if self.Virtual is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            outfile.write(' Virtual="%s"' % self.gds_format_boolean(self.Virtual, input_name='Virtual'))
        if self.Sm is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            outfile.write(' Sm="%s"' % self.gds_format_integer(self.Sm, input_name='Sm'))
        if self.OSFac is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            outfile.write(' OSFac="%s"' % self.gds_format_integer(self.OSFac, input_name='OSFac'))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            outfile.write(' Fixed="%s"' % self.gds_format_boolean(self.Fixed, input_name='Fixed'))
        if self.SRA_Parameter is not None and 'SRA_Parameter' not in already_processed:
            already_processed.add('SRA_Parameter')
            outfile.write(' SRA_Parameter="%s"' % self.gds_format_boolean(self.SRA_Parameter, input_name='SRA_Parameter'))
    def exportChildren(self, outfile, level, namespace_='', name_='PdoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            self.Index.export(outfile, level, namespace_, name_='Index', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Exclude_ in self.Exclude:
            Exclude_.export(outfile, level, namespace_, name_='Exclude', pretty_print=pretty_print)
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
        for ExcludedSm_ in self.ExcludedSm:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExcludedSm>%s</%sExcludedSm>%s' % (namespace_, self.gds_format_integer(ExcludedSm_, input_name='ExcludedSm'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PdoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Mandatory is not None and 'Mandatory' not in already_processed:
            already_processed.add('Mandatory')
            showIndent(outfile, level)
            outfile.write('Mandatory=%s,\n' % (self.Mandatory,))
        if self.OSMax is not None and 'OSMax' not in already_processed:
            already_processed.add('OSMax')
            showIndent(outfile, level)
            outfile.write('OSMax=%d,\n' % (self.OSMax,))
        if self.OSIndexInc is not None and 'OSIndexInc' not in already_processed:
            already_processed.add('OSIndexInc')
            showIndent(outfile, level)
            outfile.write('OSIndexInc=%d,\n' % (self.OSIndexInc,))
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            showIndent(outfile, level)
            outfile.write('OverwrittenByModule=%s,\n' % (self.OverwrittenByModule,))
        if self.Su is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            showIndent(outfile, level)
            outfile.write('Su=%d,\n' % (self.Su,))
        if self.OSMin is not None and 'OSMin' not in already_processed:
            already_processed.add('OSMin')
            showIndent(outfile, level)
            outfile.write('OSMin=%d,\n' % (self.OSMin,))
        if self.PdoOrder is not None and 'PdoOrder' not in already_processed:
            already_processed.add('PdoOrder')
            showIndent(outfile, level)
            outfile.write('PdoOrder=%d,\n' % (self.PdoOrder,))
        if self.Virtual is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            showIndent(outfile, level)
            outfile.write('Virtual=%s,\n' % (self.Virtual,))
        if self.Sm is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            showIndent(outfile, level)
            outfile.write('Sm=%d,\n' % (self.Sm,))
        if self.OSFac is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            showIndent(outfile, level)
            outfile.write('OSFac=%d,\n' % (self.OSFac,))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            showIndent(outfile, level)
            outfile.write('Fixed=%s,\n' % (self.Fixed,))
        if self.SRA_Parameter is not None and 'SRA_Parameter' not in already_processed:
            already_processed.add('SRA_Parameter')
            showIndent(outfile, level)
            outfile.write('SRA_Parameter=%s,\n' % (self.SRA_Parameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=model_.IndexType35(\n')
            self.Index.exportLiteral(outfile, level, name_='Index')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Exclude=[\n')
        level += 1
        for Exclude_ in self.Exclude:
            showIndent(outfile, level)
            outfile.write('model_.ExcludeType(\n')
            Exclude_.exportLiteral(outfile, level, name_='ExcludeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType36(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType36')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ExcludedSm=[\n')
        level += 1
        for ExcludedSm_ in self.ExcludedSm:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ExcludedSm_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Mandatory', node)
        if value is not None and 'Mandatory' not in already_processed:
            already_processed.add('Mandatory')
            if value in ('true', '1'):
                self.Mandatory = True
            elif value in ('false', '0'):
                self.Mandatory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OSMax', node)
        if value is not None and 'OSMax' not in already_processed:
            already_processed.add('OSMax')
            try:
                self.OSMax = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OSIndexInc', node)
        if value is not None and 'OSIndexInc' not in already_processed:
            already_processed.add('OSIndexInc')
            try:
                self.OSIndexInc = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OverwrittenByModule', node)
        if value is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            if value in ('true', '1'):
                self.OverwrittenByModule = True
            elif value in ('false', '0'):
                self.OverwrittenByModule = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Su', node)
        if value is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            try:
                self.Su = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OSMin', node)
        if value is not None and 'OSMin' not in already_processed:
            already_processed.add('OSMin')
            try:
                self.OSMin = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('PdoOrder', node)
        if value is not None and 'PdoOrder' not in already_processed:
            already_processed.add('PdoOrder')
            try:
                self.PdoOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Virtual', node)
        if value is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            if value in ('true', '1'):
                self.Virtual = True
            elif value in ('false', '0'):
                self.Virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Sm', node)
        if value is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            try:
                self.Sm = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OSFac', node)
        if value is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            try:
                self.OSFac = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Fixed', node)
        if value is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            if value in ('true', '1'):
                self.Fixed = True
            elif value in ('false', '0'):
                self.Fixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SRA_Parameter', node)
        if value is not None and 'SRA_Parameter' not in already_processed:
            already_processed.add('SRA_Parameter')
            if value in ('true', '1'):
                self.SRA_Parameter = True
            elif value in ('false', '0'):
                self.SRA_Parameter = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            obj_ = IndexType35.factory()
            obj_.build(child_)
            self.Index = obj_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Exclude':
            obj_ = ExcludeType.factory()
            obj_.build(child_)
            self.Exclude.append(obj_)
        elif nodeName_ == 'Entry':
            obj_ = EntryType36.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
        elif nodeName_ == 'ExcludedSm':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ExcludedSm')
            self.ExcludedSm.append(ival_)
# end class PdoType


class VendorSpecificType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if VendorSpecificType.subclass:
            return VendorSpecificType.subclass(*args_, **kwargs_)
        else:
            return VendorSpecificType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorSpecificType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorSpecificType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorSpecificType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VendorSpecificType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorSpecificType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VendorSpecificType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VendorSpecificType


class ProfileType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ProfileNo=None, AddInfo=None, ChannelCount=None, ChannelInfo=None, DictionaryFile=None, Dictionary=None, DiagFile=None, DiagMessages=None, VendorSpecific=None, extensiontype_=None):
        self.ProfileNo = ProfileNo
        self.AddInfo = AddInfo
        self.ChannelCount = ChannelCount
        if ChannelInfo is None:
            self.ChannelInfo = []
        else:
            self.ChannelInfo = ChannelInfo
        self.DictionaryFile = DictionaryFile
        self.Dictionary = Dictionary
        if DiagFile is None:
            self.DiagFile = []
        else:
            self.DiagFile = DiagFile
        if DiagMessages is None:
            self.DiagMessages = []
        else:
            self.DiagMessages = DiagMessages
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ProfileType.subclass:
            return ProfileType.subclass(*args_, **kwargs_)
        else:
            return ProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProfileNo(self): return self.ProfileNo
    def set_ProfileNo(self, ProfileNo): self.ProfileNo = ProfileNo
    def get_AddInfo(self): return self.AddInfo
    def set_AddInfo(self, AddInfo): self.AddInfo = AddInfo
    def get_ChannelCount(self): return self.ChannelCount
    def set_ChannelCount(self, ChannelCount): self.ChannelCount = ChannelCount
    def get_ChannelInfo(self): return self.ChannelInfo
    def set_ChannelInfo(self, ChannelInfo): self.ChannelInfo = ChannelInfo
    def add_ChannelInfo(self, value): self.ChannelInfo.append(value)
    def insert_ChannelInfo(self, index, value): self.ChannelInfo[index] = value
    def get_DictionaryFile(self): return self.DictionaryFile
    def set_DictionaryFile(self, DictionaryFile): self.DictionaryFile = DictionaryFile
    def get_Dictionary(self): return self.Dictionary
    def set_Dictionary(self, Dictionary): self.Dictionary = Dictionary
    def get_DiagFile(self): return self.DiagFile
    def set_DiagFile(self, DiagFile): self.DiagFile = DiagFile
    def add_DiagFile(self, value): self.DiagFile.append(value)
    def insert_DiagFile(self, index, value): self.DiagFile[index] = value
    def get_DiagMessages(self): return self.DiagMessages
    def set_DiagMessages(self, DiagMessages): self.DiagMessages = DiagMessages
    def add_DiagMessages(self, value): self.DiagMessages.append(value)
    def insert_DiagMessages(self, index, value): self.DiagMessages[index] = value
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.ProfileNo is not None or
            self.AddInfo is not None or
            self.ChannelCount is not None or
            self.ChannelInfo or
            self.DictionaryFile is not None or
            self.Dictionary is not None or
            self.DiagFile or
            self.DiagMessages or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProfileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProfileType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProfileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProfileNo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProfileNo>%s</%sProfileNo>%s' % (namespace_, self.gds_format_integer(self.ProfileNo, input_name='ProfileNo'), namespace_, eol_))
        if self.AddInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddInfo>%s</%sAddInfo>%s' % (namespace_, self.gds_format_integer(self.AddInfo, input_name='AddInfo'), namespace_, eol_))
        if self.ChannelCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChannelCount>%s</%sChannelCount>%s' % (namespace_, self.gds_format_integer(self.ChannelCount, input_name='ChannelCount'), namespace_, eol_))
        for ChannelInfo_ in self.ChannelInfo:
            ChannelInfo_.export(outfile, level, namespace_, name_='ChannelInfo', pretty_print=pretty_print)
        if self.DictionaryFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDictionaryFile>%s</%sDictionaryFile>%s' % (namespace_, self.gds_format_string(quote_xml(self.DictionaryFile).encode(ExternalEncoding), input_name='DictionaryFile'), namespace_, eol_))
        if self.Dictionary is not None:
            self.Dictionary.export(outfile, level, namespace_, name_='Dictionary', pretty_print=pretty_print)
        for DiagFile_ in self.DiagFile:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiagFile>%s</%sDiagFile>%s' % (namespace_, self.gds_format_string(quote_xml(DiagFile_).encode(ExternalEncoding), input_name='DiagFile'), namespace_, eol_))
        for DiagMessages_ in self.DiagMessages:
            DiagMessages_.export(outfile, level, namespace_, name_='DiagMessages', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProfileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProfileNo is not None:
            showIndent(outfile, level)
            outfile.write('ProfileNo=%d,\n' % self.ProfileNo)
        if self.AddInfo is not None:
            showIndent(outfile, level)
            outfile.write('AddInfo=%d,\n' % self.AddInfo)
        if self.ChannelCount is not None:
            showIndent(outfile, level)
            outfile.write('ChannelCount=%d,\n' % self.ChannelCount)
        showIndent(outfile, level)
        outfile.write('ChannelInfo=[\n')
        level += 1
        for ChannelInfo_ in self.ChannelInfo:
            showIndent(outfile, level)
            outfile.write('model_.ChannelInfoType(\n')
            ChannelInfo_.exportLiteral(outfile, level, name_='ChannelInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DictionaryFile is not None:
            showIndent(outfile, level)
            outfile.write('DictionaryFile=%s,\n' % quote_python(self.DictionaryFile).encode(ExternalEncoding))
        if self.Dictionary is not None:
            showIndent(outfile, level)
            outfile.write('Dictionary=model_.DictionaryType(\n')
            self.Dictionary.exportLiteral(outfile, level, name_='Dictionary')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DiagFile=[\n')
        level += 1
        for DiagFile_ in self.DiagFile:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DiagFile_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiagMessages=[\n')
        level += 1
        for DiagMessages_ in self.DiagMessages:
            showIndent(outfile, level)
            outfile.write('model_.DiagMessagesType(\n')
            DiagMessages_.exportLiteral(outfile, level, name_='DiagMessagesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProfileNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ProfileNo')
            self.ProfileNo = ival_
        elif nodeName_ == 'AddInfo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddInfo')
            self.AddInfo = ival_
        elif nodeName_ == 'ChannelCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ChannelCount')
            self.ChannelCount = ival_
        elif nodeName_ == 'ChannelInfo':
            obj_ = ChannelInfoType.factory()
            obj_.build(child_)
            self.ChannelInfo.append(obj_)
        elif nodeName_ == 'DictionaryFile':
            DictionaryFile_ = child_.text
            DictionaryFile_ = self.gds_validate_string(DictionaryFile_, node, 'DictionaryFile')
            self.DictionaryFile = DictionaryFile_
        elif nodeName_ == 'Dictionary':
            obj_ = DictionaryType.factory()
            obj_.build(child_)
            self.Dictionary = obj_
        elif nodeName_ == 'DiagFile':
            DiagFile_ = child_.text
            DiagFile_ = self.gds_validate_string(DiagFile_, node, 'DiagFile')
            self.DiagFile.append(DiagFile_)
        elif nodeName_ == 'DiagMessages':
            obj_ = DiagMessagesType.factory()
            obj_.build(child_)
            self.DiagMessages.append(obj_)
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class ProfileType


class VendorType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, UniqueName=None, Id=None, Name=None, Comment=None, URL=None, DescriptionURL=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, extensiontype_=None):
        self.UniqueName = _cast(None, UniqueName)
        self.Id = Id
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
        self.DescriptionURL = DescriptionURL
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VendorType.subclass:
            return VendorType.subclass(*args_, **kwargs_)
        else:
            return VendorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL(self, index, value): self.URL[index] = value
    def get_DescriptionURL(self): return self.DescriptionURL
    def set_DescriptionURL(self, DescriptionURL): self.DescriptionURL = DescriptionURL
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_UniqueName(self): return self.UniqueName
    def set_UniqueName(self, UniqueName): self.UniqueName = UniqueName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name or
            self.Comment or
            self.URL or
            self.DescriptionURL is not None or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorType'):
        if self.UniqueName is not None and 'UniqueName' not in already_processed:
            already_processed.add('UniqueName')
            outfile.write(' UniqueName=%s' % (self.gds_format_string(quote_attrib(self.UniqueName).encode(ExternalEncoding), input_name='UniqueName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='VendorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for URL_ in self.URL:
            URL_.export(outfile, level, namespace_, name_='URL', pretty_print=pretty_print)
        if self.DescriptionURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescriptionURL>%s</%sDescriptionURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.DescriptionURL).encode(ExternalEncoding), input_name='DescriptionURL'), namespace_, eol_))
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.UniqueName is not None and 'UniqueName' not in already_processed:
            already_processed.add('UniqueName')
            showIndent(outfile, level)
            outfile.write('UniqueName="%s",\n' % (self.UniqueName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Comment_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            URL_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DescriptionURL is not None:
            showIndent(outfile, level)
            outfile.write('DescriptionURL=%s,\n' % quote_python(self.DescriptionURL).encode(ExternalEncoding))
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UniqueName', node)
        if value is not None and 'UniqueName' not in already_processed:
            already_processed.add('UniqueName')
            self.UniqueName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            self.validate_HexDecValue(self.Id)    # validate type HexDecValue
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Comment':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
        elif nodeName_ == 'URL':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.URL.append(obj_)
        elif nodeName_ == 'DescriptionURL':
            DescriptionURL_ = child_.text
            DescriptionURL_ = self.gds_validate_string(DescriptionURL_, node, 'DescriptionURL')
            self.DescriptionURL = DescriptionURL_
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class VendorType


class ModuleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, RxPdo=None, TxPdo=None, SafetyParaMapping=None, Mailbox=None, Profile=None, DcOpModeName=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, extensiontype_=None):
        self.Type = Type
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if RxPdo is None:
            self.RxPdo = []
        else:
            self.RxPdo = RxPdo
        if TxPdo is None:
            self.TxPdo = []
        else:
            self.TxPdo = TxPdo
        if SafetyParaMapping is None:
            self.SafetyParaMapping = []
        else:
            self.SafetyParaMapping = SafetyParaMapping
        self.Mailbox = Mailbox
        self.Profile = Profile
        self.DcOpModeName = DcOpModeName
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
        self.VendorSpecific = VendorSpecific
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ModuleType.subclass:
            return ModuleType.subclass(*args_, **kwargs_)
        else:
            return ModuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_RxPdo(self): return self.RxPdo
    def set_RxPdo(self, RxPdo): self.RxPdo = RxPdo
    def add_RxPdo(self, value): self.RxPdo.append(value)
    def insert_RxPdo(self, index, value): self.RxPdo[index] = value
    def get_TxPdo(self): return self.TxPdo
    def set_TxPdo(self, TxPdo): self.TxPdo = TxPdo
    def add_TxPdo(self, value): self.TxPdo.append(value)
    def insert_TxPdo(self, index, value): self.TxPdo[index] = value
    def get_SafetyParaMapping(self): return self.SafetyParaMapping
    def set_SafetyParaMapping(self, SafetyParaMapping): self.SafetyParaMapping = SafetyParaMapping
    def add_SafetyParaMapping(self, value): self.SafetyParaMapping.append(value)
    def insert_SafetyParaMapping(self, index, value): self.SafetyParaMapping[index] = value
    def get_Mailbox(self): return self.Mailbox
    def set_Mailbox(self, Mailbox): self.Mailbox = Mailbox
    def get_Profile(self): return self.Profile
    def set_Profile(self, Profile): self.Profile = Profile
    def get_DcOpModeName(self): return self.DcOpModeName
    def set_DcOpModeName(self, DcOpModeName): self.DcOpModeName = DcOpModeName
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Name or
            self.RxPdo or
            self.TxPdo or
            self.SafetyParaMapping or
            self.Mailbox is not None or
            self.Profile is not None or
            self.DcOpModeName is not None or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModuleType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for RxPdo_ in self.RxPdo:
            RxPdo_.export(outfile, level, namespace_, name_='RxPdo', pretty_print=pretty_print)
        for TxPdo_ in self.TxPdo:
            TxPdo_.export(outfile, level, namespace_, name_='TxPdo', pretty_print=pretty_print)
        for SafetyParaMapping_ in self.SafetyParaMapping:
            SafetyParaMapping_.export(outfile, level, namespace_, name_='SafetyParaMapping', pretty_print=pretty_print)
        if self.Mailbox is not None:
            self.Mailbox.export(outfile, level, namespace_, name_='Mailbox', pretty_print=pretty_print)
        if self.Profile is not None:
            self.Profile.export(outfile, level, namespace_, name_='Profile', pretty_print=pretty_print)
        if self.DcOpModeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDcOpModeName>%s</%sDcOpModeName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DcOpModeName).encode(ExternalEncoding), input_name='DcOpModeName'), namespace_, eol_))
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ModuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.TypeType37(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RxPdo=[\n')
        level += 1
        for RxPdo_ in self.RxPdo:
            showIndent(outfile, level)
            outfile.write('model_.PdoType(\n')
            RxPdo_.exportLiteral(outfile, level, name_='PdoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TxPdo=[\n')
        level += 1
        for TxPdo_ in self.TxPdo:
            showIndent(outfile, level)
            outfile.write('model_.PdoType(\n')
            TxPdo_.exportLiteral(outfile, level, name_='PdoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SafetyParaMapping=[\n')
        level += 1
        for SafetyParaMapping_ in self.SafetyParaMapping:
            showIndent(outfile, level)
            outfile.write('model_.PdoType(\n')
            SafetyParaMapping_.exportLiteral(outfile, level, name_='PdoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mailbox is not None:
            showIndent(outfile, level)
            outfile.write('Mailbox=model_.MailboxType38(\n')
            self.Mailbox.exportLiteral(outfile, level, name_='Mailbox')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Profile is not None:
            showIndent(outfile, level)
            outfile.write('Profile=model_.ProfileType(\n')
            self.Profile.exportLiteral(outfile, level, name_='Profile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DcOpModeName is not None:
            showIndent(outfile, level)
            outfile.write('DcOpModeName=%s,\n' % quote_python(self.DcOpModeName).encode(ExternalEncoding))
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = TypeType37.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'RxPdo':
            obj_ = PdoType.factory()
            obj_.build(child_)
            self.RxPdo.append(obj_)
        elif nodeName_ == 'TxPdo':
            obj_ = PdoType.factory()
            obj_.build(child_)
            self.TxPdo.append(obj_)
        elif nodeName_ == 'SafetyParaMapping':
            obj_ = PdoType.factory()
            obj_.build(child_)
            self.SafetyParaMapping.append(obj_)
        elif nodeName_ == 'Mailbox':
            obj_ = MailboxType38.factory()
            obj_.build(child_)
            self.Mailbox = obj_
        elif nodeName_ == 'Profile':
            class_obj_ = self.get_class_obj_(child_, ProfileType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Profile = obj_
        elif nodeName_ == 'DcOpModeName':
            DcOpModeName_ = child_.text
            DcOpModeName_ = self.gds_validate_string(DcOpModeName_, node, 'DcOpModeName')
            self.DcOpModeName = DcOpModeName_
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class ModuleType


class UnitTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NotationIndex=None, Index=None, Name=None, Symbol=None):
        self.NotationIndex = NotationIndex
        self.Index = Index
        self.Name = Name
        self.Symbol = Symbol
    def factory(*args_, **kwargs_):
        if UnitTypeType.subclass:
            return UnitTypeType.subclass(*args_, **kwargs_)
        else:
            return UnitTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NotationIndex(self): return self.NotationIndex
    def set_NotationIndex(self, NotationIndex): self.NotationIndex = NotationIndex
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NotationIndex is not None or
            self.Index is not None or
            self.Name is not None or
            self.Symbol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnitTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnitTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NotationIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotationIndex>%s</%sNotationIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.NotationIndex).encode(ExternalEncoding), input_name='NotationIndex'), namespace_, eol_))
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Symbol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSymbol>%s</%sSymbol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Symbol).encode(ExternalEncoding), input_name='Symbol'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UnitTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NotationIndex is not None:
            showIndent(outfile, level)
            outfile.write('NotationIndex=%s,\n' % quote_python(self.NotationIndex).encode(ExternalEncoding))
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Symbol is not None:
            showIndent(outfile, level)
            outfile.write('Symbol=%s,\n' % quote_python(self.Symbol).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NotationIndex':
            NotationIndex_ = child_.text
            NotationIndex_ = self.gds_validate_string(NotationIndex_, node, 'NotationIndex')
            self.NotationIndex = NotationIndex_
            self.validate_HexDecValue(self.NotationIndex)    # validate type HexDecValue
        elif nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
            self.validate_HexDecValue(self.Index)    # validate type HexDecValue
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Symbol':
            Symbol_ = child_.text
            Symbol_ = self.gds_validate_string(Symbol_, node, 'Symbol')
            self.Symbol = Symbol_
# end class UnitTypeType


class DiagnosticsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiagSource=None, DiagReset=None, DiagReaction=None, DiagType=None, DiagMessage=None, extensiontype_=None):
        self.DiagSource = _cast(None, DiagSource)
        if DiagReset is None:
            self.DiagReset = []
        else:
            self.DiagReset = DiagReset
        if DiagReaction is None:
            self.DiagReaction = []
        else:
            self.DiagReaction = DiagReaction
        if DiagType is None:
            self.DiagType = []
        else:
            self.DiagType = DiagType
        if DiagMessage is None:
            self.DiagMessage = []
        else:
            self.DiagMessage = DiagMessage
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DiagnosticsType.subclass:
            return DiagnosticsType.subclass(*args_, **kwargs_)
        else:
            return DiagnosticsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiagReset(self): return self.DiagReset
    def set_DiagReset(self, DiagReset): self.DiagReset = DiagReset
    def add_DiagReset(self, value): self.DiagReset.append(value)
    def insert_DiagReset(self, index, value): self.DiagReset[index] = value
    def get_DiagReaction(self): return self.DiagReaction
    def set_DiagReaction(self, DiagReaction): self.DiagReaction = DiagReaction
    def add_DiagReaction(self, value): self.DiagReaction.append(value)
    def insert_DiagReaction(self, index, value): self.DiagReaction[index] = value
    def get_DiagType(self): return self.DiagType
    def set_DiagType(self, DiagType): self.DiagType = DiagType
    def add_DiagType(self, value): self.DiagType.append(value)
    def insert_DiagType(self, index, value): self.DiagType[index] = value
    def get_DiagMessage(self): return self.DiagMessage
    def set_DiagMessage(self, DiagMessage): self.DiagMessage = DiagMessage
    def add_DiagMessage(self, value): self.DiagMessage.append(value)
    def insert_DiagMessage(self, index, value): self.DiagMessage[index] = value
    def get_DiagSource(self): return self.DiagSource
    def set_DiagSource(self, DiagSource): self.DiagSource = DiagSource
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.DiagReset or
            self.DiagReaction or
            self.DiagType or
            self.DiagMessage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiagnosticsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiagnosticsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiagnosticsType'):
        if self.DiagSource is not None and 'DiagSource' not in already_processed:
            already_processed.add('DiagSource')
            outfile.write(' DiagSource=%s' % (self.gds_format_string(quote_attrib(self.DiagSource).encode(ExternalEncoding), input_name='DiagSource'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DiagnosticsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DiagReset_ in self.DiagReset:
            DiagReset_.export(outfile, level, namespace_, name_='DiagReset', pretty_print=pretty_print)
        for DiagReaction_ in self.DiagReaction:
            DiagReaction_.export(outfile, level, namespace_, name_='DiagReaction', pretty_print=pretty_print)
        for DiagType_ in self.DiagType:
            DiagType_.export(outfile, level, namespace_, name_='DiagType', pretty_print=pretty_print)
        for DiagMessage_ in self.DiagMessage:
            DiagMessage_.export(outfile, level, namespace_, name_='DiagMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiagnosticsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DiagSource is not None and 'DiagSource' not in already_processed:
            already_processed.add('DiagSource')
            showIndent(outfile, level)
            outfile.write('DiagSource="%s",\n' % (self.DiagSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DiagReset=[\n')
        level += 1
        for DiagReset_ in self.DiagReset:
            showIndent(outfile, level)
            outfile.write('model_.EnumInfoType(\n')
            DiagReset_.exportLiteral(outfile, level, name_='EnumInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiagReaction=[\n')
        level += 1
        for DiagReaction_ in self.DiagReaction:
            showIndent(outfile, level)
            outfile.write('model_.EnumInfoType(\n')
            DiagReaction_.exportLiteral(outfile, level, name_='EnumInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiagType=[\n')
        level += 1
        for DiagType_ in self.DiagType:
            showIndent(outfile, level)
            outfile.write('model_.EnumInfoType(\n')
            DiagType_.exportLiteral(outfile, level, name_='EnumInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiagMessage=[\n')
        level += 1
        for DiagMessage_ in self.DiagMessage:
            showIndent(outfile, level)
            outfile.write('model_.DiagMessageType(\n')
            DiagMessage_.exportLiteral(outfile, level, name_='DiagMessageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DiagSource', node)
        if value is not None and 'DiagSource' not in already_processed:
            already_processed.add('DiagSource')
            self.DiagSource = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiagReset':
            obj_ = EnumInfoType.factory()
            obj_.build(child_)
            self.DiagReset.append(obj_)
        elif nodeName_ == 'DiagReaction':
            obj_ = EnumInfoType.factory()
            obj_.build(child_)
            self.DiagReaction.append(obj_)
        elif nodeName_ == 'DiagType':
            obj_ = EnumInfoType.factory()
            obj_.build(child_)
            self.DiagType.append(obj_)
        elif nodeName_ == 'DiagMessage':
            obj_ = DiagMessageType.factory()
            obj_.build(child_)
            self.DiagMessage.append(obj_)
# end class DiagnosticsType


class VendorType1(VendorType):
    subclass = None
    superclass = VendorType
    def __init__(self, UniqueName=None, Id=None, Name=None, Comment=None, URL=None, DescriptionURL=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, FileVersion=None):
        super(VendorType1, self).__init__(UniqueName, Id, Name, Comment, URL, DescriptionURL, Image16x14, ImageFile16x14, ImageData16x14, VendorSpecific, )
        self.FileVersion = _cast(int, FileVersion)
        pass
    def factory(*args_, **kwargs_):
        if VendorType1.subclass:
            return VendorType1.subclass(*args_, **kwargs_)
        else:
            return VendorType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileVersion(self): return self.FileVersion
    def set_FileVersion(self, FileVersion): self.FileVersion = FileVersion
    def hasContent_(self):
        if (
            super(VendorType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorType1'):
        super(VendorType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorType1')
        if self.FileVersion is not None and 'FileVersion' not in already_processed:
            already_processed.add('FileVersion')
            outfile.write(' FileVersion="%s"' % self.gds_format_integer(self.FileVersion, input_name='FileVersion'))
    def exportChildren(self, outfile, level, namespace_='', name_='VendorType1', fromsubclass_=False, pretty_print=True):
        super(VendorType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FileVersion is not None and 'FileVersion' not in already_processed:
            already_processed.add('FileVersion')
            showIndent(outfile, level)
            outfile.write('FileVersion=%d,\n' % (self.FileVersion,))
        super(VendorType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FileVersion', node)
        if value is not None and 'FileVersion' not in already_processed:
            already_processed.add('FileVersion')
            try:
                self.FileVersion = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(VendorType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VendorType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VendorType1


class DescriptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Groups=None, Scalings=None, Devices=None, Modules=None):
        self.Groups = Groups
        self.Scalings = Scalings
        self.Devices = Devices
        self.Modules = Modules
    def factory(*args_, **kwargs_):
        if DescriptionsType.subclass:
            return DescriptionsType.subclass(*args_, **kwargs_)
        else:
            return DescriptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Groups(self): return self.Groups
    def set_Groups(self, Groups): self.Groups = Groups
    def get_Scalings(self): return self.Scalings
    def set_Scalings(self, Scalings): self.Scalings = Scalings
    def get_Devices(self): return self.Devices
    def set_Devices(self, Devices): self.Devices = Devices
    def get_Modules(self): return self.Modules
    def set_Modules(self, Modules): self.Modules = Modules
    def hasContent_(self):
        if (
            self.Groups is not None or
            self.Scalings is not None or
            self.Devices is not None or
            self.Modules is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DescriptionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DescriptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DescriptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Groups is not None:
            self.Groups.export(outfile, level, namespace_, name_='Groups', pretty_print=pretty_print)
        if self.Scalings is not None:
            self.Scalings.export(outfile, level, namespace_, name_='Scalings', pretty_print=pretty_print)
        if self.Devices is not None:
            self.Devices.export(outfile, level, namespace_, name_='Devices', pretty_print=pretty_print)
        if self.Modules is not None:
            self.Modules.export(outfile, level, namespace_, name_='Modules', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DescriptionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Groups is not None:
            showIndent(outfile, level)
            outfile.write('Groups=model_.GroupsType(\n')
            self.Groups.exportLiteral(outfile, level, name_='Groups')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Scalings is not None:
            showIndent(outfile, level)
            outfile.write('Scalings=model_.ScalingsType(\n')
            self.Scalings.exportLiteral(outfile, level, name_='Scalings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Devices is not None:
            showIndent(outfile, level)
            outfile.write('Devices=model_.DevicesType(\n')
            self.Devices.exportLiteral(outfile, level, name_='Devices')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Modules is not None:
            showIndent(outfile, level)
            outfile.write('Modules=model_.ModulesType(\n')
            self.Modules.exportLiteral(outfile, level, name_='Modules')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Groups':
            obj_ = GroupsType.factory()
            obj_.build(child_)
            self.Groups = obj_
        elif nodeName_ == 'Scalings':
            obj_ = ScalingsType.factory()
            obj_.build(child_)
            self.Scalings = obj_
        elif nodeName_ == 'Devices':
            obj_ = DevicesType.factory()
            obj_.build(child_)
            self.Devices = obj_
        elif nodeName_ == 'Modules':
            obj_ = ModulesType.factory()
            obj_.build(child_)
            self.Modules = obj_
# end class DescriptionsType


class GroupsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None):
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
    def factory(*args_, **kwargs_):
        if GroupsType.subclass:
            return GroupsType.subclass(*args_, **kwargs_)
        else:
            return GroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group(self, index, value): self.Group[index] = value
    def hasContent_(self):
        if (
            self.Group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GroupsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType2(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType2.factory()
            obj_.build(child_)
            self.Group.append(obj_)
# end class GroupsType


class GroupType2(GroupType):
    subclass = None
    superclass = GroupType
    def __init__(self, Type=None, Name=None, Comment=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, ParentGroup=None, SortOrder=None):
        super(GroupType2, self).__init__(Type, Name, Comment, Image16x14, ImageFile16x14, ImageData16x14, VendorSpecific, )
        self.ParentGroup = _cast(None, ParentGroup)
        self.SortOrder = _cast(int, SortOrder)
        pass
    def factory(*args_, **kwargs_):
        if GroupType2.subclass:
            return GroupType2.subclass(*args_, **kwargs_)
        else:
            return GroupType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentGroup(self): return self.ParentGroup
    def set_ParentGroup(self, ParentGroup): self.ParentGroup = ParentGroup
    def get_SortOrder(self): return self.SortOrder
    def set_SortOrder(self, SortOrder): self.SortOrder = SortOrder
    def hasContent_(self):
        if (
            super(GroupType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GroupType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupType2'):
        super(GroupType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType2')
        if self.ParentGroup is not None and 'ParentGroup' not in already_processed:
            already_processed.add('ParentGroup')
            outfile.write(' ParentGroup=%s' % (self.gds_format_string(quote_attrib(self.ParentGroup).encode(ExternalEncoding), input_name='ParentGroup'), ))
        if self.SortOrder is not None and 'SortOrder' not in already_processed:
            already_processed.add('SortOrder')
            outfile.write(' SortOrder="%s"' % self.gds_format_integer(self.SortOrder, input_name='SortOrder'))
    def exportChildren(self, outfile, level, namespace_='', name_='GroupType2', fromsubclass_=False, pretty_print=True):
        super(GroupType2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GroupType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ParentGroup is not None and 'ParentGroup' not in already_processed:
            already_processed.add('ParentGroup')
            showIndent(outfile, level)
            outfile.write('ParentGroup="%s",\n' % (self.ParentGroup,))
        if self.SortOrder is not None and 'SortOrder' not in already_processed:
            already_processed.add('SortOrder')
            showIndent(outfile, level)
            outfile.write('SortOrder=%d,\n' % (self.SortOrder,))
        super(GroupType2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GroupType2, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ParentGroup', node)
        if value is not None and 'ParentGroup' not in already_processed:
            already_processed.add('ParentGroup')
            self.ParentGroup = value
        value = find_attr_value_('SortOrder', node)
        if value is not None and 'SortOrder' not in already_processed:
            already_processed.add('SortOrder')
            try:
                self.SortOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(GroupType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GroupType2, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GroupType2


class ScalingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Scaling=None):
        if Scaling is None:
            self.Scaling = []
        else:
            self.Scaling = Scaling
    def factory(*args_, **kwargs_):
        if ScalingsType.subclass:
            return ScalingsType.subclass(*args_, **kwargs_)
        else:
            return ScalingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Scaling(self): return self.Scaling
    def set_Scaling(self, Scaling): self.Scaling = Scaling
    def add_Scaling(self, value): self.Scaling.append(value)
    def insert_Scaling(self, index, value): self.Scaling[index] = value
    def hasContent_(self):
        if (
            self.Scaling
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScalingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScalingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScalingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScalingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Scaling_ in self.Scaling:
            Scaling_.export(outfile, level, namespace_, name_='Scaling', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ScalingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Scaling=[\n')
        level += 1
        for Scaling_ in self.Scaling:
            showIndent(outfile, level)
            outfile.write('model_.ScalingType(\n')
            Scaling_.exportLiteral(outfile, level, name_='ScalingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scaling':
            obj_ = ScalingType.factory()
            obj_.build(child_)
            self.Scaling.append(obj_)
# end class ScalingsType


class ScalingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Unit=None, MinValue=None, MaxValue=None, ZeroPoint=None, Unsigned=False, Numerator=None, Denominator=None):
        self.Name = Name
        self.Unit = Unit
        self.MinValue = MinValue
        self.MaxValue = MaxValue
        self.ZeroPoint = ZeroPoint
        self.Unsigned = Unsigned
        self.Numerator = Numerator
        self.Denominator = Denominator
    def factory(*args_, **kwargs_):
        if ScalingType.subclass:
            return ScalingType.subclass(*args_, **kwargs_)
        else:
            return ScalingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    def get_MinValue(self): return self.MinValue
    def set_MinValue(self, MinValue): self.MinValue = MinValue
    def get_MaxValue(self): return self.MaxValue
    def set_MaxValue(self, MaxValue): self.MaxValue = MaxValue
    def get_ZeroPoint(self): return self.ZeroPoint
    def set_ZeroPoint(self, ZeroPoint): self.ZeroPoint = ZeroPoint
    def get_Unsigned(self): return self.Unsigned
    def set_Unsigned(self, Unsigned): self.Unsigned = Unsigned
    def get_Numerator(self): return self.Numerator
    def set_Numerator(self, Numerator): self.Numerator = Numerator
    def get_Denominator(self): return self.Denominator
    def set_Denominator(self, Denominator): self.Denominator = Denominator
    def validate_HexDecFloatValue(self, value):
        # Validate type HexDecFloatValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Unit is not None or
            self.MinValue is not None or
            self.MaxValue is not None or
            self.ZeroPoint is not None or
            self.Unsigned is not None or
            self.Numerator is not None or
            self.Denominator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScalingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScalingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScalingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScalingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Unit is not None:
            self.Unit.export(outfile, level, namespace_, name_='Unit', pretty_print=pretty_print)
        if self.MinValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinValue>%s</%sMinValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MinValue).encode(ExternalEncoding), input_name='MinValue'), namespace_, eol_))
        if self.MaxValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxValue>%s</%sMaxValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.MaxValue).encode(ExternalEncoding), input_name='MaxValue'), namespace_, eol_))
        if self.ZeroPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZeroPoint>%s</%sZeroPoint>%s' % (namespace_, self.gds_format_string(quote_xml(self.ZeroPoint).encode(ExternalEncoding), input_name='ZeroPoint'), namespace_, eol_))
        if self.Unsigned is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnsigned>%s</%sUnsigned>%s' % (namespace_, self.gds_format_boolean(self.Unsigned, input_name='Unsigned'), namespace_, eol_))
        if self.Numerator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumerator>%s</%sNumerator>%s' % (namespace_, self.gds_format_string(quote_xml(self.Numerator).encode(ExternalEncoding), input_name='Numerator'), namespace_, eol_))
        if self.Denominator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDenominator>%s</%sDenominator>%s' % (namespace_, self.gds_format_string(quote_xml(self.Denominator).encode(ExternalEncoding), input_name='Denominator'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ScalingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Unit is not None:
            showIndent(outfile, level)
            outfile.write('Unit=model_.UnitTypeType(\n')
            self.Unit.exportLiteral(outfile, level, name_='Unit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MinValue is not None:
            showIndent(outfile, level)
            outfile.write('MinValue=%s,\n' % quote_python(self.MinValue).encode(ExternalEncoding))
        if self.MaxValue is not None:
            showIndent(outfile, level)
            outfile.write('MaxValue=%s,\n' % quote_python(self.MaxValue).encode(ExternalEncoding))
        if self.ZeroPoint is not None:
            showIndent(outfile, level)
            outfile.write('ZeroPoint=%s,\n' % quote_python(self.ZeroPoint).encode(ExternalEncoding))
        if self.Unsigned is not None:
            showIndent(outfile, level)
            outfile.write('Unsigned=%s,\n' % self.Unsigned)
        if self.Numerator is not None:
            showIndent(outfile, level)
            outfile.write('Numerator=%s,\n' % quote_python(self.Numerator).encode(ExternalEncoding))
        if self.Denominator is not None:
            showIndent(outfile, level)
            outfile.write('Denominator=%s,\n' % quote_python(self.Denominator).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Unit':
            obj_ = UnitTypeType.factory()
            obj_.build(child_)
            self.Unit = obj_
        elif nodeName_ == 'MinValue':
            MinValue_ = child_.text
            MinValue_ = self.gds_validate_string(MinValue_, node, 'MinValue')
            self.MinValue = MinValue_
            self.validate_HexDecFloatValue(self.MinValue)    # validate type HexDecFloatValue
        elif nodeName_ == 'MaxValue':
            MaxValue_ = child_.text
            MaxValue_ = self.gds_validate_string(MaxValue_, node, 'MaxValue')
            self.MaxValue = MaxValue_
            self.validate_HexDecFloatValue(self.MaxValue)    # validate type HexDecFloatValue
        elif nodeName_ == 'ZeroPoint':
            ZeroPoint_ = child_.text
            ZeroPoint_ = self.gds_validate_string(ZeroPoint_, node, 'ZeroPoint')
            self.ZeroPoint = ZeroPoint_
            self.validate_HexDecFloatValue(self.ZeroPoint)    # validate type HexDecFloatValue
        elif nodeName_ == 'Unsigned':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Unsigned')
            self.Unsigned = ival_
        elif nodeName_ == 'Numerator':
            Numerator_ = child_.text
            Numerator_ = self.gds_validate_string(Numerator_, node, 'Numerator')
            self.Numerator = Numerator_
            self.validate_HexDecFloatValue(self.Numerator)    # validate type HexDecFloatValue
        elif nodeName_ == 'Denominator':
            Denominator_ = child_.text
            Denominator_ = self.gds_validate_string(Denominator_, node, 'Denominator')
            self.Denominator = Denominator_
            self.validate_HexDecFloatValue(self.Denominator)    # validate type HexDecFloatValue
# end class ScalingType


class DevicesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Device=None):
        if Device is None:
            self.Device = []
        else:
            self.Device = Device
    def factory(*args_, **kwargs_):
        if DevicesType.subclass:
            return DevicesType.subclass(*args_, **kwargs_)
        else:
            return DevicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Device(self): return self.Device
    def set_Device(self, Device): self.Device = Device
    def add_Device(self, value): self.Device.append(value)
    def insert_Device(self, index, value): self.Device[index] = value
    def hasContent_(self):
        if (
            self.Device
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DevicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DevicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DevicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DevicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Device_ in self.Device:
            Device_.export(outfile, level, namespace_, name_='Device', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DevicesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Device=[\n')
        level += 1
        for Device_ in self.Device:
            showIndent(outfile, level)
            outfile.write('model_.DeviceType3(\n')
            Device_.exportLiteral(outfile, level, name_='DeviceType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Device':
            obj_ = DeviceType3.factory()
            obj_.build(child_)
            self.Device.append(obj_)
# end class DevicesType


class DeviceType3(DeviceType):
    subclass = None
    superclass = DeviceType
    def __init__(self, Type=None, HideType=None, AlternativeType=None, SubDevice=None, Name=None, Comment=None, URL=None, Info=None, GroupType=None, Profile=None, Fmmu=None, Sm=None, Su=None, RxPdo=None, TxPdo=None, Mailbox=None, Dc=None, Slots=None, ESC=None, Eeprom=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, Invisible=None, Crc32=None, Physics=None):
        super(DeviceType3, self).__init__(Type, HideType, AlternativeType, SubDevice, Name, Comment, URL, Info, GroupType, Profile, Fmmu, Sm, Su, RxPdo, TxPdo, Mailbox, Dc, Slots, ESC, Eeprom, Image16x14, ImageFile16x14, ImageData16x14, VendorSpecific, )
        self.Invisible = _cast(bool, Invisible)
        self.Crc32 = _cast(None, Crc32)
        self.Physics = _cast(None, Physics)
        pass
    def factory(*args_, **kwargs_):
        if DeviceType3.subclass:
            return DeviceType3.subclass(*args_, **kwargs_)
        else:
            return DeviceType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Invisible(self): return self.Invisible
    def set_Invisible(self, Invisible): self.Invisible = Invisible
    def get_Crc32(self): return self.Crc32
    def set_Crc32(self, Crc32): self.Crc32 = Crc32
    def get_Physics(self): return self.Physics
    def set_Physics(self, Physics): self.Physics = Physics
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def validate_PhysicsType(self, value):
        # Validate type PhysicsType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            super(DeviceType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceType3'):
        super(DeviceType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceType3')
        if self.Invisible is not None and 'Invisible' not in already_processed:
            already_processed.add('Invisible')
            outfile.write(' Invisible="%s"' % self.gds_format_boolean(self.Invisible, input_name='Invisible'))
        if self.Crc32 is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            outfile.write(' Crc32=%s' % (quote_attrib(self.Crc32), ))
        if self.Physics is not None and 'Physics' not in already_processed:
            already_processed.add('Physics')
            outfile.write(' Physics=%s' % (quote_attrib(self.Physics), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceType3', fromsubclass_=False, pretty_print=True):
        super(DeviceType3, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeviceType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Invisible is not None and 'Invisible' not in already_processed:
            already_processed.add('Invisible')
            showIndent(outfile, level)
            outfile.write('Invisible=%s,\n' % (self.Invisible,))
        if self.Crc32 is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            showIndent(outfile, level)
            outfile.write('Crc32="%s",\n' % (self.Crc32,))
        if self.Physics is not None and 'Physics' not in already_processed:
            already_processed.add('Physics')
            showIndent(outfile, level)
            outfile.write('Physics="%s",\n' % (self.Physics,))
        super(DeviceType3, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceType3, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Invisible', node)
        if value is not None and 'Invisible' not in already_processed:
            already_processed.add('Invisible')
            if value in ('true', '1'):
                self.Invisible = True
            elif value in ('false', '0'):
                self.Invisible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Crc32', node)
        if value is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            self.Crc32 = value
            self.validate_HexDecValue(self.Crc32)    # validate type HexDecValue
        value = find_attr_value_('Physics', node)
        if value is not None and 'Physics' not in already_processed:
            already_processed.add('Physics')
            self.Physics = value
            self.validate_PhysicsType(self.Physics)    # validate type PhysicsType
        super(DeviceType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeviceType3, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceType3


class ModulesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Module=None):
        if Module is None:
            self.Module = []
        else:
            self.Module = Module
    def factory(*args_, **kwargs_):
        if ModulesType.subclass:
            return ModulesType.subclass(*args_, **kwargs_)
        else:
            return ModulesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Module(self): return self.Module
    def set_Module(self, Module): self.Module = Module
    def add_Module(self, value): self.Module.append(value)
    def insert_Module(self, index, value): self.Module[index] = value
    def hasContent_(self):
        if (
            self.Module
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModulesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModulesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModulesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModulesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Module_ in self.Module:
            Module_.export(outfile, level, namespace_, name_='Module', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ModulesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Module=[\n')
        level += 1
        for Module_ in self.Module:
            showIndent(outfile, level)
            outfile.write('model_.ModuleType4(\n')
            Module_.exportLiteral(outfile, level, name_='ModuleType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Module':
            obj_ = ModuleType4.factory()
            obj_.build(child_)
            self.Module.append(obj_)
# end class ModulesType


class ModuleType4(ModuleType):
    subclass = None
    superclass = ModuleType
    def __init__(self, Type=None, Name=None, RxPdo=None, TxPdo=None, SafetyParaMapping=None, Mailbox=None, Profile=None, DcOpModeName=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None, VendorSpecific=None, Crc32=None):
        super(ModuleType4, self).__init__(Type, Name, RxPdo, TxPdo, SafetyParaMapping, Mailbox, Profile, DcOpModeName, Image16x14, ImageFile16x14, ImageData16x14, VendorSpecific, )
        self.Crc32 = _cast(None, Crc32)
        pass
    def factory(*args_, **kwargs_):
        if ModuleType4.subclass:
            return ModuleType4.subclass(*args_, **kwargs_)
        else:
            return ModuleType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Crc32(self): return self.Crc32
    def set_Crc32(self, Crc32): self.Crc32 = Crc32
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            super(ModuleType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModuleType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModuleType4'):
        super(ModuleType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleType4')
        if self.Crc32 is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            outfile.write(' Crc32=%s' % (quote_attrib(self.Crc32), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ModuleType4', fromsubclass_=False, pretty_print=True):
        super(ModuleType4, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ModuleType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Crc32 is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            showIndent(outfile, level)
            outfile.write('Crc32="%s",\n' % (self.Crc32,))
        super(ModuleType4, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ModuleType4, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Crc32', node)
        if value is not None and 'Crc32' not in already_processed:
            already_processed.add('Crc32')
            self.Crc32 = value
            self.validate_HexDecValue(self.Crc32)    # validate type HexDecValue
        super(ModuleType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ModuleType4, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ModuleType4


class TypeType(GeneratedsSuper):
    """obsoleteobsoleteobsolete"""
    subclass = None
    superclass = None
    def __init__(self, ProductCode=None, CheckProductCode=None, RevisionNo=None, ModulePdoGroup=None, CheckRevisionNo=None, TcSmClass=None, DownloadModuleList=None, CheckSerialNo=None, SerialNo=None, TcCfgModeSafeOp=None, UseLrdLwr=None, valueOf_=None):
        self.ProductCode = _cast(None, ProductCode)
        self.CheckProductCode = _cast(None, CheckProductCode)
        self.RevisionNo = _cast(None, RevisionNo)
        self.ModulePdoGroup = _cast(int, ModulePdoGroup)
        self.CheckRevisionNo = _cast(None, CheckRevisionNo)
        self.TcSmClass = _cast(None, TcSmClass)
        self.DownloadModuleList = _cast(bool, DownloadModuleList)
        self.CheckSerialNo = _cast(None, CheckSerialNo)
        self.SerialNo = _cast(None, SerialNo)
        self.TcCfgModeSafeOp = _cast(bool, TcCfgModeSafeOp)
        self.UseLrdLwr = _cast(bool, UseLrdLwr)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TypeType.subclass:
            return TypeType.subclass(*args_, **kwargs_)
        else:
            return TypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductCode(self): return self.ProductCode
    def set_ProductCode(self, ProductCode): self.ProductCode = ProductCode
    def get_CheckProductCode(self): return self.CheckProductCode
    def set_CheckProductCode(self, CheckProductCode): self.CheckProductCode = CheckProductCode
    def get_RevisionNo(self): return self.RevisionNo
    def set_RevisionNo(self, RevisionNo): self.RevisionNo = RevisionNo
    def get_ModulePdoGroup(self): return self.ModulePdoGroup
    def set_ModulePdoGroup(self, ModulePdoGroup): self.ModulePdoGroup = ModulePdoGroup
    def get_CheckRevisionNo(self): return self.CheckRevisionNo
    def set_CheckRevisionNo(self, CheckRevisionNo): self.CheckRevisionNo = CheckRevisionNo
    def get_TcSmClass(self): return self.TcSmClass
    def set_TcSmClass(self, TcSmClass): self.TcSmClass = TcSmClass
    def get_DownloadModuleList(self): return self.DownloadModuleList
    def set_DownloadModuleList(self, DownloadModuleList): self.DownloadModuleList = DownloadModuleList
    def get_CheckSerialNo(self): return self.CheckSerialNo
    def set_CheckSerialNo(self, CheckSerialNo): self.CheckSerialNo = CheckSerialNo
    def get_SerialNo(self): return self.SerialNo
    def set_SerialNo(self, SerialNo): self.SerialNo = SerialNo
    def get_TcCfgModeSafeOp(self): return self.TcCfgModeSafeOp
    def set_TcCfgModeSafeOp(self, TcCfgModeSafeOp): self.TcCfgModeSafeOp = TcCfgModeSafeOp
    def get_UseLrdLwr(self): return self.UseLrdLwr
    def set_UseLrdLwr(self, UseLrdLwr): self.UseLrdLwr = UseLrdLwr
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TypeType'):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            outfile.write(' ProductCode=%s' % (quote_attrib(self.ProductCode), ))
        if self.CheckProductCode is not None and 'CheckProductCode' not in already_processed:
            already_processed.add('CheckProductCode')
            outfile.write(' CheckProductCode=%s' % (self.gds_format_string(quote_attrib(self.CheckProductCode).encode(ExternalEncoding), input_name='CheckProductCode'), ))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            outfile.write(' RevisionNo=%s' % (quote_attrib(self.RevisionNo), ))
        if self.ModulePdoGroup is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            outfile.write(' ModulePdoGroup="%s"' % self.gds_format_integer(self.ModulePdoGroup, input_name='ModulePdoGroup'))
        if self.CheckRevisionNo is not None and 'CheckRevisionNo' not in already_processed:
            already_processed.add('CheckRevisionNo')
            outfile.write(' CheckRevisionNo=%s' % (self.gds_format_string(quote_attrib(self.CheckRevisionNo).encode(ExternalEncoding), input_name='CheckRevisionNo'), ))
        if self.TcSmClass is not None and 'TcSmClass' not in already_processed:
            already_processed.add('TcSmClass')
            outfile.write(' TcSmClass=%s' % (self.gds_format_string(quote_attrib(self.TcSmClass).encode(ExternalEncoding), input_name='TcSmClass'), ))
        if self.DownloadModuleList is not None and 'DownloadModuleList' not in already_processed:
            already_processed.add('DownloadModuleList')
            outfile.write(' DownloadModuleList="%s"' % self.gds_format_boolean(self.DownloadModuleList, input_name='DownloadModuleList'))
        if self.CheckSerialNo is not None and 'CheckSerialNo' not in already_processed:
            already_processed.add('CheckSerialNo')
            outfile.write(' CheckSerialNo=%s' % (self.gds_format_string(quote_attrib(self.CheckSerialNo).encode(ExternalEncoding), input_name='CheckSerialNo'), ))
        if self.SerialNo is not None and 'SerialNo' not in already_processed:
            already_processed.add('SerialNo')
            outfile.write(' SerialNo=%s' % (quote_attrib(self.SerialNo), ))
        if self.TcCfgModeSafeOp is not None and 'TcCfgModeSafeOp' not in already_processed:
            already_processed.add('TcCfgModeSafeOp')
            outfile.write(' TcCfgModeSafeOp="%s"' % self.gds_format_boolean(self.TcCfgModeSafeOp, input_name='TcCfgModeSafeOp'))
        if self.UseLrdLwr is not None and 'UseLrdLwr' not in already_processed:
            already_processed.add('UseLrdLwr')
            outfile.write(' UseLrdLwr="%s"' % self.gds_format_boolean(self.UseLrdLwr, input_name='UseLrdLwr'))
    def exportChildren(self, outfile, level, namespace_='', name_='TypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            showIndent(outfile, level)
            outfile.write('ProductCode="%s",\n' % (self.ProductCode,))
        if self.CheckProductCode is not None and 'CheckProductCode' not in already_processed:
            already_processed.add('CheckProductCode')
            showIndent(outfile, level)
            outfile.write('CheckProductCode="%s",\n' % (self.CheckProductCode,))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            showIndent(outfile, level)
            outfile.write('RevisionNo="%s",\n' % (self.RevisionNo,))
        if self.ModulePdoGroup is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            showIndent(outfile, level)
            outfile.write('ModulePdoGroup=%d,\n' % (self.ModulePdoGroup,))
        if self.CheckRevisionNo is not None and 'CheckRevisionNo' not in already_processed:
            already_processed.add('CheckRevisionNo')
            showIndent(outfile, level)
            outfile.write('CheckRevisionNo="%s",\n' % (self.CheckRevisionNo,))
        if self.TcSmClass is not None and 'TcSmClass' not in already_processed:
            already_processed.add('TcSmClass')
            showIndent(outfile, level)
            outfile.write('TcSmClass="%s",\n' % (self.TcSmClass,))
        if self.DownloadModuleList is not None and 'DownloadModuleList' not in already_processed:
            already_processed.add('DownloadModuleList')
            showIndent(outfile, level)
            outfile.write('DownloadModuleList=%s,\n' % (self.DownloadModuleList,))
        if self.CheckSerialNo is not None and 'CheckSerialNo' not in already_processed:
            already_processed.add('CheckSerialNo')
            showIndent(outfile, level)
            outfile.write('CheckSerialNo="%s",\n' % (self.CheckSerialNo,))
        if self.SerialNo is not None and 'SerialNo' not in already_processed:
            already_processed.add('SerialNo')
            showIndent(outfile, level)
            outfile.write('SerialNo="%s",\n' % (self.SerialNo,))
        if self.TcCfgModeSafeOp is not None and 'TcCfgModeSafeOp' not in already_processed:
            already_processed.add('TcCfgModeSafeOp')
            showIndent(outfile, level)
            outfile.write('TcCfgModeSafeOp=%s,\n' % (self.TcCfgModeSafeOp,))
        if self.UseLrdLwr is not None and 'UseLrdLwr' not in already_processed:
            already_processed.add('UseLrdLwr')
            showIndent(outfile, level)
            outfile.write('UseLrdLwr=%s,\n' % (self.UseLrdLwr,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ProductCode', node)
        if value is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            self.ProductCode = value
            self.validate_HexDecValue(self.ProductCode)    # validate type HexDecValue
        value = find_attr_value_('CheckProductCode', node)
        if value is not None and 'CheckProductCode' not in already_processed:
            already_processed.add('CheckProductCode')
            self.CheckProductCode = value
        value = find_attr_value_('RevisionNo', node)
        if value is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            self.RevisionNo = value
            self.validate_HexDecValue(self.RevisionNo)    # validate type HexDecValue
        value = find_attr_value_('ModulePdoGroup', node)
        if value is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            try:
                self.ModulePdoGroup = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CheckRevisionNo', node)
        if value is not None and 'CheckRevisionNo' not in already_processed:
            already_processed.add('CheckRevisionNo')
            self.CheckRevisionNo = value
        value = find_attr_value_('TcSmClass', node)
        if value is not None and 'TcSmClass' not in already_processed:
            already_processed.add('TcSmClass')
            self.TcSmClass = value
        value = find_attr_value_('DownloadModuleList', node)
        if value is not None and 'DownloadModuleList' not in already_processed:
            already_processed.add('DownloadModuleList')
            if value in ('true', '1'):
                self.DownloadModuleList = True
            elif value in ('false', '0'):
                self.DownloadModuleList = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CheckSerialNo', node)
        if value is not None and 'CheckSerialNo' not in already_processed:
            already_processed.add('CheckSerialNo')
            self.CheckSerialNo = value
        value = find_attr_value_('SerialNo', node)
        if value is not None and 'SerialNo' not in already_processed:
            already_processed.add('SerialNo')
            self.SerialNo = value
            self.validate_HexDecValue(self.SerialNo)    # validate type HexDecValue
        value = find_attr_value_('TcCfgModeSafeOp', node)
        if value is not None and 'TcCfgModeSafeOp' not in already_processed:
            already_processed.add('TcCfgModeSafeOp')
            if value in ('true', '1'):
                self.TcCfgModeSafeOp = True
            elif value in ('false', '0'):
                self.TcCfgModeSafeOp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('UseLrdLwr', node)
        if value is not None and 'UseLrdLwr' not in already_processed:
            already_processed.add('UseLrdLwr')
            if value in ('true', '1'):
                self.UseLrdLwr = True
            elif value in ('false', '0'):
                self.UseLrdLwr = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TypeType


class HideTypeType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, ProductCode=None, RevisionNo=None, ProductRevision=None, valueOf_=None):
        self.ProductCode = _cast(None, ProductCode)
        self.RevisionNo = _cast(None, RevisionNo)
        self.ProductRevision = _cast(None, ProductRevision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HideTypeType.subclass:
            return HideTypeType.subclass(*args_, **kwargs_)
        else:
            return HideTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductCode(self): return self.ProductCode
    def set_ProductCode(self, ProductCode): self.ProductCode = ProductCode
    def get_RevisionNo(self): return self.RevisionNo
    def set_RevisionNo(self, RevisionNo): self.RevisionNo = RevisionNo
    def get_ProductRevision(self): return self.ProductRevision
    def set_ProductRevision(self, ProductRevision): self.ProductRevision = ProductRevision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HideTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HideTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HideTypeType'):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            outfile.write(' ProductCode=%s' % (quote_attrib(self.ProductCode), ))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            outfile.write(' RevisionNo=%s' % (quote_attrib(self.RevisionNo), ))
        if self.ProductRevision is not None and 'ProductRevision' not in already_processed:
            already_processed.add('ProductRevision')
            outfile.write(' ProductRevision=%s' % (self.gds_format_string(quote_attrib(self.ProductRevision).encode(ExternalEncoding), input_name='ProductRevision'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HideTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='HideTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            showIndent(outfile, level)
            outfile.write('ProductCode="%s",\n' % (self.ProductCode,))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            showIndent(outfile, level)
            outfile.write('RevisionNo="%s",\n' % (self.RevisionNo,))
        if self.ProductRevision is not None and 'ProductRevision' not in already_processed:
            already_processed.add('ProductRevision')
            showIndent(outfile, level)
            outfile.write('ProductRevision="%s",\n' % (self.ProductRevision,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ProductCode', node)
        if value is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            self.ProductCode = value
            self.validate_HexDecValue(self.ProductCode)    # validate type HexDecValue
        value = find_attr_value_('RevisionNo', node)
        if value is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            self.RevisionNo = value
            self.validate_HexDecValue(self.RevisionNo)    # validate type HexDecValue
        value = find_attr_value_('ProductRevision', node)
        if value is not None and 'ProductRevision' not in already_processed:
            already_processed.add('ProductRevision')
            self.ProductRevision = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HideTypeType


class AlternativeTypeType(GeneratedsSuper):
    """for future usefor future use"""
    subclass = None
    superclass = None
    def __init__(self, ProductCode=None, RevisionNo=None, valueOf_=None):
        self.ProductCode = _cast(None, ProductCode)
        self.RevisionNo = _cast(None, RevisionNo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AlternativeTypeType.subclass:
            return AlternativeTypeType.subclass(*args_, **kwargs_)
        else:
            return AlternativeTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductCode(self): return self.ProductCode
    def set_ProductCode(self, ProductCode): self.ProductCode = ProductCode
    def get_RevisionNo(self): return self.RevisionNo
    def set_RevisionNo(self, RevisionNo): self.RevisionNo = RevisionNo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AlternativeTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlternativeTypeType'):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            outfile.write(' ProductCode=%s' % (quote_attrib(self.ProductCode), ))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            outfile.write(' RevisionNo=%s' % (quote_attrib(self.RevisionNo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AlternativeTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AlternativeTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            showIndent(outfile, level)
            outfile.write('ProductCode="%s",\n' % (self.ProductCode,))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            showIndent(outfile, level)
            outfile.write('RevisionNo="%s",\n' % (self.RevisionNo,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ProductCode', node)
        if value is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            self.ProductCode = value
            self.validate_HexDecValue(self.ProductCode)    # validate type HexDecValue
        value = find_attr_value_('RevisionNo', node)
        if value is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            self.RevisionNo = value
            self.validate_HexDecValue(self.RevisionNo)    # validate type HexDecValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AlternativeTypeType


class SubDeviceType(GeneratedsSuper):
    """for future usefor future use"""
    subclass = None
    superclass = None
    def __init__(self, PreviousPortNo=None, ProductCode=None, RevisionNo=None, PreviousDevice=None, valueOf_=None):
        self.PreviousPortNo = _cast(int, PreviousPortNo)
        self.ProductCode = _cast(None, ProductCode)
        self.RevisionNo = _cast(None, RevisionNo)
        self.PreviousDevice = _cast(int, PreviousDevice)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SubDeviceType.subclass:
            return SubDeviceType.subclass(*args_, **kwargs_)
        else:
            return SubDeviceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PreviousPortNo(self): return self.PreviousPortNo
    def set_PreviousPortNo(self, PreviousPortNo): self.PreviousPortNo = PreviousPortNo
    def get_ProductCode(self): return self.ProductCode
    def set_ProductCode(self, ProductCode): self.ProductCode = ProductCode
    def get_RevisionNo(self): return self.RevisionNo
    def set_RevisionNo(self, RevisionNo): self.RevisionNo = RevisionNo
    def get_PreviousDevice(self): return self.PreviousDevice
    def set_PreviousDevice(self, PreviousDevice): self.PreviousDevice = PreviousDevice
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubDeviceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubDeviceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubDeviceType'):
        if self.PreviousPortNo is not None and 'PreviousPortNo' not in already_processed:
            already_processed.add('PreviousPortNo')
            outfile.write(' PreviousPortNo="%s"' % self.gds_format_integer(self.PreviousPortNo, input_name='PreviousPortNo'))
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            outfile.write(' ProductCode=%s' % (quote_attrib(self.ProductCode), ))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            outfile.write(' RevisionNo=%s' % (quote_attrib(self.RevisionNo), ))
        if self.PreviousDevice is not None and 'PreviousDevice' not in already_processed:
            already_processed.add('PreviousDevice')
            outfile.write(' PreviousDevice="%s"' % self.gds_format_integer(self.PreviousDevice, input_name='PreviousDevice'))
    def exportChildren(self, outfile, level, namespace_='', name_='SubDeviceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SubDeviceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PreviousPortNo is not None and 'PreviousPortNo' not in already_processed:
            already_processed.add('PreviousPortNo')
            showIndent(outfile, level)
            outfile.write('PreviousPortNo=%d,\n' % (self.PreviousPortNo,))
        if self.ProductCode is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            showIndent(outfile, level)
            outfile.write('ProductCode="%s",\n' % (self.ProductCode,))
        if self.RevisionNo is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            showIndent(outfile, level)
            outfile.write('RevisionNo="%s",\n' % (self.RevisionNo,))
        if self.PreviousDevice is not None and 'PreviousDevice' not in already_processed:
            already_processed.add('PreviousDevice')
            showIndent(outfile, level)
            outfile.write('PreviousDevice=%d,\n' % (self.PreviousDevice,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PreviousPortNo', node)
        if value is not None and 'PreviousPortNo' not in already_processed:
            already_processed.add('PreviousPortNo')
            try:
                self.PreviousPortNo = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ProductCode', node)
        if value is not None and 'ProductCode' not in already_processed:
            already_processed.add('ProductCode')
            self.ProductCode = value
            self.validate_HexDecValue(self.ProductCode)    # validate type HexDecValue
        value = find_attr_value_('RevisionNo', node)
        if value is not None and 'RevisionNo' not in already_processed:
            already_processed.add('RevisionNo')
            self.RevisionNo = value
            self.validate_HexDecValue(self.RevisionNo)    # validate type HexDecValue
        value = find_attr_value_('PreviousDevice', node)
        if value is not None and 'PreviousDevice' not in already_processed:
            already_processed.add('PreviousDevice')
            try:
                self.PreviousDevice = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubDeviceType


class ProfileType5(ProfileType):
    """obsolete"""
    subclass = None
    superclass = ProfileType
    def __init__(self, ProfileNo=None, AddInfo=None, ChannelCount=None, ChannelInfo=None, DictionaryFile=None, Dictionary=None, DiagFile=None, DiagMessages=None, VendorSpecific=None, Channel=None):
        super(ProfileType5, self).__init__(ProfileNo, AddInfo, ChannelCount, ChannelInfo, DictionaryFile, Dictionary, DiagFile, DiagMessages, VendorSpecific, )
        self.Channel = _cast(int, Channel)
        pass
    def factory(*args_, **kwargs_):
        if ProfileType5.subclass:
            return ProfileType5.subclass(*args_, **kwargs_)
        else:
            return ProfileType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Channel(self): return self.Channel
    def set_Channel(self, Channel): self.Channel = Channel
    def hasContent_(self):
        if (
            super(ProfileType5, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProfileType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProfileType5'):
        super(ProfileType5, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileType5')
        if self.Channel is not None and 'Channel' not in already_processed:
            already_processed.add('Channel')
            outfile.write(' Channel="%s"' % self.gds_format_integer(self.Channel, input_name='Channel'))
    def exportChildren(self, outfile, level, namespace_='', name_='ProfileType5', fromsubclass_=False, pretty_print=True):
        super(ProfileType5, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProfileType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Channel is not None and 'Channel' not in already_processed:
            already_processed.add('Channel')
            showIndent(outfile, level)
            outfile.write('Channel=%d,\n' % (self.Channel,))
        super(ProfileType5, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProfileType5, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Channel', node)
        if value is not None and 'Channel' not in already_processed:
            already_processed.add('Channel')
            try:
                self.Channel = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ProfileType5, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProfileType5, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProfileType5


class FmmuType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, Su=None, OpOnly=None, Sm=None, valueOf_=None):
        self.Su = _cast(int, Su)
        self.OpOnly = _cast(bool, OpOnly)
        self.Sm = _cast(int, Sm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FmmuType.subclass:
            return FmmuType.subclass(*args_, **kwargs_)
        else:
            return FmmuType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Su(self): return self.Su
    def set_Su(self, Su): self.Su = Su
    def get_OpOnly(self): return self.OpOnly
    def set_OpOnly(self, OpOnly): self.OpOnly = OpOnly
    def get_Sm(self): return self.Sm
    def set_Sm(self, Sm): self.Sm = Sm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FmmuType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FmmuType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FmmuType'):
        if self.Su is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            outfile.write(' Su="%s"' % self.gds_format_integer(self.Su, input_name='Su'))
        if self.OpOnly is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            outfile.write(' OpOnly="%s"' % self.gds_format_boolean(self.OpOnly, input_name='OpOnly'))
        if self.Sm is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            outfile.write(' Sm="%s"' % self.gds_format_integer(self.Sm, input_name='Sm'))
    def exportChildren(self, outfile, level, namespace_='', name_='FmmuType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FmmuType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Su is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            showIndent(outfile, level)
            outfile.write('Su=%d,\n' % (self.Su,))
        if self.OpOnly is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            showIndent(outfile, level)
            outfile.write('OpOnly=%s,\n' % (self.OpOnly,))
        if self.Sm is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            showIndent(outfile, level)
            outfile.write('Sm=%d,\n' % (self.Sm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Su', node)
        if value is not None and 'Su' not in already_processed:
            already_processed.add('Su')
            try:
                self.Su = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OpOnly', node)
        if value is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            if value in ('true', '1'):
                self.OpOnly = True
            elif value in ('false', '0'):
                self.OpOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Sm', node)
        if value is not None and 'Sm' not in already_processed:
            already_processed.add('Sm')
            try:
                self.Sm = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FmmuType


class SmType(GeneratedsSuper):
    """obsoleteobsoleteobsolete"""
    subclass = None
    superclass = None
    def __init__(self, Enable=None, OpOnly=None, DefaultSize=None, OneByteMode=None, FixedAssignment=None, ControlByte=None, MinSize=None, MaxSize=None, Virtual=None, StartAddress=None, Watchdog=None, valueOf_=None):
        self.Enable = _cast(None, Enable)
        self.OpOnly = _cast(bool, OpOnly)
        self.DefaultSize = _cast(None, DefaultSize)
        self.OneByteMode = _cast(bool, OneByteMode)
        self.FixedAssignment = _cast(bool, FixedAssignment)
        self.ControlByte = _cast(None, ControlByte)
        self.MinSize = _cast(None, MinSize)
        self.MaxSize = _cast(None, MaxSize)
        self.Virtual = _cast(bool, Virtual)
        self.StartAddress = _cast(None, StartAddress)
        self.Watchdog = _cast(bool, Watchdog)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SmType.subclass:
            return SmType.subclass(*args_, **kwargs_)
        else:
            return SmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enable(self): return self.Enable
    def set_Enable(self, Enable): self.Enable = Enable
    def get_OpOnly(self): return self.OpOnly
    def set_OpOnly(self, OpOnly): self.OpOnly = OpOnly
    def get_DefaultSize(self): return self.DefaultSize
    def set_DefaultSize(self, DefaultSize): self.DefaultSize = DefaultSize
    def get_OneByteMode(self): return self.OneByteMode
    def set_OneByteMode(self, OneByteMode): self.OneByteMode = OneByteMode
    def get_FixedAssignment(self): return self.FixedAssignment
    def set_FixedAssignment(self, FixedAssignment): self.FixedAssignment = FixedAssignment
    def get_ControlByte(self): return self.ControlByte
    def set_ControlByte(self, ControlByte): self.ControlByte = ControlByte
    def get_MinSize(self): return self.MinSize
    def set_MinSize(self, MinSize): self.MinSize = MinSize
    def get_MaxSize(self): return self.MaxSize
    def set_MaxSize(self, MaxSize): self.MaxSize = MaxSize
    def get_Virtual(self): return self.Virtual
    def set_Virtual(self, Virtual): self.Virtual = Virtual
    def get_StartAddress(self): return self.StartAddress
    def set_StartAddress(self, StartAddress): self.StartAddress = StartAddress
    def get_Watchdog(self): return self.Watchdog
    def set_Watchdog(self, Watchdog): self.Watchdog = Watchdog
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SmType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SmType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SmType'):
        if self.Enable is not None and 'Enable' not in already_processed:
            already_processed.add('Enable')
            outfile.write(' Enable=%s' % (quote_attrib(self.Enable), ))
        if self.OpOnly is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            outfile.write(' OpOnly="%s"' % self.gds_format_boolean(self.OpOnly, input_name='OpOnly'))
        if self.DefaultSize is not None and 'DefaultSize' not in already_processed:
            already_processed.add('DefaultSize')
            outfile.write(' DefaultSize=%s' % (quote_attrib(self.DefaultSize), ))
        if self.OneByteMode is not None and 'OneByteMode' not in already_processed:
            already_processed.add('OneByteMode')
            outfile.write(' OneByteMode="%s"' % self.gds_format_boolean(self.OneByteMode, input_name='OneByteMode'))
        if self.FixedAssignment is not None and 'FixedAssignment' not in already_processed:
            already_processed.add('FixedAssignment')
            outfile.write(' FixedAssignment="%s"' % self.gds_format_boolean(self.FixedAssignment, input_name='FixedAssignment'))
        if self.ControlByte is not None and 'ControlByte' not in already_processed:
            already_processed.add('ControlByte')
            outfile.write(' ControlByte=%s' % (quote_attrib(self.ControlByte), ))
        if self.MinSize is not None and 'MinSize' not in already_processed:
            already_processed.add('MinSize')
            outfile.write(' MinSize=%s' % (quote_attrib(self.MinSize), ))
        if self.MaxSize is not None and 'MaxSize' not in already_processed:
            already_processed.add('MaxSize')
            outfile.write(' MaxSize=%s' % (quote_attrib(self.MaxSize), ))
        if self.Virtual is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            outfile.write(' Virtual="%s"' % self.gds_format_boolean(self.Virtual, input_name='Virtual'))
        if self.StartAddress is not None and 'StartAddress' not in already_processed:
            already_processed.add('StartAddress')
            outfile.write(' StartAddress=%s' % (quote_attrib(self.StartAddress), ))
        if self.Watchdog is not None and 'Watchdog' not in already_processed:
            already_processed.add('Watchdog')
            outfile.write(' Watchdog="%s"' % self.gds_format_boolean(self.Watchdog, input_name='Watchdog'))
    def exportChildren(self, outfile, level, namespace_='', name_='SmType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Enable is not None and 'Enable' not in already_processed:
            already_processed.add('Enable')
            showIndent(outfile, level)
            outfile.write('Enable="%s",\n' % (self.Enable,))
        if self.OpOnly is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            showIndent(outfile, level)
            outfile.write('OpOnly=%s,\n' % (self.OpOnly,))
        if self.DefaultSize is not None and 'DefaultSize' not in already_processed:
            already_processed.add('DefaultSize')
            showIndent(outfile, level)
            outfile.write('DefaultSize="%s",\n' % (self.DefaultSize,))
        if self.OneByteMode is not None and 'OneByteMode' not in already_processed:
            already_processed.add('OneByteMode')
            showIndent(outfile, level)
            outfile.write('OneByteMode=%s,\n' % (self.OneByteMode,))
        if self.FixedAssignment is not None and 'FixedAssignment' not in already_processed:
            already_processed.add('FixedAssignment')
            showIndent(outfile, level)
            outfile.write('FixedAssignment=%s,\n' % (self.FixedAssignment,))
        if self.ControlByte is not None and 'ControlByte' not in already_processed:
            already_processed.add('ControlByte')
            showIndent(outfile, level)
            outfile.write('ControlByte="%s",\n' % (self.ControlByte,))
        if self.MinSize is not None and 'MinSize' not in already_processed:
            already_processed.add('MinSize')
            showIndent(outfile, level)
            outfile.write('MinSize="%s",\n' % (self.MinSize,))
        if self.MaxSize is not None and 'MaxSize' not in already_processed:
            already_processed.add('MaxSize')
            showIndent(outfile, level)
            outfile.write('MaxSize="%s",\n' % (self.MaxSize,))
        if self.Virtual is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            showIndent(outfile, level)
            outfile.write('Virtual=%s,\n' % (self.Virtual,))
        if self.StartAddress is not None and 'StartAddress' not in already_processed:
            already_processed.add('StartAddress')
            showIndent(outfile, level)
            outfile.write('StartAddress="%s",\n' % (self.StartAddress,))
        if self.Watchdog is not None and 'Watchdog' not in already_processed:
            already_processed.add('Watchdog')
            showIndent(outfile, level)
            outfile.write('Watchdog=%s,\n' % (self.Watchdog,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Enable', node)
        if value is not None and 'Enable' not in already_processed:
            already_processed.add('Enable')
            self.Enable = value
            self.validate_HexDecValue(self.Enable)    # validate type HexDecValue
        value = find_attr_value_('OpOnly', node)
        if value is not None and 'OpOnly' not in already_processed:
            already_processed.add('OpOnly')
            if value in ('true', '1'):
                self.OpOnly = True
            elif value in ('false', '0'):
                self.OpOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DefaultSize', node)
        if value is not None and 'DefaultSize' not in already_processed:
            already_processed.add('DefaultSize')
            self.DefaultSize = value
            self.validate_HexDecValue(self.DefaultSize)    # validate type HexDecValue
        value = find_attr_value_('OneByteMode', node)
        if value is not None and 'OneByteMode' not in already_processed:
            already_processed.add('OneByteMode')
            if value in ('true', '1'):
                self.OneByteMode = True
            elif value in ('false', '0'):
                self.OneByteMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('FixedAssignment', node)
        if value is not None and 'FixedAssignment' not in already_processed:
            already_processed.add('FixedAssignment')
            if value in ('true', '1'):
                self.FixedAssignment = True
            elif value in ('false', '0'):
                self.FixedAssignment = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ControlByte', node)
        if value is not None and 'ControlByte' not in already_processed:
            already_processed.add('ControlByte')
            self.ControlByte = value
            self.validate_HexDecValue(self.ControlByte)    # validate type HexDecValue
        value = find_attr_value_('MinSize', node)
        if value is not None and 'MinSize' not in already_processed:
            already_processed.add('MinSize')
            self.MinSize = value
            self.validate_HexDecValue(self.MinSize)    # validate type HexDecValue
        value = find_attr_value_('MaxSize', node)
        if value is not None and 'MaxSize' not in already_processed:
            already_processed.add('MaxSize')
            self.MaxSize = value
            self.validate_HexDecValue(self.MaxSize)    # validate type HexDecValue
        value = find_attr_value_('Virtual', node)
        if value is not None and 'Virtual' not in already_processed:
            already_processed.add('Virtual')
            if value in ('true', '1'):
                self.Virtual = True
            elif value in ('false', '0'):
                self.Virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StartAddress', node)
        if value is not None and 'StartAddress' not in already_processed:
            already_processed.add('StartAddress')
            self.StartAddress = value
            self.validate_HexDecValue(self.StartAddress)    # validate type HexDecValue
        value = find_attr_value_('Watchdog', node)
        if value is not None and 'Watchdog' not in already_processed:
            already_processed.add('Watchdog')
            if value in ('true', '1'):
                self.Watchdog = True
            elif value in ('false', '0'):
                self.Watchdog = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SmType


class SuType(GeneratedsSuper):
    """for future use"""
    subclass = None
    superclass = None
    def __init__(self, DependOnInputState=None, FrameRepeatSupport=None, SeparateSu=None, SeparateFrame=None, valueOf_=None):
        self.DependOnInputState = _cast(bool, DependOnInputState)
        self.FrameRepeatSupport = _cast(bool, FrameRepeatSupport)
        self.SeparateSu = _cast(bool, SeparateSu)
        self.SeparateFrame = _cast(bool, SeparateFrame)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SuType.subclass:
            return SuType.subclass(*args_, **kwargs_)
        else:
            return SuType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DependOnInputState(self): return self.DependOnInputState
    def set_DependOnInputState(self, DependOnInputState): self.DependOnInputState = DependOnInputState
    def get_FrameRepeatSupport(self): return self.FrameRepeatSupport
    def set_FrameRepeatSupport(self, FrameRepeatSupport): self.FrameRepeatSupport = FrameRepeatSupport
    def get_SeparateSu(self): return self.SeparateSu
    def set_SeparateSu(self, SeparateSu): self.SeparateSu = SeparateSu
    def get_SeparateFrame(self): return self.SeparateFrame
    def set_SeparateFrame(self, SeparateFrame): self.SeparateFrame = SeparateFrame
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SuType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SuType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SuType'):
        if self.DependOnInputState is not None and 'DependOnInputState' not in already_processed:
            already_processed.add('DependOnInputState')
            outfile.write(' DependOnInputState="%s"' % self.gds_format_boolean(self.DependOnInputState, input_name='DependOnInputState'))
        if self.FrameRepeatSupport is not None and 'FrameRepeatSupport' not in already_processed:
            already_processed.add('FrameRepeatSupport')
            outfile.write(' FrameRepeatSupport="%s"' % self.gds_format_boolean(self.FrameRepeatSupport, input_name='FrameRepeatSupport'))
        if self.SeparateSu is not None and 'SeparateSu' not in already_processed:
            already_processed.add('SeparateSu')
            outfile.write(' SeparateSu="%s"' % self.gds_format_boolean(self.SeparateSu, input_name='SeparateSu'))
        if self.SeparateFrame is not None and 'SeparateFrame' not in already_processed:
            already_processed.add('SeparateFrame')
            outfile.write(' SeparateFrame="%s"' % self.gds_format_boolean(self.SeparateFrame, input_name='SeparateFrame'))
    def exportChildren(self, outfile, level, namespace_='', name_='SuType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SuType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DependOnInputState is not None and 'DependOnInputState' not in already_processed:
            already_processed.add('DependOnInputState')
            showIndent(outfile, level)
            outfile.write('DependOnInputState=%s,\n' % (self.DependOnInputState,))
        if self.FrameRepeatSupport is not None and 'FrameRepeatSupport' not in already_processed:
            already_processed.add('FrameRepeatSupport')
            showIndent(outfile, level)
            outfile.write('FrameRepeatSupport=%s,\n' % (self.FrameRepeatSupport,))
        if self.SeparateSu is not None and 'SeparateSu' not in already_processed:
            already_processed.add('SeparateSu')
            showIndent(outfile, level)
            outfile.write('SeparateSu=%s,\n' % (self.SeparateSu,))
        if self.SeparateFrame is not None and 'SeparateFrame' not in already_processed:
            already_processed.add('SeparateFrame')
            showIndent(outfile, level)
            outfile.write('SeparateFrame=%s,\n' % (self.SeparateFrame,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DependOnInputState', node)
        if value is not None and 'DependOnInputState' not in already_processed:
            already_processed.add('DependOnInputState')
            if value in ('true', '1'):
                self.DependOnInputState = True
            elif value in ('false', '0'):
                self.DependOnInputState = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('FrameRepeatSupport', node)
        if value is not None and 'FrameRepeatSupport' not in already_processed:
            already_processed.add('FrameRepeatSupport')
            if value in ('true', '1'):
                self.FrameRepeatSupport = True
            elif value in ('false', '0'):
                self.FrameRepeatSupport = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SeparateSu', node)
        if value is not None and 'SeparateSu' not in already_processed:
            already_processed.add('SeparateSu')
            if value in ('true', '1'):
                self.SeparateSu = True
            elif value in ('false', '0'):
                self.SeparateSu = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SeparateFrame', node)
        if value is not None and 'SeparateFrame' not in already_processed:
            already_processed.add('SeparateFrame')
            if value in ('true', '1'):
                self.SeparateFrame = True
            elif value in ('false', '0'):
                self.SeparateFrame = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SuType


class MailboxType(GeneratedsSuper):
    """for future use"""
    subclass = None
    superclass = None
    def __init__(self, DataLinkLayer=False, RealTimeMode=False, AoE=None, EoE=None, CoE=None, FoE=None, SoE=None, VoE=None, VendorSpecific=None):
        self.DataLinkLayer = _cast(bool, DataLinkLayer)
        self.RealTimeMode = _cast(bool, RealTimeMode)
        self.AoE = AoE
        self.EoE = EoE
        self.CoE = CoE
        self.FoE = FoE
        self.SoE = SoE
        self.VoE = VoE
        self.VendorSpecific = VendorSpecific
    def factory(*args_, **kwargs_):
        if MailboxType.subclass:
            return MailboxType.subclass(*args_, **kwargs_)
        else:
            return MailboxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AoE(self): return self.AoE
    def set_AoE(self, AoE): self.AoE = AoE
    def get_EoE(self): return self.EoE
    def set_EoE(self, EoE): self.EoE = EoE
    def get_CoE(self): return self.CoE
    def set_CoE(self, CoE): self.CoE = CoE
    def get_FoE(self): return self.FoE
    def set_FoE(self, FoE): self.FoE = FoE
    def get_SoE(self): return self.SoE
    def set_SoE(self, SoE): self.SoE = SoE
    def get_VoE(self): return self.VoE
    def set_VoE(self, VoE): self.VoE = VoE
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_DataLinkLayer(self): return self.DataLinkLayer
    def set_DataLinkLayer(self, DataLinkLayer): self.DataLinkLayer = DataLinkLayer
    def get_RealTimeMode(self): return self.RealTimeMode
    def set_RealTimeMode(self, RealTimeMode): self.RealTimeMode = RealTimeMode
    def hasContent_(self):
        if (
            self.AoE is not None or
            self.EoE is not None or
            self.CoE is not None or
            self.FoE is not None or
            self.SoE is not None or
            self.VoE is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MailboxType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MailboxType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MailboxType'):
        if self.DataLinkLayer is not None and 'DataLinkLayer' not in already_processed:
            already_processed.add('DataLinkLayer')
            outfile.write(' DataLinkLayer="%s"' % self.gds_format_boolean(self.DataLinkLayer, input_name='DataLinkLayer'))
        if self.RealTimeMode is not None and 'RealTimeMode' not in already_processed:
            already_processed.add('RealTimeMode')
            outfile.write(' RealTimeMode="%s"' % self.gds_format_boolean(self.RealTimeMode, input_name='RealTimeMode'))
    def exportChildren(self, outfile, level, namespace_='', name_='MailboxType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AoE is not None:
            self.AoE.export(outfile, level, namespace_, name_='AoE', pretty_print=pretty_print)
        if self.EoE is not None:
            self.EoE.export(outfile, level, namespace_, name_='EoE', pretty_print=pretty_print)
        if self.CoE is not None:
            self.CoE.export(outfile, level, namespace_, name_='CoE', pretty_print=pretty_print)
        if self.FoE is not None:
            self.FoE.export(outfile, level, namespace_, name_='FoE', pretty_print=pretty_print)
        if self.SoE is not None:
            self.SoE.export(outfile, level, namespace_, name_='SoE', pretty_print=pretty_print)
        if self.VoE is not None:
            self.VoE.export(outfile, level, namespace_, name_='VoE', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MailboxType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataLinkLayer is not None and 'DataLinkLayer' not in already_processed:
            already_processed.add('DataLinkLayer')
            showIndent(outfile, level)
            outfile.write('DataLinkLayer=%s,\n' % (self.DataLinkLayer,))
        if self.RealTimeMode is not None and 'RealTimeMode' not in already_processed:
            already_processed.add('RealTimeMode')
            showIndent(outfile, level)
            outfile.write('RealTimeMode=%s,\n' % (self.RealTimeMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AoE is not None:
            showIndent(outfile, level)
            outfile.write('AoE=model_.AoEType(\n')
            self.AoE.exportLiteral(outfile, level, name_='AoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EoE is not None:
            showIndent(outfile, level)
            outfile.write('EoE=model_.EoEType(\n')
            self.EoE.exportLiteral(outfile, level, name_='EoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CoE is not None:
            showIndent(outfile, level)
            outfile.write('CoE=model_.CoEType(\n')
            self.CoE.exportLiteral(outfile, level, name_='CoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FoE is not None:
            showIndent(outfile, level)
            outfile.write('FoE=model_.FoEType(\n')
            self.FoE.exportLiteral(outfile, level, name_='FoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SoE is not None:
            showIndent(outfile, level)
            outfile.write('SoE=model_.SoEType(\n')
            self.SoE.exportLiteral(outfile, level, name_='SoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VoE is not None:
            showIndent(outfile, level)
            outfile.write('VoE=model_.VoEType(\n')
            self.VoE.exportLiteral(outfile, level, name_='VoE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataLinkLayer', node)
        if value is not None and 'DataLinkLayer' not in already_processed:
            already_processed.add('DataLinkLayer')
            if value in ('true', '1'):
                self.DataLinkLayer = True
            elif value in ('false', '0'):
                self.DataLinkLayer = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('RealTimeMode', node)
        if value is not None and 'RealTimeMode' not in already_processed:
            already_processed.add('RealTimeMode')
            if value in ('true', '1'):
                self.RealTimeMode = True
            elif value in ('false', '0'):
                self.RealTimeMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AoE':
            obj_ = AoEType.factory()
            obj_.build(child_)
            self.AoE = obj_
        elif nodeName_ == 'EoE':
            obj_ = EoEType.factory()
            obj_.build(child_)
            self.EoE = obj_
        elif nodeName_ == 'CoE':
            obj_ = CoEType.factory()
            obj_.build(child_)
            self.CoE = obj_
        elif nodeName_ == 'FoE':
            obj_ = FoEType.factory()
            obj_.build(child_)
            self.FoE = obj_
        elif nodeName_ == 'SoE':
            obj_ = SoEType.factory()
            obj_.build(child_)
            self.SoE = obj_
        elif nodeName_ == 'VoE':
            obj_ = VoEType.factory()
            obj_.build(child_)
            self.VoE = obj_
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class MailboxType


class AoEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdsRouter=None, GenerateOwnNetId=None, InitializeOwnNetId=None, InitCmd=None):
        self.AdsRouter = _cast(bool, AdsRouter)
        self.GenerateOwnNetId = _cast(bool, GenerateOwnNetId)
        self.InitializeOwnNetId = _cast(bool, InitializeOwnNetId)
        if InitCmd is None:
            self.InitCmd = []
        else:
            self.InitCmd = InitCmd
    def factory(*args_, **kwargs_):
        if AoEType.subclass:
            return AoEType.subclass(*args_, **kwargs_)
        else:
            return AoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InitCmd(self): return self.InitCmd
    def set_InitCmd(self, InitCmd): self.InitCmd = InitCmd
    def add_InitCmd(self, value): self.InitCmd.append(value)
    def insert_InitCmd(self, index, value): self.InitCmd[index] = value
    def get_AdsRouter(self): return self.AdsRouter
    def set_AdsRouter(self, AdsRouter): self.AdsRouter = AdsRouter
    def get_GenerateOwnNetId(self): return self.GenerateOwnNetId
    def set_GenerateOwnNetId(self, GenerateOwnNetId): self.GenerateOwnNetId = GenerateOwnNetId
    def get_InitializeOwnNetId(self): return self.InitializeOwnNetId
    def set_InitializeOwnNetId(self, InitializeOwnNetId): self.InitializeOwnNetId = InitializeOwnNetId
    def hasContent_(self):
        if (
            self.InitCmd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AoEType'):
        if self.AdsRouter is not None and 'AdsRouter' not in already_processed:
            already_processed.add('AdsRouter')
            outfile.write(' AdsRouter="%s"' % self.gds_format_boolean(self.AdsRouter, input_name='AdsRouter'))
        if self.GenerateOwnNetId is not None and 'GenerateOwnNetId' not in already_processed:
            already_processed.add('GenerateOwnNetId')
            outfile.write(' GenerateOwnNetId="%s"' % self.gds_format_boolean(self.GenerateOwnNetId, input_name='GenerateOwnNetId'))
        if self.InitializeOwnNetId is not None and 'InitializeOwnNetId' not in already_processed:
            already_processed.add('InitializeOwnNetId')
            outfile.write(' InitializeOwnNetId="%s"' % self.gds_format_boolean(self.InitializeOwnNetId, input_name='InitializeOwnNetId'))
    def exportChildren(self, outfile, level, namespace_='', name_='AoEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InitCmd_ in self.InitCmd:
            InitCmd_.export(outfile, level, namespace_, name_='InitCmd', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AdsRouter is not None and 'AdsRouter' not in already_processed:
            already_processed.add('AdsRouter')
            showIndent(outfile, level)
            outfile.write('AdsRouter=%s,\n' % (self.AdsRouter,))
        if self.GenerateOwnNetId is not None and 'GenerateOwnNetId' not in already_processed:
            already_processed.add('GenerateOwnNetId')
            showIndent(outfile, level)
            outfile.write('GenerateOwnNetId=%s,\n' % (self.GenerateOwnNetId,))
        if self.InitializeOwnNetId is not None and 'InitializeOwnNetId' not in already_processed:
            already_processed.add('InitializeOwnNetId')
            showIndent(outfile, level)
            outfile.write('InitializeOwnNetId=%s,\n' % (self.InitializeOwnNetId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InitCmd=[\n')
        level += 1
        for InitCmd_ in self.InitCmd:
            showIndent(outfile, level)
            outfile.write('model_.InitCmdType(\n')
            InitCmd_.exportLiteral(outfile, level, name_='InitCmdType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AdsRouter', node)
        if value is not None and 'AdsRouter' not in already_processed:
            already_processed.add('AdsRouter')
            if value in ('true', '1'):
                self.AdsRouter = True
            elif value in ('false', '0'):
                self.AdsRouter = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('GenerateOwnNetId', node)
        if value is not None and 'GenerateOwnNetId' not in already_processed:
            already_processed.add('GenerateOwnNetId')
            if value in ('true', '1'):
                self.GenerateOwnNetId = True
            elif value in ('false', '0'):
                self.GenerateOwnNetId = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('InitializeOwnNetId', node)
        if value is not None and 'InitializeOwnNetId' not in already_processed:
            already_processed.add('InitializeOwnNetId')
            if value in ('true', '1'):
                self.InitializeOwnNetId = True
            elif value in ('false', '0'):
                self.InitializeOwnNetId = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InitCmd':
            obj_ = InitCmdType.factory()
            obj_.build(child_)
            self.InitCmd.append(obj_)
# end class AoEType


class InitCmdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transition=None, Data=None, Comment=None):
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if InitCmdType.subclass:
            return InitCmdType.subclass(*args_, **kwargs_)
        else:
            return InitCmdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition(self, index, value): self.Transition[index] = value
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def validate_TransitionType(self, value):
        # Validate type TransitionType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Transition or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitCmdType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitCmdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitCmdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InitCmdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transition_ in self.Transition:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(Transition_).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InitCmdType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition.append(Transition_)
            self.validate_TransitionType(self.Transition)    # validate type TransitionType
        elif nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class InitCmdType


class EoEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IP=False, MAC=False, TimeStamp=False, InitCmd=None):
        self.IP = _cast(bool, IP)
        self.MAC = _cast(bool, MAC)
        self.TimeStamp = _cast(bool, TimeStamp)
        if InitCmd is None:
            self.InitCmd = []
        else:
            self.InitCmd = InitCmd
    def factory(*args_, **kwargs_):
        if EoEType.subclass:
            return EoEType.subclass(*args_, **kwargs_)
        else:
            return EoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InitCmd(self): return self.InitCmd
    def set_InitCmd(self, InitCmd): self.InitCmd = InitCmd
    def add_InitCmd(self, value): self.InitCmd.append(value)
    def insert_InitCmd(self, index, value): self.InitCmd[index] = value
    def get_IP(self): return self.IP
    def set_IP(self, IP): self.IP = IP
    def get_MAC(self): return self.MAC
    def set_MAC(self, MAC): self.MAC = MAC
    def get_TimeStamp(self): return self.TimeStamp
    def set_TimeStamp(self, TimeStamp): self.TimeStamp = TimeStamp
    def hasContent_(self):
        if (
            self.InitCmd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EoEType'):
        if self.IP is not None and 'IP' not in already_processed:
            already_processed.add('IP')
            outfile.write(' IP="%s"' % self.gds_format_boolean(self.IP, input_name='IP'))
        if self.MAC is not None and 'MAC' not in already_processed:
            already_processed.add('MAC')
            outfile.write(' MAC="%s"' % self.gds_format_boolean(self.MAC, input_name='MAC'))
        if self.TimeStamp is not None and 'TimeStamp' not in already_processed:
            already_processed.add('TimeStamp')
            outfile.write(' TimeStamp="%s"' % self.gds_format_boolean(self.TimeStamp, input_name='TimeStamp'))
    def exportChildren(self, outfile, level, namespace_='', name_='EoEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InitCmd_ in self.InitCmd:
            InitCmd_.export(outfile, level, namespace_, name_='InitCmd', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.IP is not None and 'IP' not in already_processed:
            already_processed.add('IP')
            showIndent(outfile, level)
            outfile.write('IP=%s,\n' % (self.IP,))
        if self.MAC is not None and 'MAC' not in already_processed:
            already_processed.add('MAC')
            showIndent(outfile, level)
            outfile.write('MAC=%s,\n' % (self.MAC,))
        if self.TimeStamp is not None and 'TimeStamp' not in already_processed:
            already_processed.add('TimeStamp')
            showIndent(outfile, level)
            outfile.write('TimeStamp=%s,\n' % (self.TimeStamp,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InitCmd=[\n')
        level += 1
        for InitCmd_ in self.InitCmd:
            showIndent(outfile, level)
            outfile.write('model_.InitCmdType6(\n')
            InitCmd_.exportLiteral(outfile, level, name_='InitCmdType6')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IP', node)
        if value is not None and 'IP' not in already_processed:
            already_processed.add('IP')
            if value in ('true', '1'):
                self.IP = True
            elif value in ('false', '0'):
                self.IP = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MAC', node)
        if value is not None and 'MAC' not in already_processed:
            already_processed.add('MAC')
            if value in ('true', '1'):
                self.MAC = True
            elif value in ('false', '0'):
                self.MAC = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('TimeStamp', node)
        if value is not None and 'TimeStamp' not in already_processed:
            already_processed.add('TimeStamp')
            if value in ('true', '1'):
                self.TimeStamp = True
            elif value in ('false', '0'):
                self.TimeStamp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InitCmd':
            obj_ = InitCmdType6.factory()
            obj_.build(child_)
            self.InitCmd.append(obj_)
# end class EoEType


class InitCmdType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transition=None, Type=None, Data=None, Comment=None):
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        self.Type = Type
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if InitCmdType6.subclass:
            return InitCmdType6.subclass(*args_, **kwargs_)
        else:
            return InitCmdType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition(self, index, value): self.Transition[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def validate_TransitionType7(self, value):
        # Validate type TransitionType7, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Transition or
            self.Type is not None or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitCmdType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitCmdType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitCmdType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InitCmdType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transition_ in self.Transition:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(Transition_).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_integer(self.Type, input_name='Type'), namespace_, eol_))
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InitCmdType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%d,\n' % self.Type)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition.append(Transition_)
            self.validate_TransitionType7(self.Transition)    # validate type TransitionType7
        elif nodeName_ == 'Type':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Type')
            self.Type = ival_
        elif nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class InitCmdType6


class CoEType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, SdoInfo=None, PdoConfig=None, PdoUpload=None, EdsFile=None, DiagHistory=None, PdoAssign=None, SegmentedSdo=None, DS402Channels=None, CompleteAccess=None, Object=None, InitCmd=None):
        self.SdoInfo = _cast(bool, SdoInfo)
        self.PdoConfig = _cast(bool, PdoConfig)
        self.PdoUpload = _cast(bool, PdoUpload)
        self.EdsFile = _cast(None, EdsFile)
        self.DiagHistory = _cast(bool, DiagHistory)
        self.PdoAssign = _cast(bool, PdoAssign)
        self.SegmentedSdo = _cast(bool, SegmentedSdo)
        self.DS402Channels = _cast(int, DS402Channels)
        self.CompleteAccess = _cast(bool, CompleteAccess)
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
        if InitCmd is None:
            self.InitCmd = []
        else:
            self.InitCmd = InitCmd
    def factory(*args_, **kwargs_):
        if CoEType.subclass:
            return CoEType.subclass(*args_, **kwargs_)
        else:
            return CoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def get_InitCmd(self): return self.InitCmd
    def set_InitCmd(self, InitCmd): self.InitCmd = InitCmd
    def add_InitCmd(self, value): self.InitCmd.append(value)
    def insert_InitCmd(self, index, value): self.InitCmd[index] = value
    def get_SdoInfo(self): return self.SdoInfo
    def set_SdoInfo(self, SdoInfo): self.SdoInfo = SdoInfo
    def get_PdoConfig(self): return self.PdoConfig
    def set_PdoConfig(self, PdoConfig): self.PdoConfig = PdoConfig
    def get_PdoUpload(self): return self.PdoUpload
    def set_PdoUpload(self, PdoUpload): self.PdoUpload = PdoUpload
    def get_EdsFile(self): return self.EdsFile
    def set_EdsFile(self, EdsFile): self.EdsFile = EdsFile
    def get_DiagHistory(self): return self.DiagHistory
    def set_DiagHistory(self, DiagHistory): self.DiagHistory = DiagHistory
    def get_PdoAssign(self): return self.PdoAssign
    def set_PdoAssign(self, PdoAssign): self.PdoAssign = PdoAssign
    def get_SegmentedSdo(self): return self.SegmentedSdo
    def set_SegmentedSdo(self, SegmentedSdo): self.SegmentedSdo = SegmentedSdo
    def get_DS402Channels(self): return self.DS402Channels
    def set_DS402Channels(self, DS402Channels): self.DS402Channels = DS402Channels
    def get_CompleteAccess(self): return self.CompleteAccess
    def set_CompleteAccess(self, CompleteAccess): self.CompleteAccess = CompleteAccess
    def hasContent_(self):
        if (
            self.Object or
            self.InitCmd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoEType'):
        if self.SdoInfo is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            outfile.write(' SdoInfo="%s"' % self.gds_format_boolean(self.SdoInfo, input_name='SdoInfo'))
        if self.PdoConfig is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            outfile.write(' PdoConfig="%s"' % self.gds_format_boolean(self.PdoConfig, input_name='PdoConfig'))
        if self.PdoUpload is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            outfile.write(' PdoUpload="%s"' % self.gds_format_boolean(self.PdoUpload, input_name='PdoUpload'))
        if self.EdsFile is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            outfile.write(' EdsFile=%s' % (self.gds_format_string(quote_attrib(self.EdsFile).encode(ExternalEncoding), input_name='EdsFile'), ))
        if self.DiagHistory is not None and 'DiagHistory' not in already_processed:
            already_processed.add('DiagHistory')
            outfile.write(' DiagHistory="%s"' % self.gds_format_boolean(self.DiagHistory, input_name='DiagHistory'))
        if self.PdoAssign is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            outfile.write(' PdoAssign="%s"' % self.gds_format_boolean(self.PdoAssign, input_name='PdoAssign'))
        if self.SegmentedSdo is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            outfile.write(' SegmentedSdo="%s"' % self.gds_format_boolean(self.SegmentedSdo, input_name='SegmentedSdo'))
        if self.DS402Channels is not None and 'DS402Channels' not in already_processed:
            already_processed.add('DS402Channels')
            outfile.write(' DS402Channels="%s"' % self.gds_format_integer(self.DS402Channels, input_name='DS402Channels'))
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            outfile.write(' CompleteAccess="%s"' % self.gds_format_boolean(self.CompleteAccess, input_name='CompleteAccess'))
    def exportChildren(self, outfile, level, namespace_='', name_='CoEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object', pretty_print=pretty_print)
        for InitCmd_ in self.InitCmd:
            InitCmd_.export(outfile, level, namespace_, name_='InitCmd', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SdoInfo is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            showIndent(outfile, level)
            outfile.write('SdoInfo=%s,\n' % (self.SdoInfo,))
        if self.PdoConfig is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            showIndent(outfile, level)
            outfile.write('PdoConfig=%s,\n' % (self.PdoConfig,))
        if self.PdoUpload is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            showIndent(outfile, level)
            outfile.write('PdoUpload=%s,\n' % (self.PdoUpload,))
        if self.EdsFile is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            showIndent(outfile, level)
            outfile.write('EdsFile="%s",\n' % (self.EdsFile,))
        if self.DiagHistory is not None and 'DiagHistory' not in already_processed:
            already_processed.add('DiagHistory')
            showIndent(outfile, level)
            outfile.write('DiagHistory=%s,\n' % (self.DiagHistory,))
        if self.PdoAssign is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            showIndent(outfile, level)
            outfile.write('PdoAssign=%s,\n' % (self.PdoAssign,))
        if self.SegmentedSdo is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            showIndent(outfile, level)
            outfile.write('SegmentedSdo=%s,\n' % (self.SegmentedSdo,))
        if self.DS402Channels is not None and 'DS402Channels' not in already_processed:
            already_processed.add('DS402Channels')
            showIndent(outfile, level)
            outfile.write('DS402Channels=%d,\n' % (self.DS402Channels,))
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            showIndent(outfile, level)
            outfile.write('CompleteAccess=%s,\n' % (self.CompleteAccess,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.ObjectType8(\n')
            Object_.exportLiteral(outfile, level, name_='ObjectType8')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InitCmd=[\n')
        level += 1
        for InitCmd_ in self.InitCmd:
            showIndent(outfile, level)
            outfile.write('model_.InitCmdType9(\n')
            InitCmd_.exportLiteral(outfile, level, name_='InitCmdType9')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SdoInfo', node)
        if value is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            if value in ('true', '1'):
                self.SdoInfo = True
            elif value in ('false', '0'):
                self.SdoInfo = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PdoConfig', node)
        if value is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            if value in ('true', '1'):
                self.PdoConfig = True
            elif value in ('false', '0'):
                self.PdoConfig = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PdoUpload', node)
        if value is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            if value in ('true', '1'):
                self.PdoUpload = True
            elif value in ('false', '0'):
                self.PdoUpload = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('EdsFile', node)
        if value is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            self.EdsFile = value
        value = find_attr_value_('DiagHistory', node)
        if value is not None and 'DiagHistory' not in already_processed:
            already_processed.add('DiagHistory')
            if value in ('true', '1'):
                self.DiagHistory = True
            elif value in ('false', '0'):
                self.DiagHistory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PdoAssign', node)
        if value is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            if value in ('true', '1'):
                self.PdoAssign = True
            elif value in ('false', '0'):
                self.PdoAssign = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SegmentedSdo', node)
        if value is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            if value in ('true', '1'):
                self.SegmentedSdo = True
            elif value in ('false', '0'):
                self.SegmentedSdo = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DS402Channels', node)
        if value is not None and 'DS402Channels' not in already_processed:
            already_processed.add('DS402Channels')
            try:
                self.DS402Channels = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CompleteAccess', node)
        if value is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            if value in ('true', '1'):
                self.CompleteAccess = True
            elif value in ('false', '0'):
                self.CompleteAccess = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = ObjectType8.factory()
            obj_.build(child_)
            self.Object.append(obj_)
        elif nodeName_ == 'InitCmd':
            obj_ = InitCmdType9.factory()
            obj_.build(child_)
            self.InitCmd.append(obj_)
# end class CoEType


class ObjectType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, SubIndex=None, Data=None, Comment=None):
        self.Index = Index
        self.SubIndex = SubIndex
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ObjectType8.subclass:
            return ObjectType8.subclass(*args_, **kwargs_)
        else:
            return ObjectType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_SubIndex(self): return self.SubIndex
    def set_SubIndex(self, SubIndex): self.SubIndex = SubIndex
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def hasContent_(self):
        if (
            self.Index is not None or
            self.SubIndex is not None or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_integer(self.Index, input_name='Index'), namespace_, eol_))
        if self.SubIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubIndex>%s</%sSubIndex>%s' % (namespace_, self.gds_format_integer(self.SubIndex, input_name='SubIndex'), namespace_, eol_))
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ObjectType8'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%d,\n' % self.Index)
        if self.SubIndex is not None:
            showIndent(outfile, level)
            outfile.write('SubIndex=%d,\n' % self.SubIndex)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Index')
            self.Index = ival_
        elif nodeName_ == 'SubIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SubIndex')
            self.SubIndex = ival_
        elif nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class ObjectType8


class InitCmdType9(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, CompleteAccess=None, Fixed=None, OverwrittenByModule=None, Transition=None, Index=None, SubIndex=None, Data=None, Comment=None):
        self.CompleteAccess = _cast(bool, CompleteAccess)
        self.Fixed = _cast(bool, Fixed)
        self.OverwrittenByModule = _cast(bool, OverwrittenByModule)
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        self.Index = Index
        self.SubIndex = SubIndex
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if InitCmdType9.subclass:
            return InitCmdType9.subclass(*args_, **kwargs_)
        else:
            return InitCmdType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition(self, index, value): self.Transition[index] = value
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_SubIndex(self): return self.SubIndex
    def set_SubIndex(self, SubIndex): self.SubIndex = SubIndex
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_CompleteAccess(self): return self.CompleteAccess
    def set_CompleteAccess(self, CompleteAccess): self.CompleteAccess = CompleteAccess
    def get_Fixed(self): return self.Fixed
    def set_Fixed(self, Fixed): self.Fixed = Fixed
    def get_OverwrittenByModule(self): return self.OverwrittenByModule
    def set_OverwrittenByModule(self, OverwrittenByModule): self.OverwrittenByModule = OverwrittenByModule
    def validate_TransitionType10(self, value):
        # Validate type TransitionType10, a restriction on xs:NMTOKEN.
        pass
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Transition or
            self.Index is not None or
            self.SubIndex is not None or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitCmdType9', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitCmdType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitCmdType9'):
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            outfile.write(' CompleteAccess="%s"' % self.gds_format_boolean(self.CompleteAccess, input_name='CompleteAccess'))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            outfile.write(' Fixed="%s"' % self.gds_format_boolean(self.Fixed, input_name='Fixed'))
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            outfile.write(' OverwrittenByModule="%s"' % self.gds_format_boolean(self.OverwrittenByModule, input_name='OverwrittenByModule'))
    def exportChildren(self, outfile, level, namespace_='', name_='InitCmdType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transition_ in self.Transition:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(Transition_).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.Index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndex>%s</%sIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_, eol_))
        if self.SubIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubIndex>%s</%sSubIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubIndex).encode(ExternalEncoding), input_name='SubIndex'), namespace_, eol_))
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InitCmdType9'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            showIndent(outfile, level)
            outfile.write('CompleteAccess=%s,\n' % (self.CompleteAccess,))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            showIndent(outfile, level)
            outfile.write('Fixed=%s,\n' % (self.Fixed,))
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            showIndent(outfile, level)
            outfile.write('OverwrittenByModule=%s,\n' % (self.OverwrittenByModule,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.SubIndex is not None:
            showIndent(outfile, level)
            outfile.write('SubIndex=%s,\n' % quote_python(self.SubIndex).encode(ExternalEncoding))
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataType11(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CompleteAccess', node)
        if value is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            if value in ('true', '1'):
                self.CompleteAccess = True
            elif value in ('false', '0'):
                self.CompleteAccess = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Fixed', node)
        if value is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            if value in ('true', '1'):
                self.Fixed = True
            elif value in ('false', '0'):
                self.Fixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OverwrittenByModule', node)
        if value is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            if value in ('true', '1'):
                self.OverwrittenByModule = True
            elif value in ('false', '0'):
                self.OverwrittenByModule = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition.append(Transition_)
            self.validate_TransitionType10(self.Transition)    # validate type TransitionType10
        elif nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
            self.validate_HexDecValue(self.Index)    # validate type HexDecValue
        elif nodeName_ == 'SubIndex':
            SubIndex_ = child_.text
            SubIndex_ = self.gds_validate_string(SubIndex_, node, 'SubIndex')
            self.SubIndex = SubIndex_
            self.validate_HexDecValue(self.SubIndex)    # validate type HexDecValue
        elif nodeName_ == 'Data':
            obj_ = DataType11.factory()
            obj_.build(child_)
            self.Data = obj_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class InitCmdType9


class DataType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdaptAutomatically=None, valueOf_=None):
        self.AdaptAutomatically = _cast(bool, AdaptAutomatically)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DataType11.subclass:
            return DataType11.subclass(*args_, **kwargs_)
        else:
            return DataType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdaptAutomatically(self): return self.AdaptAutomatically
    def set_AdaptAutomatically(self, AdaptAutomatically): self.AdaptAutomatically = AdaptAutomatically
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataType11', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataType11')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataType11'):
        if self.AdaptAutomatically is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            outfile.write(' AdaptAutomatically="%s"' % self.gds_format_boolean(self.AdaptAutomatically, input_name='AdaptAutomatically'))
    def exportChildren(self, outfile, level, namespace_='', name_='DataType11', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DataType11'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AdaptAutomatically is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            showIndent(outfile, level)
            outfile.write('AdaptAutomatically=%s,\n' % (self.AdaptAutomatically,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AdaptAutomatically', node)
        if value is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            if value in ('true', '1'):
                self.AdaptAutomatically = True
            elif value in ('false', '0'):
                self.AdaptAutomatically = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataType11


class FoEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if FoEType.subclass:
            return FoEType.subclass(*args_, **kwargs_)
        else:
            return FoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FoEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FoEType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoEType


class SoEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChannelCount=None, DriveFollowsBit3Support=None, InitCmd=None):
        self.ChannelCount = _cast(int, ChannelCount)
        self.DriveFollowsBit3Support = _cast(bool, DriveFollowsBit3Support)
        if InitCmd is None:
            self.InitCmd = []
        else:
            self.InitCmd = InitCmd
    def factory(*args_, **kwargs_):
        if SoEType.subclass:
            return SoEType.subclass(*args_, **kwargs_)
        else:
            return SoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InitCmd(self): return self.InitCmd
    def set_InitCmd(self, InitCmd): self.InitCmd = InitCmd
    def add_InitCmd(self, value): self.InitCmd.append(value)
    def insert_InitCmd(self, index, value): self.InitCmd[index] = value
    def get_ChannelCount(self): return self.ChannelCount
    def set_ChannelCount(self, ChannelCount): self.ChannelCount = ChannelCount
    def get_DriveFollowsBit3Support(self): return self.DriveFollowsBit3Support
    def set_DriveFollowsBit3Support(self, DriveFollowsBit3Support): self.DriveFollowsBit3Support = DriveFollowsBit3Support
    def hasContent_(self):
        if (
            self.InitCmd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SoEType'):
        if self.ChannelCount is not None and 'ChannelCount' not in already_processed:
            already_processed.add('ChannelCount')
            outfile.write(' ChannelCount="%s"' % self.gds_format_integer(self.ChannelCount, input_name='ChannelCount'))
        if self.DriveFollowsBit3Support is not None and 'DriveFollowsBit3Support' not in already_processed:
            already_processed.add('DriveFollowsBit3Support')
            outfile.write(' DriveFollowsBit3Support="%s"' % self.gds_format_boolean(self.DriveFollowsBit3Support, input_name='DriveFollowsBit3Support'))
    def exportChildren(self, outfile, level, namespace_='', name_='SoEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InitCmd_ in self.InitCmd:
            InitCmd_.export(outfile, level, namespace_, name_='InitCmd', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ChannelCount is not None and 'ChannelCount' not in already_processed:
            already_processed.add('ChannelCount')
            showIndent(outfile, level)
            outfile.write('ChannelCount=%d,\n' % (self.ChannelCount,))
        if self.DriveFollowsBit3Support is not None and 'DriveFollowsBit3Support' not in already_processed:
            already_processed.add('DriveFollowsBit3Support')
            showIndent(outfile, level)
            outfile.write('DriveFollowsBit3Support=%s,\n' % (self.DriveFollowsBit3Support,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InitCmd=[\n')
        level += 1
        for InitCmd_ in self.InitCmd:
            showIndent(outfile, level)
            outfile.write('model_.InitCmdType12(\n')
            InitCmd_.exportLiteral(outfile, level, name_='InitCmdType12')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ChannelCount', node)
        if value is not None and 'ChannelCount' not in already_processed:
            already_processed.add('ChannelCount')
            try:
                self.ChannelCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('DriveFollowsBit3Support', node)
        if value is not None and 'DriveFollowsBit3Support' not in already_processed:
            already_processed.add('DriveFollowsBit3Support')
            if value in ('true', '1'):
                self.DriveFollowsBit3Support = True
            elif value in ('false', '0'):
                self.DriveFollowsBit3Support = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InitCmd':
            obj_ = InitCmdType12.factory()
            obj_.build(child_)
            self.InitCmd.append(obj_)
# end class SoEType


class InitCmdType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Chn=0, Transition=None, IDN=None, Data=None, Comment=None):
        self.Chn = _cast(int, Chn)
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        self.IDN = IDN
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if InitCmdType12.subclass:
            return InitCmdType12.subclass(*args_, **kwargs_)
        else:
            return InitCmdType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition(self, index, value): self.Transition[index] = value
    def get_IDN(self): return self.IDN
    def set_IDN(self, IDN): self.IDN = IDN
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Chn(self): return self.Chn
    def set_Chn(self, Chn): self.Chn = Chn
    def validate_TransitionType13(self, value):
        # Validate type TransitionType13, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Transition or
            self.IDN is not None or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitCmdType12', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitCmdType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitCmdType12'):
        if self.Chn is not None and 'Chn' not in already_processed:
            already_processed.add('Chn')
            outfile.write(' Chn="%s"' % self.gds_format_integer(self.Chn, input_name='Chn'))
    def exportChildren(self, outfile, level, namespace_='', name_='InitCmdType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transition_ in self.Transition:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(Transition_).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.IDN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIDN>%s</%sIDN>%s' % (namespace_, self.gds_format_integer(self.IDN, input_name='IDN'), namespace_, eol_))
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InitCmdType12'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Chn is not None and 'Chn' not in already_processed:
            already_processed.add('Chn')
            showIndent(outfile, level)
            outfile.write('Chn=%d,\n' % (self.Chn,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.IDN is not None:
            showIndent(outfile, level)
            outfile.write('IDN=%d,\n' % self.IDN)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Chn', node)
        if value is not None and 'Chn' not in already_processed:
            already_processed.add('Chn')
            try:
                self.Chn = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition.append(Transition_)
            self.validate_TransitionType13(self.Transition)    # validate type TransitionType13
        elif nodeName_ == 'IDN':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'IDN')
            self.IDN = ival_
        elif nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class InitCmdType12


class VoEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if VoEType.subclass:
            return VoEType.subclass(*args_, **kwargs_)
        else:
            return VoEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VoEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VoEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VoEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VoEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VoEType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VoEType


class DcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnknownFRMW=None, ExternalRefClock=None, Unknown64Bit=None, OpMode=None, VendorSpecific=None):
        self.UnknownFRMW = _cast(bool, UnknownFRMW)
        self.ExternalRefClock = _cast(bool, ExternalRefClock)
        self.Unknown64Bit = _cast(bool, Unknown64Bit)
        if OpMode is None:
            self.OpMode = []
        else:
            self.OpMode = OpMode
        self.VendorSpecific = VendorSpecific
    def factory(*args_, **kwargs_):
        if DcType.subclass:
            return DcType.subclass(*args_, **kwargs_)
        else:
            return DcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpMode(self): return self.OpMode
    def set_OpMode(self, OpMode): self.OpMode = OpMode
    def add_OpMode(self, value): self.OpMode.append(value)
    def insert_OpMode(self, index, value): self.OpMode[index] = value
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def get_UnknownFRMW(self): return self.UnknownFRMW
    def set_UnknownFRMW(self, UnknownFRMW): self.UnknownFRMW = UnknownFRMW
    def get_ExternalRefClock(self): return self.ExternalRefClock
    def set_ExternalRefClock(self, ExternalRefClock): self.ExternalRefClock = ExternalRefClock
    def get_Unknown64Bit(self): return self.Unknown64Bit
    def set_Unknown64Bit(self, Unknown64Bit): self.Unknown64Bit = Unknown64Bit
    def hasContent_(self):
        if (
            self.OpMode or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DcType'):
        if self.UnknownFRMW is not None and 'UnknownFRMW' not in already_processed:
            already_processed.add('UnknownFRMW')
            outfile.write(' UnknownFRMW="%s"' % self.gds_format_boolean(self.UnknownFRMW, input_name='UnknownFRMW'))
        if self.ExternalRefClock is not None and 'ExternalRefClock' not in already_processed:
            already_processed.add('ExternalRefClock')
            outfile.write(' ExternalRefClock="%s"' % self.gds_format_boolean(self.ExternalRefClock, input_name='ExternalRefClock'))
        if self.Unknown64Bit is not None and 'Unknown64Bit' not in already_processed:
            already_processed.add('Unknown64Bit')
            outfile.write(' Unknown64Bit="%s"' % self.gds_format_boolean(self.Unknown64Bit, input_name='Unknown64Bit'))
    def exportChildren(self, outfile, level, namespace_='', name_='DcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OpMode_ in self.OpMode:
            OpMode_.export(outfile, level, namespace_, name_='OpMode', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.UnknownFRMW is not None and 'UnknownFRMW' not in already_processed:
            already_processed.add('UnknownFRMW')
            showIndent(outfile, level)
            outfile.write('UnknownFRMW=%s,\n' % (self.UnknownFRMW,))
        if self.ExternalRefClock is not None and 'ExternalRefClock' not in already_processed:
            already_processed.add('ExternalRefClock')
            showIndent(outfile, level)
            outfile.write('ExternalRefClock=%s,\n' % (self.ExternalRefClock,))
        if self.Unknown64Bit is not None and 'Unknown64Bit' not in already_processed:
            already_processed.add('Unknown64Bit')
            showIndent(outfile, level)
            outfile.write('Unknown64Bit=%s,\n' % (self.Unknown64Bit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OpMode=[\n')
        level += 1
        for OpMode_ in self.OpMode:
            showIndent(outfile, level)
            outfile.write('model_.OpModeType(\n')
            OpMode_.exportLiteral(outfile, level, name_='OpModeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UnknownFRMW', node)
        if value is not None and 'UnknownFRMW' not in already_processed:
            already_processed.add('UnknownFRMW')
            if value in ('true', '1'):
                self.UnknownFRMW = True
            elif value in ('false', '0'):
                self.UnknownFRMW = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ExternalRefClock', node)
        if value is not None and 'ExternalRefClock' not in already_processed:
            already_processed.add('ExternalRefClock')
            if value in ('true', '1'):
                self.ExternalRefClock = True
            elif value in ('false', '0'):
                self.ExternalRefClock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Unknown64Bit', node)
        if value is not None and 'Unknown64Bit' not in already_processed:
            already_processed.add('Unknown64Bit')
            if value in ('true', '1'):
                self.Unknown64Bit = True
            elif value in ('false', '0'):
                self.Unknown64Bit = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpMode':
            obj_ = OpModeType.factory()
            obj_.build(child_)
            self.OpMode.append(obj_)
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class DcType


class OpModeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Desc=None, AssignActivate=None, CycleTimeSync0=None, ShiftTimeSync0=None, CycleTimeSync1=None, ShiftTimeSync1=None, Sm=None, VendorSpecific=None):
        self.Name = Name
        self.Desc = Desc
        self.AssignActivate = AssignActivate
        self.CycleTimeSync0 = CycleTimeSync0
        self.ShiftTimeSync0 = ShiftTimeSync0
        self.CycleTimeSync1 = CycleTimeSync1
        self.ShiftTimeSync1 = ShiftTimeSync1
        if Sm is None:
            self.Sm = []
        else:
            self.Sm = Sm
        self.VendorSpecific = VendorSpecific
    def factory(*args_, **kwargs_):
        if OpModeType.subclass:
            return OpModeType.subclass(*args_, **kwargs_)
        else:
            return OpModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Desc(self): return self.Desc
    def set_Desc(self, Desc): self.Desc = Desc
    def get_AssignActivate(self): return self.AssignActivate
    def set_AssignActivate(self, AssignActivate): self.AssignActivate = AssignActivate
    def get_CycleTimeSync0(self): return self.CycleTimeSync0
    def set_CycleTimeSync0(self, CycleTimeSync0): self.CycleTimeSync0 = CycleTimeSync0
    def get_ShiftTimeSync0(self): return self.ShiftTimeSync0
    def set_ShiftTimeSync0(self, ShiftTimeSync0): self.ShiftTimeSync0 = ShiftTimeSync0
    def get_CycleTimeSync1(self): return self.CycleTimeSync1
    def set_CycleTimeSync1(self, CycleTimeSync1): self.CycleTimeSync1 = CycleTimeSync1
    def get_ShiftTimeSync1(self): return self.ShiftTimeSync1
    def set_ShiftTimeSync1(self, ShiftTimeSync1): self.ShiftTimeSync1 = ShiftTimeSync1
    def get_Sm(self): return self.Sm
    def set_Sm(self, Sm): self.Sm = Sm
    def add_Sm(self, value): self.Sm.append(value)
    def insert_Sm(self, index, value): self.Sm[index] = value
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Desc is not None or
            self.AssignActivate is not None or
            self.CycleTimeSync0 is not None or
            self.ShiftTimeSync0 is not None or
            self.CycleTimeSync1 is not None or
            self.ShiftTimeSync1 is not None or
            self.Sm or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OpModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OpModeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OpModeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OpModeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDesc>%s</%sDesc>%s' % (namespace_, self.gds_format_string(quote_xml(self.Desc).encode(ExternalEncoding), input_name='Desc'), namespace_, eol_))
        if self.AssignActivate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssignActivate>%s</%sAssignActivate>%s' % (namespace_, self.gds_format_string(quote_xml(self.AssignActivate).encode(ExternalEncoding), input_name='AssignActivate'), namespace_, eol_))
        if self.CycleTimeSync0 is not None:
            self.CycleTimeSync0.export(outfile, level, namespace_, name_='CycleTimeSync0', pretty_print=pretty_print)
        if self.ShiftTimeSync0 is not None:
            self.ShiftTimeSync0.export(outfile, level, namespace_, name_='ShiftTimeSync0', pretty_print=pretty_print)
        if self.CycleTimeSync1 is not None:
            self.CycleTimeSync1.export(outfile, level, namespace_, name_='CycleTimeSync1', pretty_print=pretty_print)
        if self.ShiftTimeSync1 is not None:
            self.ShiftTimeSync1.export(outfile, level, namespace_, name_='ShiftTimeSync1', pretty_print=pretty_print)
        for Sm_ in self.Sm:
            Sm_.export(outfile, level, namespace_, name_='Sm', pretty_print=pretty_print)
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OpModeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Desc is not None:
            showIndent(outfile, level)
            outfile.write('Desc=%s,\n' % quote_python(self.Desc).encode(ExternalEncoding))
        if self.AssignActivate is not None:
            showIndent(outfile, level)
            outfile.write('AssignActivate=%s,\n' % quote_python(self.AssignActivate).encode(ExternalEncoding))
        if self.CycleTimeSync0 is not None:
            showIndent(outfile, level)
            outfile.write('CycleTimeSync0=model_.CycleTimeSync0Type(\n')
            self.CycleTimeSync0.exportLiteral(outfile, level, name_='CycleTimeSync0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShiftTimeSync0 is not None:
            showIndent(outfile, level)
            outfile.write('ShiftTimeSync0=model_.ShiftTimeSync0Type(\n')
            self.ShiftTimeSync0.exportLiteral(outfile, level, name_='ShiftTimeSync0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CycleTimeSync1 is not None:
            showIndent(outfile, level)
            outfile.write('CycleTimeSync1=model_.CycleTimeSync1Type(\n')
            self.CycleTimeSync1.exportLiteral(outfile, level, name_='CycleTimeSync1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShiftTimeSync1 is not None:
            showIndent(outfile, level)
            outfile.write('ShiftTimeSync1=model_.ShiftTimeSync1Type(\n')
            self.ShiftTimeSync1.exportLiteral(outfile, level, name_='ShiftTimeSync1')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Sm=[\n')
        level += 1
        for Sm_ in self.Sm:
            showIndent(outfile, level)
            outfile.write('model_.SmType14(\n')
            Sm_.exportLiteral(outfile, level, name_='SmType14')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Desc':
            Desc_ = child_.text
            Desc_ = self.gds_validate_string(Desc_, node, 'Desc')
            self.Desc = Desc_
        elif nodeName_ == 'AssignActivate':
            AssignActivate_ = child_.text
            AssignActivate_ = self.gds_validate_string(AssignActivate_, node, 'AssignActivate')
            self.AssignActivate = AssignActivate_
            self.validate_HexDecValue(self.AssignActivate)    # validate type HexDecValue
        elif nodeName_ == 'CycleTimeSync0':
            obj_ = CycleTimeSync0Type.factory()
            obj_.build(child_)
            self.CycleTimeSync0 = obj_
        elif nodeName_ == 'ShiftTimeSync0':
            obj_ = ShiftTimeSync0Type.factory()
            obj_.build(child_)
            self.ShiftTimeSync0 = obj_
        elif nodeName_ == 'CycleTimeSync1':
            obj_ = CycleTimeSync1Type.factory()
            obj_.build(child_)
            self.CycleTimeSync1 = obj_
        elif nodeName_ == 'ShiftTimeSync1':
            obj_ = ShiftTimeSync1Type.factory()
            obj_.build(child_)
            self.ShiftTimeSync1 = obj_
        elif nodeName_ == 'Sm':
            obj_ = SmType14.factory()
            obj_.build(child_)
            self.Sm.append(obj_)
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class OpModeType


class CycleTimeSync0Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Factor=None, valueOf_=None):
        self.Factor = _cast(int, Factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CycleTimeSync0Type.subclass:
            return CycleTimeSync0Type.subclass(*args_, **kwargs_)
        else:
            return CycleTimeSync0Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Factor(self): return self.Factor
    def set_Factor(self, Factor): self.Factor = Factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CycleTimeSync0Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CycleTimeSync0Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CycleTimeSync0Type'):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            outfile.write(' Factor="%s"' % self.gds_format_integer(self.Factor, input_name='Factor'))
    def exportChildren(self, outfile, level, namespace_='', name_='CycleTimeSync0Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CycleTimeSync0Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            showIndent(outfile, level)
            outfile.write('Factor=%d,\n' % (self.Factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Factor', node)
        if value is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            try:
                self.Factor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CycleTimeSync0Type


class ShiftTimeSync0Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InputDelayTime=None, Input=None, OutputDelayTime=None, Factor=None, valueOf_=None):
        self.InputDelayTime = _cast(int, InputDelayTime)
        self.Input = _cast(bool, Input)
        self.OutputDelayTime = _cast(int, OutputDelayTime)
        self.Factor = _cast(int, Factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ShiftTimeSync0Type.subclass:
            return ShiftTimeSync0Type.subclass(*args_, **kwargs_)
        else:
            return ShiftTimeSync0Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InputDelayTime(self): return self.InputDelayTime
    def set_InputDelayTime(self, InputDelayTime): self.InputDelayTime = InputDelayTime
    def get_Input(self): return self.Input
    def set_Input(self, Input): self.Input = Input
    def get_OutputDelayTime(self): return self.OutputDelayTime
    def set_OutputDelayTime(self, OutputDelayTime): self.OutputDelayTime = OutputDelayTime
    def get_Factor(self): return self.Factor
    def set_Factor(self, Factor): self.Factor = Factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShiftTimeSync0Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShiftTimeSync0Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShiftTimeSync0Type'):
        if self.InputDelayTime is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            outfile.write(' InputDelayTime="%s"' % self.gds_format_integer(self.InputDelayTime, input_name='InputDelayTime'))
        if self.Input is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            outfile.write(' Input="%s"' % self.gds_format_boolean(self.Input, input_name='Input'))
        if self.OutputDelayTime is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            outfile.write(' OutputDelayTime="%s"' % self.gds_format_integer(self.OutputDelayTime, input_name='OutputDelayTime'))
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            outfile.write(' Factor="%s"' % self.gds_format_integer(self.Factor, input_name='Factor'))
    def exportChildren(self, outfile, level, namespace_='', name_='ShiftTimeSync0Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ShiftTimeSync0Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.InputDelayTime is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            showIndent(outfile, level)
            outfile.write('InputDelayTime=%d,\n' % (self.InputDelayTime,))
        if self.Input is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            showIndent(outfile, level)
            outfile.write('Input=%s,\n' % (self.Input,))
        if self.OutputDelayTime is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            showIndent(outfile, level)
            outfile.write('OutputDelayTime=%d,\n' % (self.OutputDelayTime,))
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            showIndent(outfile, level)
            outfile.write('Factor=%d,\n' % (self.Factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('InputDelayTime', node)
        if value is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            try:
                self.InputDelayTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Input', node)
        if value is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            if value in ('true', '1'):
                self.Input = True
            elif value in ('false', '0'):
                self.Input = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OutputDelayTime', node)
        if value is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            try:
                self.OutputDelayTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Factor', node)
        if value is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            try:
                self.Factor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ShiftTimeSync0Type


class CycleTimeSync1Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Factor=None, valueOf_=None):
        self.Factor = _cast(int, Factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CycleTimeSync1Type.subclass:
            return CycleTimeSync1Type.subclass(*args_, **kwargs_)
        else:
            return CycleTimeSync1Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Factor(self): return self.Factor
    def set_Factor(self, Factor): self.Factor = Factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CycleTimeSync1Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CycleTimeSync1Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CycleTimeSync1Type'):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            outfile.write(' Factor="%s"' % self.gds_format_integer(self.Factor, input_name='Factor'))
    def exportChildren(self, outfile, level, namespace_='', name_='CycleTimeSync1Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CycleTimeSync1Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            showIndent(outfile, level)
            outfile.write('Factor=%d,\n' % (self.Factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Factor', node)
        if value is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            try:
                self.Factor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CycleTimeSync1Type


class ShiftTimeSync1Type(GeneratedsSuper):
    """for future use"""
    subclass = None
    superclass = None
    def __init__(self, InputDelayTime=None, Input=None, OutputDelayTime=None, Factor=None, valueOf_=None):
        self.InputDelayTime = _cast(int, InputDelayTime)
        self.Input = _cast(bool, Input)
        self.OutputDelayTime = _cast(int, OutputDelayTime)
        self.Factor = _cast(int, Factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ShiftTimeSync1Type.subclass:
            return ShiftTimeSync1Type.subclass(*args_, **kwargs_)
        else:
            return ShiftTimeSync1Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InputDelayTime(self): return self.InputDelayTime
    def set_InputDelayTime(self, InputDelayTime): self.InputDelayTime = InputDelayTime
    def get_Input(self): return self.Input
    def set_Input(self, Input): self.Input = Input
    def get_OutputDelayTime(self): return self.OutputDelayTime
    def set_OutputDelayTime(self, OutputDelayTime): self.OutputDelayTime = OutputDelayTime
    def get_Factor(self): return self.Factor
    def set_Factor(self, Factor): self.Factor = Factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShiftTimeSync1Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShiftTimeSync1Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShiftTimeSync1Type'):
        if self.InputDelayTime is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            outfile.write(' InputDelayTime="%s"' % self.gds_format_integer(self.InputDelayTime, input_name='InputDelayTime'))
        if self.Input is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            outfile.write(' Input="%s"' % self.gds_format_boolean(self.Input, input_name='Input'))
        if self.OutputDelayTime is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            outfile.write(' OutputDelayTime="%s"' % self.gds_format_integer(self.OutputDelayTime, input_name='OutputDelayTime'))
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            outfile.write(' Factor="%s"' % self.gds_format_integer(self.Factor, input_name='Factor'))
    def exportChildren(self, outfile, level, namespace_='', name_='ShiftTimeSync1Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ShiftTimeSync1Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.InputDelayTime is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            showIndent(outfile, level)
            outfile.write('InputDelayTime=%d,\n' % (self.InputDelayTime,))
        if self.Input is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            showIndent(outfile, level)
            outfile.write('Input=%s,\n' % (self.Input,))
        if self.OutputDelayTime is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            showIndent(outfile, level)
            outfile.write('OutputDelayTime=%d,\n' % (self.OutputDelayTime,))
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            showIndent(outfile, level)
            outfile.write('Factor=%d,\n' % (self.Factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('InputDelayTime', node)
        if value is not None and 'InputDelayTime' not in already_processed:
            already_processed.add('InputDelayTime')
            try:
                self.InputDelayTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Input', node)
        if value is not None and 'Input' not in already_processed:
            already_processed.add('Input')
            if value in ('true', '1'):
                self.Input = True
            elif value in ('false', '0'):
                self.Input = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('OutputDelayTime', node)
        if value is not None and 'OutputDelayTime' not in already_processed:
            already_processed.add('OutputDelayTime')
            try:
                self.OutputDelayTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Factor', node)
        if value is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            try:
                self.Factor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ShiftTimeSync1Type


class SmType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, No=None, SyncType=None, CycleTime=None, ShiftTime=None, Pdo=None):
        self.No = _cast(int, No)
        self.SyncType = SyncType
        self.CycleTime = CycleTime
        self.ShiftTime = ShiftTime
        if Pdo is None:
            self.Pdo = []
        else:
            self.Pdo = Pdo
    def factory(*args_, **kwargs_):
        if SmType14.subclass:
            return SmType14.subclass(*args_, **kwargs_)
        else:
            return SmType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SyncType(self): return self.SyncType
    def set_SyncType(self, SyncType): self.SyncType = SyncType
    def get_CycleTime(self): return self.CycleTime
    def set_CycleTime(self, CycleTime): self.CycleTime = CycleTime
    def get_ShiftTime(self): return self.ShiftTime
    def set_ShiftTime(self, ShiftTime): self.ShiftTime = ShiftTime
    def get_Pdo(self): return self.Pdo
    def set_Pdo(self, Pdo): self.Pdo = Pdo
    def add_Pdo(self, value): self.Pdo.append(value)
    def insert_Pdo(self, index, value): self.Pdo[index] = value
    def get_No(self): return self.No
    def set_No(self, No): self.No = No
    def hasContent_(self):
        if (
            self.SyncType is not None or
            self.CycleTime is not None or
            self.ShiftTime is not None or
            self.Pdo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SmType14', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SmType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SmType14'):
        if self.No is not None and 'No' not in already_processed:
            already_processed.add('No')
            outfile.write(' No="%s"' % self.gds_format_integer(self.No, input_name='No'))
    def exportChildren(self, outfile, level, namespace_='', name_='SmType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyncType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyncType>%s</%sSyncType>%s' % (namespace_, self.gds_format_integer(self.SyncType, input_name='SyncType'), namespace_, eol_))
        if self.CycleTime is not None:
            self.CycleTime.export(outfile, level, namespace_, name_='CycleTime', pretty_print=pretty_print)
        if self.ShiftTime is not None:
            self.ShiftTime.export(outfile, level, namespace_, name_='ShiftTime', pretty_print=pretty_print)
        for Pdo_ in self.Pdo:
            Pdo_.export(outfile, level, namespace_, name_='Pdo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SmType14'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.No is not None and 'No' not in already_processed:
            already_processed.add('No')
            showIndent(outfile, level)
            outfile.write('No=%d,\n' % (self.No,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SyncType is not None:
            showIndent(outfile, level)
            outfile.write('SyncType=%d,\n' % self.SyncType)
        if self.CycleTime is not None:
            showIndent(outfile, level)
            outfile.write('CycleTime=model_.CycleTimeType(\n')
            self.CycleTime.exportLiteral(outfile, level, name_='CycleTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ShiftTime is not None:
            showIndent(outfile, level)
            outfile.write('ShiftTime=model_.ShiftTimeType(\n')
            self.ShiftTime.exportLiteral(outfile, level, name_='ShiftTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Pdo=[\n')
        level += 1
        for Pdo_ in self.Pdo:
            showIndent(outfile, level)
            outfile.write('model_.PdoType15(\n')
            Pdo_.exportLiteral(outfile, level, name_='PdoType15')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('No', node)
        if value is not None and 'No' not in already_processed:
            already_processed.add('No')
            try:
                self.No = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SyncType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SyncType')
            self.SyncType = ival_
        elif nodeName_ == 'CycleTime':
            obj_ = CycleTimeType.factory()
            obj_.build(child_)
            self.CycleTime = obj_
        elif nodeName_ == 'ShiftTime':
            obj_ = ShiftTimeType.factory()
            obj_.build(child_)
            self.ShiftTime = obj_
        elif nodeName_ == 'Pdo':
            obj_ = PdoType15.factory()
            obj_.build(child_)
            self.Pdo.append(obj_)
# end class SmType14


class CycleTimeType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, Factor=None, valueOf_=None):
        self.Factor = _cast(int, Factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CycleTimeType.subclass:
            return CycleTimeType.subclass(*args_, **kwargs_)
        else:
            return CycleTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Factor(self): return self.Factor
    def set_Factor(self, Factor): self.Factor = Factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CycleTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CycleTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CycleTimeType'):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            outfile.write(' Factor="%s"' % self.gds_format_integer(self.Factor, input_name='Factor'))
    def exportChildren(self, outfile, level, namespace_='', name_='CycleTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CycleTimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Factor is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            showIndent(outfile, level)
            outfile.write('Factor=%d,\n' % (self.Factor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Factor', node)
        if value is not None and 'Factor' not in already_processed:
            already_processed.add('Factor')
            try:
                self.Factor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CycleTimeType


class ShiftTimeType(GeneratedsSuper):
    """obsoleteobsolete"""
    subclass = None
    superclass = None
    def __init__(self, MinBeforeFrame=None, MinAfterSync=None, valueOf_=None):
        self.MinBeforeFrame = _cast(int, MinBeforeFrame)
        self.MinAfterSync = _cast(int, MinAfterSync)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ShiftTimeType.subclass:
            return ShiftTimeType.subclass(*args_, **kwargs_)
        else:
            return ShiftTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinBeforeFrame(self): return self.MinBeforeFrame
    def set_MinBeforeFrame(self, MinBeforeFrame): self.MinBeforeFrame = MinBeforeFrame
    def get_MinAfterSync(self): return self.MinAfterSync
    def set_MinAfterSync(self, MinAfterSync): self.MinAfterSync = MinAfterSync
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShiftTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShiftTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShiftTimeType'):
        if self.MinBeforeFrame is not None and 'MinBeforeFrame' not in already_processed:
            already_processed.add('MinBeforeFrame')
            outfile.write(' MinBeforeFrame="%s"' % self.gds_format_integer(self.MinBeforeFrame, input_name='MinBeforeFrame'))
        if self.MinAfterSync is not None and 'MinAfterSync' not in already_processed:
            already_processed.add('MinAfterSync')
            outfile.write(' MinAfterSync="%s"' % self.gds_format_integer(self.MinAfterSync, input_name='MinAfterSync'))
    def exportChildren(self, outfile, level, namespace_='', name_='ShiftTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ShiftTimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MinBeforeFrame is not None and 'MinBeforeFrame' not in already_processed:
            already_processed.add('MinBeforeFrame')
            showIndent(outfile, level)
            outfile.write('MinBeforeFrame=%d,\n' % (self.MinBeforeFrame,))
        if self.MinAfterSync is not None and 'MinAfterSync' not in already_processed:
            already_processed.add('MinAfterSync')
            showIndent(outfile, level)
            outfile.write('MinAfterSync=%d,\n' % (self.MinAfterSync,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MinBeforeFrame', node)
        if value is not None and 'MinBeforeFrame' not in already_processed:
            already_processed.add('MinBeforeFrame')
            try:
                self.MinBeforeFrame = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MinAfterSync', node)
        if value is not None and 'MinAfterSync' not in already_processed:
            already_processed.add('MinAfterSync')
            try:
                self.MinAfterSync = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ShiftTimeType


class PdoType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OSFac=None, valueOf_=None):
        self.OSFac = _cast(int, OSFac)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PdoType15.subclass:
            return PdoType15.subclass(*args_, **kwargs_)
        else:
            return PdoType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OSFac(self): return self.OSFac
    def set_OSFac(self, OSFac): self.OSFac = OSFac
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PdoType15', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PdoType15')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PdoType15'):
        if self.OSFac is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            outfile.write(' OSFac="%s"' % self.gds_format_integer(self.OSFac, input_name='OSFac'))
    def exportChildren(self, outfile, level, namespace_='', name_='PdoType15', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PdoType15'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.OSFac is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            showIndent(outfile, level)
            outfile.write('OSFac=%d,\n' % (self.OSFac,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OSFac', node)
        if value is not None and 'OSFac' not in already_processed:
            already_processed.add('OSFac')
            try:
                self.OSFac = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PdoType15


class SlotsType(GeneratedsSuper):
    """obsolete"""
    subclass = None
    superclass = None
    def __init__(self, SlotPdoIncrement=None, IdentifyModuleBy=None, MaxSlotGroupCount=None, SlotGroupIndexIncrement=None, SlotIndexIncrement=None, MaxSlotCount=None, DownloadModuleAddressList=None, SlotGroupPdoIncrement=None, DownloadModuleIdentList=None, Slot=None, ModulePdoGroup=None, SlotSelections=None):
        self.SlotPdoIncrement = _cast(None, SlotPdoIncrement)
        self.IdentifyModuleBy = _cast(None, IdentifyModuleBy)
        self.MaxSlotGroupCount = _cast(None, MaxSlotGroupCount)
        self.SlotGroupIndexIncrement = _cast(None, SlotGroupIndexIncrement)
        self.SlotIndexIncrement = _cast(None, SlotIndexIncrement)
        self.MaxSlotCount = _cast(None, MaxSlotCount)
        self.DownloadModuleAddressList = _cast(bool, DownloadModuleAddressList)
        self.SlotGroupPdoIncrement = _cast(None, SlotGroupPdoIncrement)
        self.DownloadModuleIdentList = _cast(bool, DownloadModuleIdentList)
        if Slot is None:
            self.Slot = []
        else:
            self.Slot = Slot
        if ModulePdoGroup is None:
            self.ModulePdoGroup = []
        else:
            self.ModulePdoGroup = ModulePdoGroup
        if SlotSelections is None:
            self.SlotSelections = []
        else:
            self.SlotSelections = SlotSelections
    def factory(*args_, **kwargs_):
        if SlotsType.subclass:
            return SlotsType.subclass(*args_, **kwargs_)
        else:
            return SlotsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Slot(self): return self.Slot
    def set_Slot(self, Slot): self.Slot = Slot
    def add_Slot(self, value): self.Slot.append(value)
    def insert_Slot(self, index, value): self.Slot[index] = value
    def get_ModulePdoGroup(self): return self.ModulePdoGroup
    def set_ModulePdoGroup(self, ModulePdoGroup): self.ModulePdoGroup = ModulePdoGroup
    def add_ModulePdoGroup(self, value): self.ModulePdoGroup.append(value)
    def insert_ModulePdoGroup(self, index, value): self.ModulePdoGroup[index] = value
    def get_SlotSelections(self): return self.SlotSelections
    def set_SlotSelections(self, SlotSelections): self.SlotSelections = SlotSelections
    def add_SlotSelections(self, value): self.SlotSelections.append(value)
    def insert_SlotSelections(self, index, value): self.SlotSelections[index] = value
    def get_SlotPdoIncrement(self): return self.SlotPdoIncrement
    def set_SlotPdoIncrement(self, SlotPdoIncrement): self.SlotPdoIncrement = SlotPdoIncrement
    def get_IdentifyModuleBy(self): return self.IdentifyModuleBy
    def set_IdentifyModuleBy(self, IdentifyModuleBy): self.IdentifyModuleBy = IdentifyModuleBy
    def get_MaxSlotGroupCount(self): return self.MaxSlotGroupCount
    def set_MaxSlotGroupCount(self, MaxSlotGroupCount): self.MaxSlotGroupCount = MaxSlotGroupCount
    def get_SlotGroupIndexIncrement(self): return self.SlotGroupIndexIncrement
    def set_SlotGroupIndexIncrement(self, SlotGroupIndexIncrement): self.SlotGroupIndexIncrement = SlotGroupIndexIncrement
    def get_SlotIndexIncrement(self): return self.SlotIndexIncrement
    def set_SlotIndexIncrement(self, SlotIndexIncrement): self.SlotIndexIncrement = SlotIndexIncrement
    def get_MaxSlotCount(self): return self.MaxSlotCount
    def set_MaxSlotCount(self, MaxSlotCount): self.MaxSlotCount = MaxSlotCount
    def get_DownloadModuleAddressList(self): return self.DownloadModuleAddressList
    def set_DownloadModuleAddressList(self, DownloadModuleAddressList): self.DownloadModuleAddressList = DownloadModuleAddressList
    def get_SlotGroupPdoIncrement(self): return self.SlotGroupPdoIncrement
    def set_SlotGroupPdoIncrement(self, SlotGroupPdoIncrement): self.SlotGroupPdoIncrement = SlotGroupPdoIncrement
    def get_DownloadModuleIdentList(self): return self.DownloadModuleIdentList
    def set_DownloadModuleIdentList(self, DownloadModuleIdentList): self.DownloadModuleIdentList = DownloadModuleIdentList
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Slot or
            self.ModulePdoGroup or
            self.SlotSelections
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SlotsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlotsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SlotsType'):
        if self.SlotPdoIncrement is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            outfile.write(' SlotPdoIncrement=%s' % (quote_attrib(self.SlotPdoIncrement), ))
        if self.IdentifyModuleBy is not None and 'IdentifyModuleBy' not in already_processed:
            already_processed.add('IdentifyModuleBy')
            outfile.write(' IdentifyModuleBy=%s' % (self.gds_format_string(quote_attrib(self.IdentifyModuleBy).encode(ExternalEncoding), input_name='IdentifyModuleBy'), ))
        if self.MaxSlotGroupCount is not None and 'MaxSlotGroupCount' not in already_processed:
            already_processed.add('MaxSlotGroupCount')
            outfile.write(' MaxSlotGroupCount=%s' % (quote_attrib(self.MaxSlotGroupCount), ))
        if self.SlotGroupIndexIncrement is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            outfile.write(' SlotGroupIndexIncrement=%s' % (quote_attrib(self.SlotGroupIndexIncrement), ))
        if self.SlotIndexIncrement is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            outfile.write(' SlotIndexIncrement=%s' % (quote_attrib(self.SlotIndexIncrement), ))
        if self.MaxSlotCount is not None and 'MaxSlotCount' not in already_processed:
            already_processed.add('MaxSlotCount')
            outfile.write(' MaxSlotCount=%s' % (quote_attrib(self.MaxSlotCount), ))
        if self.DownloadModuleAddressList is not None and 'DownloadModuleAddressList' not in already_processed:
            already_processed.add('DownloadModuleAddressList')
            outfile.write(' DownloadModuleAddressList="%s"' % self.gds_format_boolean(self.DownloadModuleAddressList, input_name='DownloadModuleAddressList'))
        if self.SlotGroupPdoIncrement is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            outfile.write(' SlotGroupPdoIncrement=%s' % (quote_attrib(self.SlotGroupPdoIncrement), ))
        if self.DownloadModuleIdentList is not None and 'DownloadModuleIdentList' not in already_processed:
            already_processed.add('DownloadModuleIdentList')
            outfile.write(' DownloadModuleIdentList="%s"' % self.gds_format_boolean(self.DownloadModuleIdentList, input_name='DownloadModuleIdentList'))
    def exportChildren(self, outfile, level, namespace_='', name_='SlotsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Slot_ in self.Slot:
            Slot_.export(outfile, level, namespace_, name_='Slot', pretty_print=pretty_print)
        for ModulePdoGroup_ in self.ModulePdoGroup:
            ModulePdoGroup_.export(outfile, level, namespace_, name_='ModulePdoGroup', pretty_print=pretty_print)
        for SlotSelections_ in self.SlotSelections:
            SlotSelections_.export(outfile, level, namespace_, name_='SlotSelections', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SlotsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SlotPdoIncrement is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            showIndent(outfile, level)
            outfile.write('SlotPdoIncrement="%s",\n' % (self.SlotPdoIncrement,))
        if self.IdentifyModuleBy is not None and 'IdentifyModuleBy' not in already_processed:
            already_processed.add('IdentifyModuleBy')
            showIndent(outfile, level)
            outfile.write('IdentifyModuleBy="%s",\n' % (self.IdentifyModuleBy,))
        if self.MaxSlotGroupCount is not None and 'MaxSlotGroupCount' not in already_processed:
            already_processed.add('MaxSlotGroupCount')
            showIndent(outfile, level)
            outfile.write('MaxSlotGroupCount="%s",\n' % (self.MaxSlotGroupCount,))
        if self.SlotGroupIndexIncrement is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            showIndent(outfile, level)
            outfile.write('SlotGroupIndexIncrement="%s",\n' % (self.SlotGroupIndexIncrement,))
        if self.SlotIndexIncrement is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            showIndent(outfile, level)
            outfile.write('SlotIndexIncrement="%s",\n' % (self.SlotIndexIncrement,))
        if self.MaxSlotCount is not None and 'MaxSlotCount' not in already_processed:
            already_processed.add('MaxSlotCount')
            showIndent(outfile, level)
            outfile.write('MaxSlotCount="%s",\n' % (self.MaxSlotCount,))
        if self.DownloadModuleAddressList is not None and 'DownloadModuleAddressList' not in already_processed:
            already_processed.add('DownloadModuleAddressList')
            showIndent(outfile, level)
            outfile.write('DownloadModuleAddressList=%s,\n' % (self.DownloadModuleAddressList,))
        if self.SlotGroupPdoIncrement is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            showIndent(outfile, level)
            outfile.write('SlotGroupPdoIncrement="%s",\n' % (self.SlotGroupPdoIncrement,))
        if self.DownloadModuleIdentList is not None and 'DownloadModuleIdentList' not in already_processed:
            already_processed.add('DownloadModuleIdentList')
            showIndent(outfile, level)
            outfile.write('DownloadModuleIdentList=%s,\n' % (self.DownloadModuleIdentList,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Slot=[\n')
        level += 1
        for Slot_ in self.Slot:
            showIndent(outfile, level)
            outfile.write('model_.SlotType(\n')
            Slot_.exportLiteral(outfile, level, name_='SlotType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ModulePdoGroup=[\n')
        level += 1
        for ModulePdoGroup_ in self.ModulePdoGroup:
            showIndent(outfile, level)
            outfile.write('model_.ModulePdoGroupType(\n')
            ModulePdoGroup_.exportLiteral(outfile, level, name_='ModulePdoGroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SlotSelections=[\n')
        level += 1
        for SlotSelections_ in self.SlotSelections:
            showIndent(outfile, level)
            outfile.write('model_.SlotSelectionsType(\n')
            SlotSelections_.exportLiteral(outfile, level, name_='SlotSelectionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SlotPdoIncrement', node)
        if value is not None and 'SlotPdoIncrement' not in already_processed:
            already_processed.add('SlotPdoIncrement')
            self.SlotPdoIncrement = value
            self.validate_HexDecValue(self.SlotPdoIncrement)    # validate type HexDecValue
        value = find_attr_value_('IdentifyModuleBy', node)
        if value is not None and 'IdentifyModuleBy' not in already_processed:
            already_processed.add('IdentifyModuleBy')
            self.IdentifyModuleBy = value
        value = find_attr_value_('MaxSlotGroupCount', node)
        if value is not None and 'MaxSlotGroupCount' not in already_processed:
            already_processed.add('MaxSlotGroupCount')
            self.MaxSlotGroupCount = value
            self.validate_HexDecValue(self.MaxSlotGroupCount)    # validate type HexDecValue
        value = find_attr_value_('SlotGroupIndexIncrement', node)
        if value is not None and 'SlotGroupIndexIncrement' not in already_processed:
            already_processed.add('SlotGroupIndexIncrement')
            self.SlotGroupIndexIncrement = value
            self.validate_HexDecValue(self.SlotGroupIndexIncrement)    # validate type HexDecValue
        value = find_attr_value_('SlotIndexIncrement', node)
        if value is not None and 'SlotIndexIncrement' not in already_processed:
            already_processed.add('SlotIndexIncrement')
            self.SlotIndexIncrement = value
            self.validate_HexDecValue(self.SlotIndexIncrement)    # validate type HexDecValue
        value = find_attr_value_('MaxSlotCount', node)
        if value is not None and 'MaxSlotCount' not in already_processed:
            already_processed.add('MaxSlotCount')
            self.MaxSlotCount = value
            self.validate_HexDecValue(self.MaxSlotCount)    # validate type HexDecValue
        value = find_attr_value_('DownloadModuleAddressList', node)
        if value is not None and 'DownloadModuleAddressList' not in already_processed:
            already_processed.add('DownloadModuleAddressList')
            if value in ('true', '1'):
                self.DownloadModuleAddressList = True
            elif value in ('false', '0'):
                self.DownloadModuleAddressList = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SlotGroupPdoIncrement', node)
        if value is not None and 'SlotGroupPdoIncrement' not in already_processed:
            already_processed.add('SlotGroupPdoIncrement')
            self.SlotGroupPdoIncrement = value
            self.validate_HexDecValue(self.SlotGroupPdoIncrement)    # validate type HexDecValue
        value = find_attr_value_('DownloadModuleIdentList', node)
        if value is not None and 'DownloadModuleIdentList' not in already_processed:
            already_processed.add('DownloadModuleIdentList')
            if value in ('true', '1'):
                self.DownloadModuleIdentList = True
            elif value in ('false', '0'):
                self.DownloadModuleIdentList = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Slot':
            obj_ = SlotType.factory()
            obj_.build(child_)
            self.Slot.append(obj_)
        elif nodeName_ == 'ModulePdoGroup':
            obj_ = ModulePdoGroupType.factory()
            obj_.build(child_)
            self.ModulePdoGroup.append(obj_)
        elif nodeName_ == 'SlotSelections':
            obj_ = SlotSelectionsType.factory()
            obj_.build(child_)
            self.SlotSelections.append(obj_)
# end class SlotsType


class ModulePdoGroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TxPdo=None, RxPdo=None, Alignment=None, valueOf_=None):
        self.TxPdo = _cast(None, TxPdo)
        self.RxPdo = _cast(None, RxPdo)
        self.Alignment = _cast(int, Alignment)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ModulePdoGroupType.subclass:
            return ModulePdoGroupType.subclass(*args_, **kwargs_)
        else:
            return ModulePdoGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TxPdo(self): return self.TxPdo
    def set_TxPdo(self, TxPdo): self.TxPdo = TxPdo
    def get_RxPdo(self): return self.RxPdo
    def set_RxPdo(self, RxPdo): self.RxPdo = RxPdo
    def get_Alignment(self): return self.Alignment
    def set_Alignment(self, Alignment): self.Alignment = Alignment
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModulePdoGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModulePdoGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModulePdoGroupType'):
        if self.TxPdo is not None and 'TxPdo' not in already_processed:
            already_processed.add('TxPdo')
            outfile.write(' TxPdo=%s' % (quote_attrib(self.TxPdo), ))
        if self.RxPdo is not None and 'RxPdo' not in already_processed:
            already_processed.add('RxPdo')
            outfile.write(' RxPdo=%s' % (quote_attrib(self.RxPdo), ))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            outfile.write(' Alignment="%s"' % self.gds_format_integer(self.Alignment, input_name='Alignment'))
    def exportChildren(self, outfile, level, namespace_='', name_='ModulePdoGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ModulePdoGroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TxPdo is not None and 'TxPdo' not in already_processed:
            already_processed.add('TxPdo')
            showIndent(outfile, level)
            outfile.write('TxPdo="%s",\n' % (self.TxPdo,))
        if self.RxPdo is not None and 'RxPdo' not in already_processed:
            already_processed.add('RxPdo')
            showIndent(outfile, level)
            outfile.write('RxPdo="%s",\n' % (self.RxPdo,))
        if self.Alignment is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            showIndent(outfile, level)
            outfile.write('Alignment=%d,\n' % (self.Alignment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TxPdo', node)
        if value is not None and 'TxPdo' not in already_processed:
            already_processed.add('TxPdo')
            self.TxPdo = value
            self.validate_HexDecValue(self.TxPdo)    # validate type HexDecValue
        value = find_attr_value_('RxPdo', node)
        if value is not None and 'RxPdo' not in already_processed:
            already_processed.add('RxPdo')
            self.RxPdo = value
            self.validate_HexDecValue(self.RxPdo)    # validate type HexDecValue
        value = find_attr_value_('Alignment', node)
        if value is not None and 'Alignment' not in already_processed:
            already_processed.add('Alignment')
            try:
                self.Alignment = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModulePdoGroupType


class SlotSelectionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ModuleIdent=None):
        self.Name = Name
        if ModuleIdent is None:
            self.ModuleIdent = []
        else:
            self.ModuleIdent = ModuleIdent
    def factory(*args_, **kwargs_):
        if SlotSelectionsType.subclass:
            return SlotSelectionsType.subclass(*args_, **kwargs_)
        else:
            return SlotSelectionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ModuleIdent(self): return self.ModuleIdent
    def set_ModuleIdent(self, ModuleIdent): self.ModuleIdent = ModuleIdent
    def add_ModuleIdent(self, value): self.ModuleIdent.append(value)
    def insert_ModuleIdent(self, index, value): self.ModuleIdent[index] = value
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.ModuleIdent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SlotSelectionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlotSelectionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SlotSelectionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SlotSelectionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for ModuleIdent_ in self.ModuleIdent:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModuleIdent>%s</%sModuleIdent>%s' % (namespace_, self.gds_format_string(quote_xml(ModuleIdent_).encode(ExternalEncoding), input_name='ModuleIdent'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SlotSelectionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.NameType(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ModuleIdent=[\n')
        level += 1
        for ModuleIdent_ in self.ModuleIdent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ModuleIdent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name = obj_
        elif nodeName_ == 'ModuleIdent':
            ModuleIdent_ = child_.text
            ModuleIdent_ = self.gds_validate_string(ModuleIdent_, node, 'ModuleIdent')
            self.ModuleIdent.append(ModuleIdent_)
            self.validate_HexDecValue(self.ModuleIdent)    # validate type HexDecValue
# end class SlotSelectionsType


class ESCType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Reg0108=None, Reg0400=None, Reg0410=None, Reg0420=None, VendorSpecific=None):
        self.Reg0108 = Reg0108
        self.Reg0400 = Reg0400
        self.Reg0410 = Reg0410
        self.Reg0420 = Reg0420
        self.VendorSpecific = VendorSpecific
    def factory(*args_, **kwargs_):
        if ESCType.subclass:
            return ESCType.subclass(*args_, **kwargs_)
        else:
            return ESCType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reg0108(self): return self.Reg0108
    def set_Reg0108(self, Reg0108): self.Reg0108 = Reg0108
    def get_Reg0400(self): return self.Reg0400
    def set_Reg0400(self, Reg0400): self.Reg0400 = Reg0400
    def get_Reg0410(self): return self.Reg0410
    def set_Reg0410(self, Reg0410): self.Reg0410 = Reg0410
    def get_Reg0420(self): return self.Reg0420
    def set_Reg0420(self, Reg0420): self.Reg0420 = Reg0420
    def get_VendorSpecific(self): return self.VendorSpecific
    def set_VendorSpecific(self, VendorSpecific): self.VendorSpecific = VendorSpecific
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Reg0108 is not None or
            self.Reg0400 is not None or
            self.Reg0410 is not None or
            self.Reg0420 is not None or
            self.VendorSpecific is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ESCType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ESCType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ESCType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ESCType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reg0108 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReg0108>%s</%sReg0108>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reg0108).encode(ExternalEncoding), input_name='Reg0108'), namespace_, eol_))
        if self.Reg0400 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReg0400>%s</%sReg0400>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reg0400).encode(ExternalEncoding), input_name='Reg0400'), namespace_, eol_))
        if self.Reg0410 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReg0410>%s</%sReg0410>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reg0410).encode(ExternalEncoding), input_name='Reg0410'), namespace_, eol_))
        if self.Reg0420 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReg0420>%s</%sReg0420>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reg0420).encode(ExternalEncoding), input_name='Reg0420'), namespace_, eol_))
        if self.VendorSpecific is not None:
            self.VendorSpecific.export(outfile, level, namespace_, name_='VendorSpecific', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ESCType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Reg0108 is not None:
            showIndent(outfile, level)
            outfile.write('Reg0108=%s,\n' % quote_python(self.Reg0108).encode(ExternalEncoding))
        if self.Reg0400 is not None:
            showIndent(outfile, level)
            outfile.write('Reg0400=%s,\n' % quote_python(self.Reg0400).encode(ExternalEncoding))
        if self.Reg0410 is not None:
            showIndent(outfile, level)
            outfile.write('Reg0410=%s,\n' % quote_python(self.Reg0410).encode(ExternalEncoding))
        if self.Reg0420 is not None:
            showIndent(outfile, level)
            outfile.write('Reg0420=%s,\n' % quote_python(self.Reg0420).encode(ExternalEncoding))
        if self.VendorSpecific is not None:
            showIndent(outfile, level)
            outfile.write('VendorSpecific=model_.VendorSpecificType(\n')
            self.VendorSpecific.exportLiteral(outfile, level, name_='VendorSpecific')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reg0108':
            Reg0108_ = child_.text
            Reg0108_ = self.gds_validate_string(Reg0108_, node, 'Reg0108')
            self.Reg0108 = Reg0108_
            self.validate_HexDecValue(self.Reg0108)    # validate type HexDecValue
        elif nodeName_ == 'Reg0400':
            Reg0400_ = child_.text
            Reg0400_ = self.gds_validate_string(Reg0400_, node, 'Reg0400')
            self.Reg0400 = Reg0400_
            self.validate_HexDecValue(self.Reg0400)    # validate type HexDecValue
        elif nodeName_ == 'Reg0410':
            Reg0410_ = child_.text
            Reg0410_ = self.gds_validate_string(Reg0410_, node, 'Reg0410')
            self.Reg0410 = Reg0410_
            self.validate_HexDecValue(self.Reg0410)    # validate type HexDecValue
        elif nodeName_ == 'Reg0420':
            Reg0420_ = child_.text
            Reg0420_ = self.gds_validate_string(Reg0420_, node, 'Reg0420')
            self.Reg0420 = Reg0420_
            self.validate_HexDecValue(self.Reg0420)    # validate type HexDecValue
        elif nodeName_ == 'VendorSpecific':
            obj_ = VendorSpecificType.factory()
            obj_.build(child_)
            self.VendorSpecific = obj_
# end class ESCType


class EepromType16(EepromType):
    subclass = None
    superclass = EepromType
    def __init__(self, Data=None, ByteSize=None, ConfigData=None, BootStrap=None, Category=None, VendorSpecific=None, AssignToPdi=None):
        super(EepromType16, self).__init__(Data, ByteSize, ConfigData, BootStrap, Category, VendorSpecific, )
        self.AssignToPdi = _cast(bool, AssignToPdi)
        pass
    def factory(*args_, **kwargs_):
        if EepromType16.subclass:
            return EepromType16.subclass(*args_, **kwargs_)
        else:
            return EepromType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssignToPdi(self): return self.AssignToPdi
    def set_AssignToPdi(self, AssignToPdi): self.AssignToPdi = AssignToPdi
    def hasContent_(self):
        if (
            super(EepromType16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EepromType16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EepromType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EepromType16'):
        super(EepromType16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EepromType16')
        if self.AssignToPdi is not None and 'AssignToPdi' not in already_processed:
            already_processed.add('AssignToPdi')
            outfile.write(' AssignToPdi="%s"' % self.gds_format_boolean(self.AssignToPdi, input_name='AssignToPdi'))
    def exportChildren(self, outfile, level, namespace_='', name_='EepromType16', fromsubclass_=False, pretty_print=True):
        super(EepromType16, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EepromType16'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AssignToPdi is not None and 'AssignToPdi' not in already_processed:
            already_processed.add('AssignToPdi')
            showIndent(outfile, level)
            outfile.write('AssignToPdi=%s,\n' % (self.AssignToPdi,))
        super(EepromType16, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EepromType16, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AssignToPdi', node)
        if value is not None and 'AssignToPdi' not in already_processed:
            already_processed.add('AssignToPdi')
            if value in ('true', '1'):
                self.AssignToPdi = True
            elif value in ('false', '0'):
                self.AssignToPdi = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(EepromType16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EepromType16, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EepromType16


class CategoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PreserveOnlineData=None, CatNo=None, Data=None, DataString=None, DataUINT=None, DataUDINT=None):
        self.PreserveOnlineData = _cast(bool, PreserveOnlineData)
        self.CatNo = CatNo
        self.Data = Data
        self.DataString = DataString
        self.DataUINT = DataUINT
        self.DataUDINT = DataUDINT
    def factory(*args_, **kwargs_):
        if CategoryType.subclass:
            return CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CatNo(self): return self.CatNo
    def set_CatNo(self, CatNo): self.CatNo = CatNo
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_DataString(self): return self.DataString
    def set_DataString(self, DataString): self.DataString = DataString
    def get_DataUINT(self): return self.DataUINT
    def set_DataUINT(self, DataUINT): self.DataUINT = DataUINT
    def get_DataUDINT(self): return self.DataUDINT
    def set_DataUDINT(self, DataUDINT): self.DataUDINT = DataUDINT
    def get_PreserveOnlineData(self): return self.PreserveOnlineData
    def set_PreserveOnlineData(self, PreserveOnlineData): self.PreserveOnlineData = PreserveOnlineData
    def hasContent_(self):
        if (
            self.CatNo is not None or
            self.Data is not None or
            self.DataString is not None or
            self.DataUINT is not None or
            self.DataUDINT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CategoryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoryType'):
        if self.PreserveOnlineData is not None and 'PreserveOnlineData' not in already_processed:
            already_processed.add('PreserveOnlineData')
            outfile.write(' PreserveOnlineData="%s"' % self.gds_format_boolean(self.PreserveOnlineData, input_name='PreserveOnlineData'))
    def exportChildren(self, outfile, level, namespace_='', name_='CategoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CatNo is not None:
            self.CatNo.export(outfile, level, namespace_, name_='CatNo', pretty_print=pretty_print)
        if self.Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData>%s</%sData>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data).encode(ExternalEncoding), input_name='Data'), namespace_, eol_))
        if self.DataString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataString>%s</%sDataString>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataString).encode(ExternalEncoding), input_name='DataString'), namespace_, eol_))
        if self.DataUINT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataUINT>%s</%sDataUINT>%s' % (namespace_, self.gds_format_integer(self.DataUINT, input_name='DataUINT'), namespace_, eol_))
        if self.DataUDINT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataUDINT>%s</%sDataUDINT>%s' % (namespace_, self.gds_format_integer(self.DataUDINT, input_name='DataUDINT'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CategoryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PreserveOnlineData is not None and 'PreserveOnlineData' not in already_processed:
            already_processed.add('PreserveOnlineData')
            showIndent(outfile, level)
            outfile.write('PreserveOnlineData=%s,\n' % (self.PreserveOnlineData,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CatNo is not None:
            showIndent(outfile, level)
            outfile.write('CatNo=model_.CatNoType(\n')
            self.CatNo.exportLiteral(outfile, level, name_='CatNo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=%s,\n' % quote_python(self.Data).encode(ExternalEncoding))
        if self.DataString is not None:
            showIndent(outfile, level)
            outfile.write('DataString=%s,\n' % quote_python(self.DataString).encode(ExternalEncoding))
        if self.DataUINT is not None:
            showIndent(outfile, level)
            outfile.write('DataUINT=%d,\n' % self.DataUINT)
        if self.DataUDINT is not None:
            showIndent(outfile, level)
            outfile.write('DataUDINT=%d,\n' % self.DataUDINT)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PreserveOnlineData', node)
        if value is not None and 'PreserveOnlineData' not in already_processed:
            already_processed.add('PreserveOnlineData')
            if value in ('true', '1'):
                self.PreserveOnlineData = True
            elif value in ('false', '0'):
                self.PreserveOnlineData = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CatNo':
            obj_ = CatNoType.factory()
            obj_.build(child_)
            self.CatNo = obj_
        elif nodeName_ == 'Data':
            Data_ = child_.text
            Data_ = self.gds_validate_string(Data_, node, 'Data')
            self.Data = Data_
        elif nodeName_ == 'DataString':
            DataString_ = child_.text
            DataString_ = self.gds_validate_string(DataString_, node, 'DataString')
            self.DataString = DataString_
        elif nodeName_ == 'DataUINT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataUINT')
            self.DataUINT = ival_
        elif nodeName_ == 'DataUDINT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataUDINT')
            self.DataUDINT = ival_
# end class CategoryType


class CatNoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CatNoType.subclass:
            return CatNoType.subclass(*args_, **kwargs_)
        else:
            return CatNoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CatNoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CatNoType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CatNoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CatNoType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CatNoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CatNoType


class ElectricalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EBusCurrent=None):
        self.EBusCurrent = EBusCurrent
    def factory(*args_, **kwargs_):
        if ElectricalType.subclass:
            return ElectricalType.subclass(*args_, **kwargs_)
        else:
            return ElectricalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EBusCurrent(self): return self.EBusCurrent
    def set_EBusCurrent(self, EBusCurrent): self.EBusCurrent = EBusCurrent
    def hasContent_(self):
        if (
            self.EBusCurrent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EBusCurrent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEBusCurrent>%s</%sEBusCurrent>%s' % (namespace_, self.gds_format_integer(self.EBusCurrent, input_name='EBusCurrent'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ElectricalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EBusCurrent is not None:
            showIndent(outfile, level)
            outfile.write('EBusCurrent=%d,\n' % self.EBusCurrent)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EBusCurrent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EBusCurrent')
            self.EBusCurrent = ival_
# end class ElectricalType


class StateMachineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Timeout=None, Behavior=None):
        self.Timeout = Timeout
        self.Behavior = Behavior
    def factory(*args_, **kwargs_):
        if StateMachineType.subclass:
            return StateMachineType.subclass(*args_, **kwargs_)
        else:
            return StateMachineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Timeout(self): return self.Timeout
    def set_Timeout(self, Timeout): self.Timeout = Timeout
    def get_Behavior(self): return self.Behavior
    def set_Behavior(self, Behavior): self.Behavior = Behavior
    def hasContent_(self):
        if (
            self.Timeout is not None or
            self.Behavior is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StateMachineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateMachineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateMachineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StateMachineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Timeout is not None:
            self.Timeout.export(outfile, level, namespace_, name_='Timeout', pretty_print=pretty_print)
        if self.Behavior is not None:
            self.Behavior.export(outfile, level, namespace_, name_='Behavior', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StateMachineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Timeout is not None:
            showIndent(outfile, level)
            outfile.write('Timeout=model_.TimeoutType(\n')
            self.Timeout.exportLiteral(outfile, level, name_='Timeout')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Behavior is not None:
            showIndent(outfile, level)
            outfile.write('Behavior=model_.BehaviorType(\n')
            self.Behavior.exportLiteral(outfile, level, name_='Behavior')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Timeout':
            obj_ = TimeoutType.factory()
            obj_.build(child_)
            self.Timeout = obj_
        elif nodeName_ == 'Behavior':
            obj_ = BehaviorType.factory()
            obj_.build(child_)
            self.Behavior = obj_
# end class StateMachineType


class TimeoutType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PreopTimeout=None, SafeopOpTimeout=None, BackToInitTimeout=None, BackToSafeopTimeout=None):
        self.PreopTimeout = PreopTimeout
        self.SafeopOpTimeout = SafeopOpTimeout
        self.BackToInitTimeout = BackToInitTimeout
        self.BackToSafeopTimeout = BackToSafeopTimeout
    def factory(*args_, **kwargs_):
        if TimeoutType.subclass:
            return TimeoutType.subclass(*args_, **kwargs_)
        else:
            return TimeoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PreopTimeout(self): return self.PreopTimeout
    def set_PreopTimeout(self, PreopTimeout): self.PreopTimeout = PreopTimeout
    def get_SafeopOpTimeout(self): return self.SafeopOpTimeout
    def set_SafeopOpTimeout(self, SafeopOpTimeout): self.SafeopOpTimeout = SafeopOpTimeout
    def get_BackToInitTimeout(self): return self.BackToInitTimeout
    def set_BackToInitTimeout(self, BackToInitTimeout): self.BackToInitTimeout = BackToInitTimeout
    def get_BackToSafeopTimeout(self): return self.BackToSafeopTimeout
    def set_BackToSafeopTimeout(self, BackToSafeopTimeout): self.BackToSafeopTimeout = BackToSafeopTimeout
    def hasContent_(self):
        if (
            self.PreopTimeout is not None or
            self.SafeopOpTimeout is not None or
            self.BackToInitTimeout is not None or
            self.BackToSafeopTimeout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeoutType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeoutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeoutType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeoutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PreopTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreopTimeout>%s</%sPreopTimeout>%s' % (namespace_, self.gds_format_integer(self.PreopTimeout, input_name='PreopTimeout'), namespace_, eol_))
        if self.SafeopOpTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSafeopOpTimeout>%s</%sSafeopOpTimeout>%s' % (namespace_, self.gds_format_integer(self.SafeopOpTimeout, input_name='SafeopOpTimeout'), namespace_, eol_))
        if self.BackToInitTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackToInitTimeout>%s</%sBackToInitTimeout>%s' % (namespace_, self.gds_format_integer(self.BackToInitTimeout, input_name='BackToInitTimeout'), namespace_, eol_))
        if self.BackToSafeopTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackToSafeopTimeout>%s</%sBackToSafeopTimeout>%s' % (namespace_, self.gds_format_integer(self.BackToSafeopTimeout, input_name='BackToSafeopTimeout'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeoutType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PreopTimeout is not None:
            showIndent(outfile, level)
            outfile.write('PreopTimeout=%d,\n' % self.PreopTimeout)
        if self.SafeopOpTimeout is not None:
            showIndent(outfile, level)
            outfile.write('SafeopOpTimeout=%d,\n' % self.SafeopOpTimeout)
        if self.BackToInitTimeout is not None:
            showIndent(outfile, level)
            outfile.write('BackToInitTimeout=%d,\n' % self.BackToInitTimeout)
        if self.BackToSafeopTimeout is not None:
            showIndent(outfile, level)
            outfile.write('BackToSafeopTimeout=%d,\n' % self.BackToSafeopTimeout)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PreopTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PreopTimeout')
            self.PreopTimeout = ival_
        elif nodeName_ == 'SafeopOpTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SafeopOpTimeout')
            self.SafeopOpTimeout = ival_
        elif nodeName_ == 'BackToInitTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BackToInitTimeout')
            self.BackToInitTimeout = ival_
        elif nodeName_ == 'BackToSafeopTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BackToSafeopTimeout')
            self.BackToSafeopTimeout = ival_
# end class TimeoutType


class BehaviorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartToSafeop=None, StartToInit=None, StartToSafeopNoSync=None, StartToPreop=None):
        self.StartToSafeop = _cast(bool, StartToSafeop)
        self.StartToInit = _cast(bool, StartToInit)
        self.StartToSafeopNoSync = _cast(bool, StartToSafeopNoSync)
        self.StartToPreop = _cast(bool, StartToPreop)
        pass
    def factory(*args_, **kwargs_):
        if BehaviorType.subclass:
            return BehaviorType.subclass(*args_, **kwargs_)
        else:
            return BehaviorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartToSafeop(self): return self.StartToSafeop
    def set_StartToSafeop(self, StartToSafeop): self.StartToSafeop = StartToSafeop
    def get_StartToInit(self): return self.StartToInit
    def set_StartToInit(self, StartToInit): self.StartToInit = StartToInit
    def get_StartToSafeopNoSync(self): return self.StartToSafeopNoSync
    def set_StartToSafeopNoSync(self, StartToSafeopNoSync): self.StartToSafeopNoSync = StartToSafeopNoSync
    def get_StartToPreop(self): return self.StartToPreop
    def set_StartToPreop(self, StartToPreop): self.StartToPreop = StartToPreop
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BehaviorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BehaviorType'):
        if self.StartToSafeop is not None and 'StartToSafeop' not in already_processed:
            already_processed.add('StartToSafeop')
            outfile.write(' StartToSafeop="%s"' % self.gds_format_boolean(self.StartToSafeop, input_name='StartToSafeop'))
        if self.StartToInit is not None and 'StartToInit' not in already_processed:
            already_processed.add('StartToInit')
            outfile.write(' StartToInit="%s"' % self.gds_format_boolean(self.StartToInit, input_name='StartToInit'))
        if self.StartToSafeopNoSync is not None and 'StartToSafeopNoSync' not in already_processed:
            already_processed.add('StartToSafeopNoSync')
            outfile.write(' StartToSafeopNoSync="%s"' % self.gds_format_boolean(self.StartToSafeopNoSync, input_name='StartToSafeopNoSync'))
        if self.StartToPreop is not None and 'StartToPreop' not in already_processed:
            already_processed.add('StartToPreop')
            outfile.write(' StartToPreop="%s"' % self.gds_format_boolean(self.StartToPreop, input_name='StartToPreop'))
    def exportChildren(self, outfile, level, namespace_='', name_='BehaviorType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BehaviorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StartToSafeop is not None and 'StartToSafeop' not in already_processed:
            already_processed.add('StartToSafeop')
            showIndent(outfile, level)
            outfile.write('StartToSafeop=%s,\n' % (self.StartToSafeop,))
        if self.StartToInit is not None and 'StartToInit' not in already_processed:
            already_processed.add('StartToInit')
            showIndent(outfile, level)
            outfile.write('StartToInit=%s,\n' % (self.StartToInit,))
        if self.StartToSafeopNoSync is not None and 'StartToSafeopNoSync' not in already_processed:
            already_processed.add('StartToSafeopNoSync')
            showIndent(outfile, level)
            outfile.write('StartToSafeopNoSync=%s,\n' % (self.StartToSafeopNoSync,))
        if self.StartToPreop is not None and 'StartToPreop' not in already_processed:
            already_processed.add('StartToPreop')
            showIndent(outfile, level)
            outfile.write('StartToPreop=%s,\n' % (self.StartToPreop,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StartToSafeop', node)
        if value is not None and 'StartToSafeop' not in already_processed:
            already_processed.add('StartToSafeop')
            if value in ('true', '1'):
                self.StartToSafeop = True
            elif value in ('false', '0'):
                self.StartToSafeop = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StartToInit', node)
        if value is not None and 'StartToInit' not in already_processed:
            already_processed.add('StartToInit')
            if value in ('true', '1'):
                self.StartToInit = True
            elif value in ('false', '0'):
                self.StartToInit = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StartToSafeopNoSync', node)
        if value is not None and 'StartToSafeopNoSync' not in already_processed:
            already_processed.add('StartToSafeopNoSync')
            if value in ('true', '1'):
                self.StartToSafeopNoSync = True
            elif value in ('false', '0'):
                self.StartToSafeopNoSync = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('StartToPreop', node)
        if value is not None and 'StartToPreop' not in already_processed:
            already_processed.add('StartToPreop')
            if value in ('true', '1'):
                self.StartToPreop = True
            elif value in ('false', '0'):
                self.StartToPreop = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BehaviorType


class MailboxType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Timeout=None):
        self.Timeout = Timeout
    def factory(*args_, **kwargs_):
        if MailboxType17.subclass:
            return MailboxType17.subclass(*args_, **kwargs_)
        else:
            return MailboxType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Timeout(self): return self.Timeout
    def set_Timeout(self, Timeout): self.Timeout = Timeout
    def hasContent_(self):
        if (
            self.Timeout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MailboxType17', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MailboxType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MailboxType17'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MailboxType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Timeout is not None:
            self.Timeout.export(outfile, level, namespace_, name_='Timeout', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MailboxType17'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Timeout is not None:
            showIndent(outfile, level)
            outfile.write('Timeout=model_.TimeoutType18(\n')
            self.Timeout.exportLiteral(outfile, level, name_='Timeout')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Timeout':
            obj_ = TimeoutType18.factory()
            obj_.build(child_)
            self.Timeout = obj_
# end class MailboxType17


class TimeoutType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequestTimeout=None, ResponseTimeout=None):
        self.RequestTimeout = RequestTimeout
        self.ResponseTimeout = ResponseTimeout
    def factory(*args_, **kwargs_):
        if TimeoutType18.subclass:
            return TimeoutType18.subclass(*args_, **kwargs_)
        else:
            return TimeoutType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestTimeout(self): return self.RequestTimeout
    def set_RequestTimeout(self, RequestTimeout): self.RequestTimeout = RequestTimeout
    def get_ResponseTimeout(self): return self.ResponseTimeout
    def set_ResponseTimeout(self, ResponseTimeout): self.ResponseTimeout = ResponseTimeout
    def hasContent_(self):
        if (
            self.RequestTimeout is not None or
            self.ResponseTimeout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeoutType18', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeoutType18')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeoutType18'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeoutType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RequestTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRequestTimeout>%s</%sRequestTimeout>%s' % (namespace_, self.gds_format_integer(self.RequestTimeout, input_name='RequestTimeout'), namespace_, eol_))
        if self.ResponseTimeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResponseTimeout>%s</%sResponseTimeout>%s' % (namespace_, self.gds_format_integer(self.ResponseTimeout, input_name='ResponseTimeout'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeoutType18'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RequestTimeout is not None:
            showIndent(outfile, level)
            outfile.write('RequestTimeout=%d,\n' % self.RequestTimeout)
        if self.ResponseTimeout is not None:
            showIndent(outfile, level)
            outfile.write('ResponseTimeout=%d,\n' % self.ResponseTimeout)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequestTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RequestTimeout')
            self.RequestTimeout = ival_
        elif nodeName_ == 'ResponseTimeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ResponseTimeout')
            self.ResponseTimeout = ival_
# end class TimeoutType18


class EtherCATControllerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DpramSize=4096, SmCount=None, FmmuCount=None):
        self.DpramSize = DpramSize
        self.SmCount = SmCount
        self.FmmuCount = FmmuCount
    def factory(*args_, **kwargs_):
        if EtherCATControllerType.subclass:
            return EtherCATControllerType.subclass(*args_, **kwargs_)
        else:
            return EtherCATControllerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DpramSize(self): return self.DpramSize
    def set_DpramSize(self, DpramSize): self.DpramSize = DpramSize
    def get_SmCount(self): return self.SmCount
    def set_SmCount(self, SmCount): self.SmCount = SmCount
    def get_FmmuCount(self): return self.FmmuCount
    def set_FmmuCount(self, FmmuCount): self.FmmuCount = FmmuCount
    def hasContent_(self):
        if (
            self.DpramSize is not None or
            self.SmCount is not None or
            self.FmmuCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EtherCATControllerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EtherCATControllerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EtherCATControllerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EtherCATControllerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DpramSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDpramSize>%s</%sDpramSize>%s' % (namespace_, self.gds_format_integer(self.DpramSize, input_name='DpramSize'), namespace_, eol_))
        if self.SmCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSmCount>%s</%sSmCount>%s' % (namespace_, self.gds_format_integer(self.SmCount, input_name='SmCount'), namespace_, eol_))
        if self.FmmuCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFmmuCount>%s</%sFmmuCount>%s' % (namespace_, self.gds_format_integer(self.FmmuCount, input_name='FmmuCount'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EtherCATControllerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DpramSize is not None:
            showIndent(outfile, level)
            outfile.write('DpramSize=%d,\n' % self.DpramSize)
        if self.SmCount is not None:
            showIndent(outfile, level)
            outfile.write('SmCount=%d,\n' % self.SmCount)
        if self.FmmuCount is not None:
            showIndent(outfile, level)
            outfile.write('FmmuCount=%d,\n' % self.FmmuCount)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DpramSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DpramSize')
            self.DpramSize = ival_
        elif nodeName_ == 'SmCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SmCount')
            self.SmCount = ival_
        elif nodeName_ == 'FmmuCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FmmuCount')
            self.FmmuCount = ival_
# end class EtherCATControllerType


class PortType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Connector=None, Label=None, RxDelay=None, TxDelay=None, PhysicalPhyAddr=None):
        self.Type = Type
        self.Connector = Connector
        self.Label = Label
        self.RxDelay = RxDelay
        self.TxDelay = TxDelay
        self.PhysicalPhyAddr = PhysicalPhyAddr
    def factory(*args_, **kwargs_):
        if PortType.subclass:
            return PortType.subclass(*args_, **kwargs_)
        else:
            return PortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Connector(self): return self.Connector
    def set_Connector(self, Connector): self.Connector = Connector
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_RxDelay(self): return self.RxDelay
    def set_RxDelay(self, RxDelay): self.RxDelay = RxDelay
    def get_TxDelay(self): return self.TxDelay
    def set_TxDelay(self, TxDelay): self.TxDelay = TxDelay
    def get_PhysicalPhyAddr(self): return self.PhysicalPhyAddr
    def set_PhysicalPhyAddr(self, PhysicalPhyAddr): self.PhysicalPhyAddr = PhysicalPhyAddr
    def validate_TypeType19(self, value):
        # Validate type TypeType19, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Connector is not None or
            self.Label is not None or
            self.RxDelay is not None or
            self.TxDelay is not None or
            self.PhysicalPhyAddr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PortType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.Connector is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConnector>%s</%sConnector>%s' % (namespace_, self.gds_format_string(quote_xml(self.Connector).encode(ExternalEncoding), input_name='Connector'), namespace_, eol_))
        if self.Label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLabel>%s</%sLabel>%s' % (namespace_, self.gds_format_string(quote_xml(self.Label).encode(ExternalEncoding), input_name='Label'), namespace_, eol_))
        if self.RxDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRxDelay>%s</%sRxDelay>%s' % (namespace_, self.gds_format_integer(self.RxDelay, input_name='RxDelay'), namespace_, eol_))
        if self.TxDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTxDelay>%s</%sTxDelay>%s' % (namespace_, self.gds_format_integer(self.TxDelay, input_name='TxDelay'), namespace_, eol_))
        if self.PhysicalPhyAddr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhysicalPhyAddr>%s</%sPhysicalPhyAddr>%s' % (namespace_, self.gds_format_integer(self.PhysicalPhyAddr, input_name='PhysicalPhyAddr'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PortType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Connector is not None:
            showIndent(outfile, level)
            outfile.write('Connector=%s,\n' % quote_python(self.Connector).encode(ExternalEncoding))
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=%s,\n' % quote_python(self.Label).encode(ExternalEncoding))
        if self.RxDelay is not None:
            showIndent(outfile, level)
            outfile.write('RxDelay=%d,\n' % self.RxDelay)
        if self.TxDelay is not None:
            showIndent(outfile, level)
            outfile.write('TxDelay=%d,\n' % self.TxDelay)
        if self.PhysicalPhyAddr is not None:
            showIndent(outfile, level)
            outfile.write('PhysicalPhyAddr=%d,\n' % self.PhysicalPhyAddr)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            self.validate_TypeType19(self.Type)    # validate type TypeType19
        elif nodeName_ == 'Connector':
            Connector_ = child_.text
            Connector_ = self.gds_validate_string(Connector_, node, 'Connector')
            self.Connector = Connector_
        elif nodeName_ == 'Label':
            Label_ = child_.text
            Label_ = self.gds_validate_string(Label_, node, 'Label')
            self.Label = Label_
        elif nodeName_ == 'RxDelay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RxDelay')
            self.RxDelay = ival_
        elif nodeName_ == 'TxDelay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TxDelay')
            self.TxDelay = ival_
        elif nodeName_ == 'PhysicalPhyAddr':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PhysicalPhyAddr')
            self.PhysicalPhyAddr = ival_
# end class PortType


class ExecutionUnitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, RxDelay=None, TxDelay=None):
        self.Type = Type
        self.RxDelay = RxDelay
        self.TxDelay = TxDelay
    def factory(*args_, **kwargs_):
        if ExecutionUnitType.subclass:
            return ExecutionUnitType.subclass(*args_, **kwargs_)
        else:
            return ExecutionUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_RxDelay(self): return self.RxDelay
    def set_RxDelay(self, RxDelay): self.RxDelay = RxDelay
    def get_TxDelay(self): return self.TxDelay
    def set_TxDelay(self, TxDelay): self.TxDelay = TxDelay
    def validate_TypeType20(self, value):
        # Validate type TypeType20, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Type is not None or
            self.RxDelay is not None or
            self.TxDelay is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExecutionUnitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutionUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutionUnitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutionUnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.RxDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRxDelay>%s</%sRxDelay>%s' % (namespace_, self.gds_format_integer(self.RxDelay, input_name='RxDelay'), namespace_, eol_))
        if self.TxDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTxDelay>%s</%sTxDelay>%s' % (namespace_, self.gds_format_integer(self.TxDelay, input_name='TxDelay'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ExecutionUnitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.RxDelay is not None:
            showIndent(outfile, level)
            outfile.write('RxDelay=%d,\n' % self.RxDelay)
        if self.TxDelay is not None:
            showIndent(outfile, level)
            outfile.write('TxDelay=%d,\n' % self.TxDelay)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            self.validate_TypeType20(self.Type)    # validate type TypeType20
        elif nodeName_ == 'RxDelay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RxDelay')
            self.RxDelay = ival_
        elif nodeName_ == 'TxDelay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TxDelay')
            self.TxDelay = ival_
# end class ExecutionUnitType


class DeviceFeatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None, Description=None, Register=None):
        self.Name = Name
        self.Value = Value
        self.Description = Description
        if Register is None:
            self.Register = []
        else:
            self.Register = Register
    def factory(*args_, **kwargs_):
        if DeviceFeatureType.subclass:
            return DeviceFeatureType.subclass(*args_, **kwargs_)
        else:
            return DeviceFeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Register(self): return self.Register
    def set_Register(self, Register): self.Register = Register
    def add_Register(self, value): self.Register.append(value)
    def insert_Register(self, index, value): self.Register[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None or
            self.Description is not None or
            self.Register
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceFeatureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceFeatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceFeatureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceFeatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        for Register_ in self.Register:
            Register_.export(outfile, level, namespace_, name_='Register', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeviceFeatureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Register=[\n')
        level += 1
        for Register_ in self.Register:
            showIndent(outfile, level)
            outfile.write('model_.RegisterType(\n')
            Register_.exportLiteral(outfile, level, name_='RegisterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Register':
            obj_ = RegisterType.factory()
            obj_.build(child_)
            self.Register.append(obj_)
# end class DeviceFeatureType


class RegisterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartAddress=None, Length=None, BitMask=None):
        self.StartAddress = StartAddress
        self.Length = Length
        self.BitMask = BitMask
    def factory(*args_, **kwargs_):
        if RegisterType.subclass:
            return RegisterType.subclass(*args_, **kwargs_)
        else:
            return RegisterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartAddress(self): return self.StartAddress
    def set_StartAddress(self, StartAddress): self.StartAddress = StartAddress
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_BitMask(self): return self.BitMask
    def set_BitMask(self, BitMask): self.BitMask = BitMask
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.StartAddress is not None or
            self.Length is not None or
            self.BitMask is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegisterType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegisterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegisterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegisterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartAddress>%s</%sStartAddress>%s' % (namespace_, self.gds_format_integer(self.StartAddress, input_name='StartAddress'), namespace_, eol_))
        if self.Length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLength>%s</%sLength>%s' % (namespace_, self.gds_format_integer(self.Length, input_name='Length'), namespace_, eol_))
        if self.BitMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBitMask>%s</%sBitMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.BitMask).encode(ExternalEncoding), input_name='BitMask'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RegisterType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartAddress is not None:
            showIndent(outfile, level)
            outfile.write('StartAddress=%d,\n' % self.StartAddress)
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=%d,\n' % self.Length)
        if self.BitMask is not None:
            showIndent(outfile, level)
            outfile.write('BitMask=%s,\n' % quote_python(self.BitMask).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartAddress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartAddress')
            self.StartAddress = ival_
        elif nodeName_ == 'Length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Length')
            self.Length = ival_
        elif nodeName_ == 'BitMask':
            BitMask_ = child_.text
            BitMask_ = self.gds_validate_string(BitMask_, node, 'BitMask')
            self.BitMask = BitMask_
            self.validate_HexDecValue(self.BitMask)    # validate type HexDecValue
# end class RegisterType


class ModuleIdentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Default=None, valueOf_=None):
        self.Default = _cast(None, Default)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ModuleIdentType.subclass:
            return ModuleIdentType.subclass(*args_, **kwargs_)
        else:
            return ModuleIdentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModuleIdentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleIdentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModuleIdentType'):
        if self.Default is not None and 'Default' not in already_processed:
            already_processed.add('Default')
            outfile.write(' Default=%s' % (quote_attrib(self.Default), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ModuleIdentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ModuleIdentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Default is not None and 'Default' not in already_processed:
            already_processed.add('Default')
            showIndent(outfile, level)
            outfile.write('Default="%s",\n' % (self.Default,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Default', node)
        if value is not None and 'Default' not in already_processed:
            already_processed.add('Default')
            self.Default = value
            self.validate_HexDecValue(self.Default)    # validate type HexDecValue
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModuleIdentType


class ModuleClassType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Class=None, VendorId=None, Name=None, Image16x14=None, ImageFile16x14=None, ImageData16x14=None):
        self.Class = Class
        self.VendorId = VendorId
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Image16x14 = Image16x14
        self.ImageFile16x14 = ImageFile16x14
        self.ImageData16x14 = ImageData16x14
    def factory(*args_, **kwargs_):
        if ModuleClassType.subclass:
            return ModuleClassType.subclass(*args_, **kwargs_)
        else:
            return ModuleClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Class(self): return self.Class
    def set_Class(self, Class): self.Class = Class
    def get_VendorId(self): return self.VendorId
    def set_VendorId(self, VendorId): self.VendorId = VendorId
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Image16x14(self): return self.Image16x14
    def set_Image16x14(self, Image16x14): self.Image16x14 = Image16x14
    def get_ImageFile16x14(self): return self.ImageFile16x14
    def set_ImageFile16x14(self, ImageFile16x14): self.ImageFile16x14 = ImageFile16x14
    def get_ImageData16x14(self): return self.ImageData16x14
    def set_ImageData16x14(self, ImageData16x14): self.ImageData16x14 = ImageData16x14
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Class is not None or
            self.VendorId is not None or
            self.Name or
            self.Image16x14 is not None or
            self.ImageFile16x14 is not None or
            self.ImageData16x14 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModuleClassType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleClassType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModuleClassType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModuleClassType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Class is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClass>%s</%sClass>%s' % (namespace_, self.gds_format_string(quote_xml(self.Class).encode(ExternalEncoding), input_name='Class'), namespace_, eol_))
        if self.VendorId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVendorId>%s</%sVendorId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VendorId).encode(ExternalEncoding), input_name='VendorId'), namespace_, eol_))
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Image16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage16x14>%s</%sImage16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image16x14).encode(ExternalEncoding), input_name='Image16x14'), namespace_, eol_))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageFile16x14>%s</%sImageFile16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageFile16x14).encode(ExternalEncoding), input_name='ImageFile16x14'), namespace_, eol_))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageData16x14>%s</%sImageData16x14>%s' % (namespace_, self.gds_format_string(quote_xml(self.ImageData16x14).encode(ExternalEncoding), input_name='ImageData16x14'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ModuleClassType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Class is not None:
            showIndent(outfile, level)
            outfile.write('Class=%s,\n' % quote_python(self.Class).encode(ExternalEncoding))
        if self.VendorId is not None:
            showIndent(outfile, level)
            outfile.write('VendorId=%s,\n' % quote_python(self.VendorId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Image16x14 is not None:
            showIndent(outfile, level)
            outfile.write('Image16x14=%s,\n' % quote_python(self.Image16x14).encode(ExternalEncoding))
        if self.ImageFile16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageFile16x14=%s,\n' % quote_python(self.ImageFile16x14).encode(ExternalEncoding))
        if self.ImageData16x14 is not None:
            showIndent(outfile, level)
            outfile.write('ImageData16x14=%s,\n' % quote_python(self.ImageData16x14).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Class':
            Class_ = child_.text
            Class_ = self.gds_validate_string(Class_, node, 'Class')
            self.Class = Class_
        elif nodeName_ == 'VendorId':
            VendorId_ = child_.text
            VendorId_ = self.gds_validate_string(VendorId_, node, 'VendorId')
            self.VendorId = VendorId_
            self.validate_HexDecValue(self.VendorId)    # validate type HexDecValue
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name.append(obj_)
        elif nodeName_ == 'Image16x14':
            Image16x14_ = child_.text
            Image16x14_ = self.gds_validate_string(Image16x14_, node, 'Image16x14')
            self.Image16x14 = Image16x14_
        elif nodeName_ == 'ImageFile16x14':
            ImageFile16x14_ = child_.text
            ImageFile16x14_ = self.gds_validate_string(ImageFile16x14_, node, 'ImageFile16x14')
            self.ImageFile16x14 = ImageFile16x14_
        elif nodeName_ == 'ImageData16x14':
            ImageData16x14_ = child_.text
            ImageData16x14_ = self.gds_validate_string(ImageData16x14_, node, 'ImageData16x14')
            self.ImageData16x14 = ImageData16x14_
# end class ModuleClassType


class PropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if PropertiesType.subclass:
            return PropertiesType.subclass(*args_, **kwargs_)
        else:
            return PropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class PropertiesType


class XmlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if XmlType.subclass:
            return XmlType.subclass(*args_, **kwargs_)
        else:
            return XmlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XmlType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XmlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XmlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XmlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='XmlType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'XmlType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class XmlType


class FlagsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Access=None, Category=None, PdoMapping=None, SafetyMapping=None, Attribute=None, Backup=None, Setting=None):
        self.Access = Access
        self.Category = Category
        self.PdoMapping = PdoMapping
        self.SafetyMapping = SafetyMapping
        self.Attribute = Attribute
        self.Backup = Backup
        self.Setting = Setting
    def factory(*args_, **kwargs_):
        if FlagsType.subclass:
            return FlagsType.subclass(*args_, **kwargs_)
        else:
            return FlagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Access(self): return self.Access
    def set_Access(self, Access): self.Access = Access
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_PdoMapping(self): return self.PdoMapping
    def set_PdoMapping(self, PdoMapping): self.PdoMapping = PdoMapping
    def get_SafetyMapping(self): return self.SafetyMapping
    def set_SafetyMapping(self, SafetyMapping): self.SafetyMapping = SafetyMapping
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Backup(self): return self.Backup
    def set_Backup(self, Backup): self.Backup = Backup
    def get_Setting(self): return self.Setting
    def set_Setting(self, Setting): self.Setting = Setting
    def validate_CategoryType22(self, value):
        # Validate type CategoryType22, a restriction on xs:NMTOKEN.
        pass
    def validate_PdoMappingType(self, value):
        # Validate type PdoMappingType, a restriction on xs:NMTOKEN.
        pass
    def validate_SafetyMappingType(self, value):
        # Validate type SafetyMappingType, a restriction on xs:NMTOKEN.
        pass
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Access is not None or
            self.Category is not None or
            self.PdoMapping is not None or
            self.SafetyMapping is not None or
            self.Attribute is not None or
            self.Backup is not None or
            self.Setting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlagsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlagsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Access is not None:
            self.Access.export(outfile, level, namespace_, name_='Access', pretty_print=pretty_print)
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategory>%s</%sCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Category).encode(ExternalEncoding), input_name='Category'), namespace_, eol_))
        if self.PdoMapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPdoMapping>%s</%sPdoMapping>%s' % (namespace_, self.gds_format_string(quote_xml(self.PdoMapping).encode(ExternalEncoding), input_name='PdoMapping'), namespace_, eol_))
        if self.SafetyMapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSafetyMapping>%s</%sSafetyMapping>%s' % (namespace_, self.gds_format_string(quote_xml(self.SafetyMapping).encode(ExternalEncoding), input_name='SafetyMapping'), namespace_, eol_))
        if self.Attribute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttribute>%s</%sAttribute>%s' % (namespace_, self.gds_format_string(quote_xml(self.Attribute).encode(ExternalEncoding), input_name='Attribute'), namespace_, eol_))
        if self.Backup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackup>%s</%sBackup>%s' % (namespace_, self.gds_format_integer(self.Backup, input_name='Backup'), namespace_, eol_))
        if self.Setting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSetting>%s</%sSetting>%s' % (namespace_, self.gds_format_integer(self.Setting, input_name='Setting'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FlagsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Access is not None:
            showIndent(outfile, level)
            outfile.write('Access=model_.AccessType21(\n')
            self.Access.exportLiteral(outfile, level, name_='Access')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=%s,\n' % quote_python(self.Category).encode(ExternalEncoding))
        if self.PdoMapping is not None:
            showIndent(outfile, level)
            outfile.write('PdoMapping=%s,\n' % quote_python(self.PdoMapping).encode(ExternalEncoding))
        if self.SafetyMapping is not None:
            showIndent(outfile, level)
            outfile.write('SafetyMapping=%s,\n' % quote_python(self.SafetyMapping).encode(ExternalEncoding))
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=%s,\n' % quote_python(self.Attribute).encode(ExternalEncoding))
        if self.Backup is not None:
            showIndent(outfile, level)
            outfile.write('Backup=%d,\n' % self.Backup)
        if self.Setting is not None:
            showIndent(outfile, level)
            outfile.write('Setting=%d,\n' % self.Setting)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Access':
            obj_ = AccessType21.factory()
            obj_.build(child_)
            self.Access = obj_
        elif nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
            self.validate_CategoryType22(self.Category)    # validate type CategoryType22
        elif nodeName_ == 'PdoMapping':
            PdoMapping_ = child_.text
            PdoMapping_ = self.gds_validate_string(PdoMapping_, node, 'PdoMapping')
            self.PdoMapping = PdoMapping_
            self.validate_PdoMappingType(self.PdoMapping)    # validate type PdoMappingType
        elif nodeName_ == 'SafetyMapping':
            SafetyMapping_ = child_.text
            SafetyMapping_ = self.gds_validate_string(SafetyMapping_, node, 'SafetyMapping')
            self.SafetyMapping = SafetyMapping_
            self.validate_SafetyMappingType(self.SafetyMapping)    # validate type SafetyMappingType
        elif nodeName_ == 'Attribute':
            Attribute_ = child_.text
            Attribute_ = self.gds_validate_string(Attribute_, node, 'Attribute')
            self.Attribute = Attribute_
            self.validate_HexDecValue(self.Attribute)    # validate type HexDecValue
        elif nodeName_ == 'Backup':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Backup')
            self.Backup = ival_
        elif nodeName_ == 'Setting':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Setting')
            self.Setting = ival_
# end class FlagsType


class AccessType21(AccessType):
    subclass = None
    superclass = AccessType
    def __init__(self, ReadRestrictions=None, WriteRestrictions=None, valueOf_=None):
        super(AccessType21, self).__init__(ReadRestrictions, WriteRestrictions, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AccessType21.subclass:
            return AccessType21.subclass(*args_, **kwargs_)
        else:
            return AccessType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AccessType21, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessType21', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessType21')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessType21'):
        super(AccessType21, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessType21')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessType21', fromsubclass_=False, pretty_print=True):
        super(AccessType21, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AccessType21'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessType21, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessType21, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessType21, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccessType21


class XmlType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if XmlType23.subclass:
            return XmlType23.subclass(*args_, **kwargs_)
        else:
            return XmlType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XmlType23', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XmlType23')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XmlType23'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XmlType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='XmlType23'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'XmlType23')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class XmlType23


class UnitTypesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitType=None):
        if UnitType is None:
            self.UnitType = []
        else:
            self.UnitType = UnitType
    def factory(*args_, **kwargs_):
        if UnitTypesType.subclass:
            return UnitTypesType.subclass(*args_, **kwargs_)
        else:
            return UnitTypesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitType(self): return self.UnitType
    def set_UnitType(self, UnitType): self.UnitType = UnitType
    def add_UnitType(self, value): self.UnitType.append(value)
    def insert_UnitType(self, index, value): self.UnitType[index] = value
    def hasContent_(self):
        if (
            self.UnitType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnitTypesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitTypesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitTypesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnitTypesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UnitType_ in self.UnitType:
            UnitType_.export(outfile, level, namespace_, name_='UnitType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UnitTypesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('UnitType=[\n')
        level += 1
        for UnitType_ in self.UnitType:
            showIndent(outfile, level)
            outfile.write('model_.UnitTypeType(\n')
            UnitType_.exportLiteral(outfile, level, name_='UnitTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitType':
            obj_ = UnitTypeType.factory()
            obj_.build(child_)
            self.UnitType.append(obj_)
# end class UnitTypesType


class DataTypesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataType=None):
        if DataType is None:
            self.DataType = []
        else:
            self.DataType = DataType
    def factory(*args_, **kwargs_):
        if DataTypesType.subclass:
            return DataTypesType.subclass(*args_, **kwargs_)
        else:
            return DataTypesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def add_DataType(self, value): self.DataType.append(value)
    def insert_DataType(self, index, value): self.DataType[index] = value
    def hasContent_(self):
        if (
            self.DataType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataTypesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTypesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataTypesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataTypesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataType_ in self.DataType:
            DataType_.export(outfile, level, namespace_, name_='DataType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataTypesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataType=[\n')
        level += 1
        for DataType_ in self.DataType:
            showIndent(outfile, level)
            outfile.write('model_.DataTypeType(\n')
            DataType_.exportLiteral(outfile, level, name_='DataTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataType':
            obj_ = DataTypeType.factory()
            obj_.build(child_)
            self.DataType.append(obj_)
# end class DataTypesType


class ObjectsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if ObjectsType.subclass:
            return ObjectsType.subclass(*args_, **kwargs_)
        else:
            return ObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def hasContent_(self):
        if (
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.ObjectType(\n')
            Object_.exportLiteral(outfile, level, name_='ObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class ObjectsType


class IndexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OverwrittenByModule=None, DependOnSlot=None, DependOnSlotGroup=None, valueOf_=None):
        self.OverwrittenByModule = _cast(bool, OverwrittenByModule)
        self.DependOnSlot = _cast(bool, DependOnSlot)
        self.DependOnSlotGroup = _cast(bool, DependOnSlotGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IndexType.subclass:
            return IndexType.subclass(*args_, **kwargs_)
        else:
            return IndexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OverwrittenByModule(self): return self.OverwrittenByModule
    def set_OverwrittenByModule(self, OverwrittenByModule): self.OverwrittenByModule = OverwrittenByModule
    def get_DependOnSlot(self): return self.DependOnSlot
    def set_DependOnSlot(self, DependOnSlot): self.DependOnSlot = DependOnSlot
    def get_DependOnSlotGroup(self): return self.DependOnSlotGroup
    def set_DependOnSlotGroup(self, DependOnSlotGroup): self.DependOnSlotGroup = DependOnSlotGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndexType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndexType'):
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            outfile.write(' OverwrittenByModule="%s"' % self.gds_format_boolean(self.OverwrittenByModule, input_name='OverwrittenByModule'))
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            outfile.write(' DependOnSlot="%s"' % self.gds_format_boolean(self.DependOnSlot, input_name='DependOnSlot'))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            outfile.write(' DependOnSlotGroup="%s"' % self.gds_format_boolean(self.DependOnSlotGroup, input_name='DependOnSlotGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndexType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IndexType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            showIndent(outfile, level)
            outfile.write('OverwrittenByModule=%s,\n' % (self.OverwrittenByModule,))
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            showIndent(outfile, level)
            outfile.write('DependOnSlot=%s,\n' % (self.DependOnSlot,))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            showIndent(outfile, level)
            outfile.write('DependOnSlotGroup=%s,\n' % (self.DependOnSlotGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OverwrittenByModule', node)
        if value is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            if value in ('true', '1'):
                self.OverwrittenByModule = True
            elif value in ('false', '0'):
                self.OverwrittenByModule = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlot', node)
        if value is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            if value in ('true', '1'):
                self.DependOnSlot = True
            elif value in ('false', '0'):
                self.DependOnSlot = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlotGroup', node)
        if value is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            if value in ('true', '1'):
                self.DependOnSlotGroup = True
            elif value in ('false', '0'):
                self.DependOnSlotGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndexType


class FlagsType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Access=None, Category=None, PdoMapping=None, SafetyMapping=None, Attribute=None, Transition=None, SdoAccess=None, Backup=None, Setting=None):
        self.Access = Access
        self.Category = Category
        self.PdoMapping = PdoMapping
        self.SafetyMapping = SafetyMapping
        self.Attribute = Attribute
        self.Transition = Transition
        self.SdoAccess = SdoAccess
        self.Backup = Backup
        self.Setting = Setting
    def factory(*args_, **kwargs_):
        if FlagsType24.subclass:
            return FlagsType24.subclass(*args_, **kwargs_)
        else:
            return FlagsType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Access(self): return self.Access
    def set_Access(self, Access): self.Access = Access
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_PdoMapping(self): return self.PdoMapping
    def set_PdoMapping(self, PdoMapping): self.PdoMapping = PdoMapping
    def get_SafetyMapping(self): return self.SafetyMapping
    def set_SafetyMapping(self, SafetyMapping): self.SafetyMapping = SafetyMapping
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def get_SdoAccess(self): return self.SdoAccess
    def set_SdoAccess(self, SdoAccess): self.SdoAccess = SdoAccess
    def get_Backup(self): return self.Backup
    def set_Backup(self, Backup): self.Backup = Backup
    def get_Setting(self): return self.Setting
    def set_Setting(self, Setting): self.Setting = Setting
    def validate_CategoryType26(self, value):
        # Validate type CategoryType26, a restriction on xs:NMTOKEN.
        pass
    def validate_PdoMappingType27(self, value):
        # Validate type PdoMappingType27, a restriction on xs:NMTOKEN.
        pass
    def validate_SafetyMappingType28(self, value):
        # Validate type SafetyMappingType28, a restriction on xs:NMTOKEN.
        pass
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def validate_TransitionType29(self, value):
        # Validate type TransitionType29, a restriction on xs:NMTOKEN.
        pass
    def validate_SdoAccessType(self, value):
        # Validate type SdoAccessType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Access is not None or
            self.Category is not None or
            self.PdoMapping is not None or
            self.SafetyMapping is not None or
            self.Attribute is not None or
            self.Transition is not None or
            self.SdoAccess is not None or
            self.Backup is not None or
            self.Setting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlagsType24', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlagsType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlagsType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlagsType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Access is not None:
            self.Access.export(outfile, level, namespace_, name_='Access', pretty_print=pretty_print)
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategory>%s</%sCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Category).encode(ExternalEncoding), input_name='Category'), namespace_, eol_))
        if self.PdoMapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPdoMapping>%s</%sPdoMapping>%s' % (namespace_, self.gds_format_string(quote_xml(self.PdoMapping).encode(ExternalEncoding), input_name='PdoMapping'), namespace_, eol_))
        if self.SafetyMapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSafetyMapping>%s</%sSafetyMapping>%s' % (namespace_, self.gds_format_string(quote_xml(self.SafetyMapping).encode(ExternalEncoding), input_name='SafetyMapping'), namespace_, eol_))
        if self.Attribute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttribute>%s</%sAttribute>%s' % (namespace_, self.gds_format_string(quote_xml(self.Attribute).encode(ExternalEncoding), input_name='Attribute'), namespace_, eol_))
        if self.Transition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(self.Transition).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.SdoAccess is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSdoAccess>%s</%sSdoAccess>%s' % (namespace_, self.gds_format_string(quote_xml(self.SdoAccess).encode(ExternalEncoding), input_name='SdoAccess'), namespace_, eol_))
        if self.Backup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackup>%s</%sBackup>%s' % (namespace_, self.gds_format_integer(self.Backup, input_name='Backup'), namespace_, eol_))
        if self.Setting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSetting>%s</%sSetting>%s' % (namespace_, self.gds_format_integer(self.Setting, input_name='Setting'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FlagsType24'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Access is not None:
            showIndent(outfile, level)
            outfile.write('Access=model_.AccessType25(\n')
            self.Access.exportLiteral(outfile, level, name_='Access')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=%s,\n' % quote_python(self.Category).encode(ExternalEncoding))
        if self.PdoMapping is not None:
            showIndent(outfile, level)
            outfile.write('PdoMapping=%s,\n' % quote_python(self.PdoMapping).encode(ExternalEncoding))
        if self.SafetyMapping is not None:
            showIndent(outfile, level)
            outfile.write('SafetyMapping=%s,\n' % quote_python(self.SafetyMapping).encode(ExternalEncoding))
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=%s,\n' % quote_python(self.Attribute).encode(ExternalEncoding))
        if self.Transition is not None:
            showIndent(outfile, level)
            outfile.write('Transition=%s,\n' % quote_python(self.Transition).encode(ExternalEncoding))
        if self.SdoAccess is not None:
            showIndent(outfile, level)
            outfile.write('SdoAccess=%s,\n' % quote_python(self.SdoAccess).encode(ExternalEncoding))
        if self.Backup is not None:
            showIndent(outfile, level)
            outfile.write('Backup=%d,\n' % self.Backup)
        if self.Setting is not None:
            showIndent(outfile, level)
            outfile.write('Setting=%d,\n' % self.Setting)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Access':
            obj_ = AccessType25.factory()
            obj_.build(child_)
            self.Access = obj_
        elif nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
            self.validate_CategoryType26(self.Category)    # validate type CategoryType26
        elif nodeName_ == 'PdoMapping':
            PdoMapping_ = child_.text
            PdoMapping_ = self.gds_validate_string(PdoMapping_, node, 'PdoMapping')
            self.PdoMapping = PdoMapping_
            self.validate_PdoMappingType27(self.PdoMapping)    # validate type PdoMappingType27
        elif nodeName_ == 'SafetyMapping':
            SafetyMapping_ = child_.text
            SafetyMapping_ = self.gds_validate_string(SafetyMapping_, node, 'SafetyMapping')
            self.SafetyMapping = SafetyMapping_
            self.validate_SafetyMappingType28(self.SafetyMapping)    # validate type SafetyMappingType28
        elif nodeName_ == 'Attribute':
            Attribute_ = child_.text
            Attribute_ = self.gds_validate_string(Attribute_, node, 'Attribute')
            self.Attribute = Attribute_
            self.validate_HexDecValue(self.Attribute)    # validate type HexDecValue
        elif nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition = Transition_
            self.validate_TransitionType29(self.Transition)    # validate type TransitionType29
        elif nodeName_ == 'SdoAccess':
            SdoAccess_ = child_.text
            SdoAccess_ = self.gds_validate_string(SdoAccess_, node, 'SdoAccess')
            self.SdoAccess = SdoAccess_
            self.validate_SdoAccessType(self.SdoAccess)    # validate type SdoAccessType
        elif nodeName_ == 'Backup':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Backup')
            self.Backup = ival_
        elif nodeName_ == 'Setting':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Setting')
            self.Setting = ival_
# end class FlagsType24


class AccessType25(AccessType):
    subclass = None
    superclass = AccessType
    def __init__(self, ReadRestrictions=None, WriteRestrictions=None, valueOf_=None):
        super(AccessType25, self).__init__(ReadRestrictions, WriteRestrictions, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AccessType25.subclass:
            return AccessType25.subclass(*args_, **kwargs_)
        else:
            return AccessType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AccessType25, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessType25', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessType25')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessType25'):
        super(AccessType25, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessType25')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessType25', fromsubclass_=False, pretty_print=True):
        super(AccessType25, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AccessType25'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessType25, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessType25, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessType25, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccessType25


class PropertiesType30(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if PropertiesType30.subclass:
            return PropertiesType30.subclass(*args_, **kwargs_)
        else:
            return PropertiesType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertiesType30', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertiesType30'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PropertiesType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertiesType30'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class PropertiesType30


class XmlType31(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if XmlType31.subclass:
            return XmlType31.subclass(*args_, **kwargs_)
        else:
            return XmlType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XmlType31', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XmlType31')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XmlType31'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XmlType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='XmlType31'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'XmlType31')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class XmlType31


class SubItemType32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Info=None):
        self.Name = Name
        self.Info = Info
    def factory(*args_, **kwargs_):
        if SubItemType32.subclass:
            return SubItemType32.subclass(*args_, **kwargs_)
        else:
            return SubItemType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Info is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubItemType32', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubItemType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubItemType32'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubItemType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubItemType32'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.ObjectInfoType(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Info':
            obj_ = ObjectInfoType.factory()
            obj_.build(child_)
            self.Info = obj_
# end class SubItemType32


class IndexType33(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DependOnSlot=None, DependOnSlotGroup=None, valueOf_=None):
        self.DependOnSlot = _cast(bool, DependOnSlot)
        self.DependOnSlotGroup = _cast(bool, DependOnSlotGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IndexType33.subclass:
            return IndexType33.subclass(*args_, **kwargs_)
        else:
            return IndexType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DependOnSlot(self): return self.DependOnSlot
    def set_DependOnSlot(self, DependOnSlot): self.DependOnSlot = DependOnSlot
    def get_DependOnSlotGroup(self): return self.DependOnSlotGroup
    def set_DependOnSlotGroup(self, DependOnSlotGroup): self.DependOnSlotGroup = DependOnSlotGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndexType33', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexType33')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndexType33'):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            outfile.write(' DependOnSlot="%s"' % self.gds_format_boolean(self.DependOnSlot, input_name='DependOnSlot'))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            outfile.write(' DependOnSlotGroup="%s"' % self.gds_format_boolean(self.DependOnSlotGroup, input_name='DependOnSlotGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndexType33', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IndexType33'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            showIndent(outfile, level)
            outfile.write('DependOnSlot=%s,\n' % (self.DependOnSlot,))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            showIndent(outfile, level)
            outfile.write('DependOnSlotGroup=%s,\n' % (self.DependOnSlotGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DependOnSlot', node)
        if value is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            if value in ('true', '1'):
                self.DependOnSlot = True
            elif value in ('false', '0'):
                self.DependOnSlot = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlotGroup', node)
        if value is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            if value in ('true', '1'):
                self.DependOnSlotGroup = True
            elif value in ('false', '0'):
                self.DependOnSlotGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndexType33


class DataTypeType34(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SwapData=None, DScale=None, valueOf_=None):
        self.SwapData = _cast(None, SwapData)
        self.DScale = _cast(None, DScale)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DataTypeType34.subclass:
            return DataTypeType34.subclass(*args_, **kwargs_)
        else:
            return DataTypeType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SwapData(self): return self.SwapData
    def set_SwapData(self, SwapData): self.SwapData = SwapData
    def get_DScale(self): return self.DScale
    def set_DScale(self, DScale): self.DScale = DScale
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataTypeType34', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTypeType34')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataTypeType34'):
        if self.SwapData is not None and 'SwapData' not in already_processed:
            already_processed.add('SwapData')
            outfile.write(' SwapData=%s' % (self.gds_format_string(quote_attrib(self.SwapData).encode(ExternalEncoding), input_name='SwapData'), ))
        if self.DScale is not None and 'DScale' not in already_processed:
            already_processed.add('DScale')
            outfile.write(' DScale=%s' % (self.gds_format_string(quote_attrib(self.DScale).encode(ExternalEncoding), input_name='DScale'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataTypeType34', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DataTypeType34'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SwapData is not None and 'SwapData' not in already_processed:
            already_processed.add('SwapData')
            showIndent(outfile, level)
            outfile.write('SwapData="%s",\n' % (self.SwapData,))
        if self.DScale is not None and 'DScale' not in already_processed:
            already_processed.add('DScale')
            showIndent(outfile, level)
            outfile.write('DScale="%s",\n' % (self.DScale,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SwapData', node)
        if value is not None and 'SwapData' not in already_processed:
            already_processed.add('SwapData')
            self.SwapData = value
        value = find_attr_value_('DScale', node)
        if value is not None and 'DScale' not in already_processed:
            already_processed.add('DScale')
            self.DScale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataTypeType34


class IndexType35(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DependOnSlot=None, DependOnSlotGroup=None, valueOf_=None):
        self.DependOnSlot = _cast(bool, DependOnSlot)
        self.DependOnSlotGroup = _cast(bool, DependOnSlotGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IndexType35.subclass:
            return IndexType35.subclass(*args_, **kwargs_)
        else:
            return IndexType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DependOnSlot(self): return self.DependOnSlot
    def set_DependOnSlot(self, DependOnSlot): self.DependOnSlot = DependOnSlot
    def get_DependOnSlotGroup(self): return self.DependOnSlotGroup
    def set_DependOnSlotGroup(self, DependOnSlotGroup): self.DependOnSlotGroup = DependOnSlotGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndexType35', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexType35')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndexType35'):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            outfile.write(' DependOnSlot="%s"' % self.gds_format_boolean(self.DependOnSlot, input_name='DependOnSlot'))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            outfile.write(' DependOnSlotGroup="%s"' % self.gds_format_boolean(self.DependOnSlotGroup, input_name='DependOnSlotGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndexType35', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IndexType35'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            showIndent(outfile, level)
            outfile.write('DependOnSlot=%s,\n' % (self.DependOnSlot,))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            showIndent(outfile, level)
            outfile.write('DependOnSlotGroup=%s,\n' % (self.DependOnSlotGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DependOnSlot', node)
        if value is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            if value in ('true', '1'):
                self.DependOnSlot = True
            elif value in ('false', '0'):
                self.DependOnSlot = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlotGroup', node)
        if value is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            if value in ('true', '1'):
                self.DependOnSlotGroup = True
            elif value in ('false', '0'):
                self.DependOnSlotGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndexType35


class ExcludeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DependOnSlot=None, DependOnSlotGroup=None, valueOf_=None):
        self.DependOnSlot = _cast(bool, DependOnSlot)
        self.DependOnSlotGroup = _cast(bool, DependOnSlotGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ExcludeType.subclass:
            return ExcludeType.subclass(*args_, **kwargs_)
        else:
            return ExcludeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DependOnSlot(self): return self.DependOnSlot
    def set_DependOnSlot(self, DependOnSlot): self.DependOnSlot = DependOnSlot
    def get_DependOnSlotGroup(self): return self.DependOnSlotGroup
    def set_DependOnSlotGroup(self, DependOnSlotGroup): self.DependOnSlotGroup = DependOnSlotGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExcludeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExcludeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExcludeType'):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            outfile.write(' DependOnSlot="%s"' % self.gds_format_boolean(self.DependOnSlot, input_name='DependOnSlot'))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            outfile.write(' DependOnSlotGroup="%s"' % self.gds_format_boolean(self.DependOnSlotGroup, input_name='DependOnSlotGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='ExcludeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ExcludeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            showIndent(outfile, level)
            outfile.write('DependOnSlot=%s,\n' % (self.DependOnSlot,))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            showIndent(outfile, level)
            outfile.write('DependOnSlotGroup=%s,\n' % (self.DependOnSlotGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DependOnSlot', node)
        if value is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            if value in ('true', '1'):
                self.DependOnSlot = True
            elif value in ('false', '0'):
                self.DependOnSlot = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlotGroup', node)
        if value is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            if value in ('true', '1'):
                self.DependOnSlotGroup = True
            elif value in ('false', '0'):
                self.DependOnSlotGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExcludeType


class EntryType36(EntryType):
    subclass = None
    superclass = EntryType
    def __init__(self, Index=None, SubIndex=None, BitLen=None, Name=None, Comment=None, DataType=None, Fixed=None):
        super(EntryType36, self).__init__(Index, SubIndex, BitLen, Name, Comment, DataType, )
        self.Fixed = _cast(bool, Fixed)
        pass
    def factory(*args_, **kwargs_):
        if EntryType36.subclass:
            return EntryType36.subclass(*args_, **kwargs_)
        else:
            return EntryType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fixed(self): return self.Fixed
    def set_Fixed(self, Fixed): self.Fixed = Fixed
    def hasContent_(self):
        if (
            super(EntryType36, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType36', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType36'):
        super(EntryType36, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType36')
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            outfile.write(' Fixed="%s"' % self.gds_format_boolean(self.Fixed, input_name='Fixed'))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType36', fromsubclass_=False, pretty_print=True):
        super(EntryType36, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntryType36'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            showIndent(outfile, level)
            outfile.write('Fixed=%s,\n' % (self.Fixed,))
        super(EntryType36, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntryType36, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Fixed', node)
        if value is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            if value in ('true', '1'):
                self.Fixed = True
            elif value in ('false', '0'):
                self.Fixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(EntryType36, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntryType36, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntryType36


class ChannelInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OverwrittenByModule=None, ProfileNo=None, AddInfo=None, DisplayName=None):
        self.OverwrittenByModule = _cast(bool, OverwrittenByModule)
        self.ProfileNo = ProfileNo
        self.AddInfo = AddInfo
        if DisplayName is None:
            self.DisplayName = []
        else:
            self.DisplayName = DisplayName
    def factory(*args_, **kwargs_):
        if ChannelInfoType.subclass:
            return ChannelInfoType.subclass(*args_, **kwargs_)
        else:
            return ChannelInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProfileNo(self): return self.ProfileNo
    def set_ProfileNo(self, ProfileNo): self.ProfileNo = ProfileNo
    def get_AddInfo(self): return self.AddInfo
    def set_AddInfo(self, AddInfo): self.AddInfo = AddInfo
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def add_DisplayName(self, value): self.DisplayName.append(value)
    def insert_DisplayName(self, index, value): self.DisplayName[index] = value
    def get_OverwrittenByModule(self): return self.OverwrittenByModule
    def set_OverwrittenByModule(self, OverwrittenByModule): self.OverwrittenByModule = OverwrittenByModule
    def hasContent_(self):
        if (
            self.ProfileNo is not None or
            self.AddInfo is not None or
            self.DisplayName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChannelInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelInfoType'):
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            outfile.write(' OverwrittenByModule="%s"' % self.gds_format_boolean(self.OverwrittenByModule, input_name='OverwrittenByModule'))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProfileNo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProfileNo>%s</%sProfileNo>%s' % (namespace_, self.gds_format_integer(self.ProfileNo, input_name='ProfileNo'), namespace_, eol_))
        if self.AddInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddInfo>%s</%sAddInfo>%s' % (namespace_, self.gds_format_integer(self.AddInfo, input_name='AddInfo'), namespace_, eol_))
        for DisplayName_ in self.DisplayName:
            DisplayName_.export(outfile, level, namespace_, name_='DisplayName', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ChannelInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.OverwrittenByModule is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            showIndent(outfile, level)
            outfile.write('OverwrittenByModule=%s,\n' % (self.OverwrittenByModule,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProfileNo is not None:
            showIndent(outfile, level)
            outfile.write('ProfileNo=%d,\n' % self.ProfileNo)
        if self.AddInfo is not None:
            showIndent(outfile, level)
            outfile.write('AddInfo=%d,\n' % self.AddInfo)
        showIndent(outfile, level)
        outfile.write('DisplayName=[\n')
        level += 1
        for DisplayName_ in self.DisplayName:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            DisplayName_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OverwrittenByModule', node)
        if value is not None and 'OverwrittenByModule' not in already_processed:
            already_processed.add('OverwrittenByModule')
            if value in ('true', '1'):
                self.OverwrittenByModule = True
            elif value in ('false', '0'):
                self.OverwrittenByModule = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProfileNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ProfileNo')
            self.ProfileNo = ival_
        elif nodeName_ == 'AddInfo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddInfo')
            self.AddInfo = ival_
        elif nodeName_ == 'DisplayName':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DisplayName.append(obj_)
# end class ChannelInfoType


class DiagMessagesType(DiagnosticsType):
    subclass = None
    superclass = DiagnosticsType
    def __init__(self, DiagSource=None, DiagReset=None, DiagReaction=None, DiagType=None, DiagMessage=None):
        super(DiagMessagesType, self).__init__(DiagSource, DiagReset, DiagReaction, DiagType, DiagMessage, )
        pass
    def factory(*args_, **kwargs_):
        if DiagMessagesType.subclass:
            return DiagMessagesType.subclass(*args_, **kwargs_)
        else:
            return DiagMessagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DiagMessagesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiagMessagesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiagMessagesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiagMessagesType'):
        super(DiagMessagesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiagMessagesType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiagMessagesType', fromsubclass_=False, pretty_print=True):
        super(DiagMessagesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiagMessagesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiagMessagesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiagMessagesType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiagMessagesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DiagMessagesType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DiagMessagesType


class TypeType37(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ModuleClass=None, SRA_ParameterSupported=None, ModuleIdent=None, ModulePdoGroup=None, valueOf_=None):
        self.ModuleClass = _cast(None, ModuleClass)
        self.SRA_ParameterSupported = _cast(None, SRA_ParameterSupported)
        self.ModuleIdent = _cast(None, ModuleIdent)
        self.ModulePdoGroup = _cast(int, ModulePdoGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TypeType37.subclass:
            return TypeType37.subclass(*args_, **kwargs_)
        else:
            return TypeType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ModuleClass(self): return self.ModuleClass
    def set_ModuleClass(self, ModuleClass): self.ModuleClass = ModuleClass
    def get_SRA_ParameterSupported(self): return self.SRA_ParameterSupported
    def set_SRA_ParameterSupported(self, SRA_ParameterSupported): self.SRA_ParameterSupported = SRA_ParameterSupported
    def get_ModuleIdent(self): return self.ModuleIdent
    def set_ModuleIdent(self, ModuleIdent): self.ModuleIdent = ModuleIdent
    def get_ModulePdoGroup(self): return self.ModulePdoGroup
    def set_ModulePdoGroup(self, ModulePdoGroup): self.ModulePdoGroup = ModulePdoGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TypeType37', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeType37')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TypeType37'):
        if self.ModuleClass is not None and 'ModuleClass' not in already_processed:
            already_processed.add('ModuleClass')
            outfile.write(' ModuleClass=%s' % (self.gds_format_string(quote_attrib(self.ModuleClass).encode(ExternalEncoding), input_name='ModuleClass'), ))
        if self.SRA_ParameterSupported is not None and 'SRA_ParameterSupported' not in already_processed:
            already_processed.add('SRA_ParameterSupported')
            outfile.write(' SRA_ParameterSupported=%s' % (self.gds_format_string(quote_attrib(self.SRA_ParameterSupported).encode(ExternalEncoding), input_name='SRA_ParameterSupported'), ))
        if self.ModuleIdent is not None and 'ModuleIdent' not in already_processed:
            already_processed.add('ModuleIdent')
            outfile.write(' ModuleIdent=%s' % (quote_attrib(self.ModuleIdent), ))
        if self.ModulePdoGroup is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            outfile.write(' ModulePdoGroup="%s"' % self.gds_format_integer(self.ModulePdoGroup, input_name='ModulePdoGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='TypeType37', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TypeType37'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModuleClass is not None and 'ModuleClass' not in already_processed:
            already_processed.add('ModuleClass')
            showIndent(outfile, level)
            outfile.write('ModuleClass="%s",\n' % (self.ModuleClass,))
        if self.SRA_ParameterSupported is not None and 'SRA_ParameterSupported' not in already_processed:
            already_processed.add('SRA_ParameterSupported')
            showIndent(outfile, level)
            outfile.write('SRA_ParameterSupported="%s",\n' % (self.SRA_ParameterSupported,))
        if self.ModuleIdent is not None and 'ModuleIdent' not in already_processed:
            already_processed.add('ModuleIdent')
            showIndent(outfile, level)
            outfile.write('ModuleIdent="%s",\n' % (self.ModuleIdent,))
        if self.ModulePdoGroup is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            showIndent(outfile, level)
            outfile.write('ModulePdoGroup=%d,\n' % (self.ModulePdoGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModuleClass', node)
        if value is not None and 'ModuleClass' not in already_processed:
            already_processed.add('ModuleClass')
            self.ModuleClass = value
        value = find_attr_value_('SRA_ParameterSupported', node)
        if value is not None and 'SRA_ParameterSupported' not in already_processed:
            already_processed.add('SRA_ParameterSupported')
            self.SRA_ParameterSupported = value
        value = find_attr_value_('ModuleIdent', node)
        if value is not None and 'ModuleIdent' not in already_processed:
            already_processed.add('ModuleIdent')
            self.ModuleIdent = value
            self.validate_HexDecValue(self.ModuleIdent)    # validate type HexDecValue
        value = find_attr_value_('ModulePdoGroup', node)
        if value is not None and 'ModulePdoGroup' not in already_processed:
            already_processed.add('ModulePdoGroup')
            try:
                self.ModulePdoGroup = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TypeType37


class MailboxType38(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CoE=None):
        self.CoE = CoE
    def factory(*args_, **kwargs_):
        if MailboxType38.subclass:
            return MailboxType38.subclass(*args_, **kwargs_)
        else:
            return MailboxType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CoE(self): return self.CoE
    def set_CoE(self, CoE): self.CoE = CoE
    def hasContent_(self):
        if (
            self.CoE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MailboxType38', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MailboxType38')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MailboxType38'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MailboxType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoE is not None:
            self.CoE.export(outfile, level, namespace_, name_='CoE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MailboxType38'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CoE is not None:
            showIndent(outfile, level)
            outfile.write('CoE=model_.CoEType39(\n')
            self.CoE.exportLiteral(outfile, level, name_='CoE')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoE':
            obj_ = CoEType39.factory()
            obj_.build(child_)
            self.CoE = obj_
# end class MailboxType38


class CoEType39(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ModuleOD=None, SdoInfo=None, PdoConfig=None, PdoUpload=None, EdsFile=None, PdoAssign=None, SegmentedSdo=None, CompleteAccess=None, InitCmd=None):
        self.ModuleOD = _cast(bool, ModuleOD)
        self.SdoInfo = _cast(bool, SdoInfo)
        self.PdoConfig = _cast(bool, PdoConfig)
        self.PdoUpload = _cast(bool, PdoUpload)
        self.EdsFile = _cast(None, EdsFile)
        self.PdoAssign = _cast(bool, PdoAssign)
        self.SegmentedSdo = _cast(bool, SegmentedSdo)
        self.CompleteAccess = _cast(bool, CompleteAccess)
        if InitCmd is None:
            self.InitCmd = []
        else:
            self.InitCmd = InitCmd
    def factory(*args_, **kwargs_):
        if CoEType39.subclass:
            return CoEType39.subclass(*args_, **kwargs_)
        else:
            return CoEType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InitCmd(self): return self.InitCmd
    def set_InitCmd(self, InitCmd): self.InitCmd = InitCmd
    def add_InitCmd(self, value): self.InitCmd.append(value)
    def insert_InitCmd(self, index, value): self.InitCmd[index] = value
    def get_ModuleOD(self): return self.ModuleOD
    def set_ModuleOD(self, ModuleOD): self.ModuleOD = ModuleOD
    def get_SdoInfo(self): return self.SdoInfo
    def set_SdoInfo(self, SdoInfo): self.SdoInfo = SdoInfo
    def get_PdoConfig(self): return self.PdoConfig
    def set_PdoConfig(self, PdoConfig): self.PdoConfig = PdoConfig
    def get_PdoUpload(self): return self.PdoUpload
    def set_PdoUpload(self, PdoUpload): self.PdoUpload = PdoUpload
    def get_EdsFile(self): return self.EdsFile
    def set_EdsFile(self, EdsFile): self.EdsFile = EdsFile
    def get_PdoAssign(self): return self.PdoAssign
    def set_PdoAssign(self, PdoAssign): self.PdoAssign = PdoAssign
    def get_SegmentedSdo(self): return self.SegmentedSdo
    def set_SegmentedSdo(self, SegmentedSdo): self.SegmentedSdo = SegmentedSdo
    def get_CompleteAccess(self): return self.CompleteAccess
    def set_CompleteAccess(self, CompleteAccess): self.CompleteAccess = CompleteAccess
    def hasContent_(self):
        if (
            self.InitCmd
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoEType39', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoEType39')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoEType39'):
        if self.ModuleOD is not None and 'ModuleOD' not in already_processed:
            already_processed.add('ModuleOD')
            outfile.write(' ModuleOD="%s"' % self.gds_format_boolean(self.ModuleOD, input_name='ModuleOD'))
        if self.SdoInfo is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            outfile.write(' SdoInfo="%s"' % self.gds_format_boolean(self.SdoInfo, input_name='SdoInfo'))
        if self.PdoConfig is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            outfile.write(' PdoConfig="%s"' % self.gds_format_boolean(self.PdoConfig, input_name='PdoConfig'))
        if self.PdoUpload is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            outfile.write(' PdoUpload="%s"' % self.gds_format_boolean(self.PdoUpload, input_name='PdoUpload'))
        if self.EdsFile is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            outfile.write(' EdsFile=%s' % (self.gds_format_string(quote_attrib(self.EdsFile).encode(ExternalEncoding), input_name='EdsFile'), ))
        if self.PdoAssign is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            outfile.write(' PdoAssign="%s"' % self.gds_format_boolean(self.PdoAssign, input_name='PdoAssign'))
        if self.SegmentedSdo is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            outfile.write(' SegmentedSdo="%s"' % self.gds_format_boolean(self.SegmentedSdo, input_name='SegmentedSdo'))
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            outfile.write(' CompleteAccess="%s"' % self.gds_format_boolean(self.CompleteAccess, input_name='CompleteAccess'))
    def exportChildren(self, outfile, level, namespace_='', name_='CoEType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InitCmd_ in self.InitCmd:
            InitCmd_.export(outfile, level, namespace_, name_='InitCmd', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CoEType39'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModuleOD is not None and 'ModuleOD' not in already_processed:
            already_processed.add('ModuleOD')
            showIndent(outfile, level)
            outfile.write('ModuleOD=%s,\n' % (self.ModuleOD,))
        if self.SdoInfo is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            showIndent(outfile, level)
            outfile.write('SdoInfo=%s,\n' % (self.SdoInfo,))
        if self.PdoConfig is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            showIndent(outfile, level)
            outfile.write('PdoConfig=%s,\n' % (self.PdoConfig,))
        if self.PdoUpload is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            showIndent(outfile, level)
            outfile.write('PdoUpload=%s,\n' % (self.PdoUpload,))
        if self.EdsFile is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            showIndent(outfile, level)
            outfile.write('EdsFile="%s",\n' % (self.EdsFile,))
        if self.PdoAssign is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            showIndent(outfile, level)
            outfile.write('PdoAssign=%s,\n' % (self.PdoAssign,))
        if self.SegmentedSdo is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            showIndent(outfile, level)
            outfile.write('SegmentedSdo=%s,\n' % (self.SegmentedSdo,))
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            showIndent(outfile, level)
            outfile.write('CompleteAccess=%s,\n' % (self.CompleteAccess,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InitCmd=[\n')
        level += 1
        for InitCmd_ in self.InitCmd:
            showIndent(outfile, level)
            outfile.write('model_.InitCmdType40(\n')
            InitCmd_.exportLiteral(outfile, level, name_='InitCmdType40')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModuleOD', node)
        if value is not None and 'ModuleOD' not in already_processed:
            already_processed.add('ModuleOD')
            if value in ('true', '1'):
                self.ModuleOD = True
            elif value in ('false', '0'):
                self.ModuleOD = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SdoInfo', node)
        if value is not None and 'SdoInfo' not in already_processed:
            already_processed.add('SdoInfo')
            if value in ('true', '1'):
                self.SdoInfo = True
            elif value in ('false', '0'):
                self.SdoInfo = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PdoConfig', node)
        if value is not None and 'PdoConfig' not in already_processed:
            already_processed.add('PdoConfig')
            if value in ('true', '1'):
                self.PdoConfig = True
            elif value in ('false', '0'):
                self.PdoConfig = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PdoUpload', node)
        if value is not None and 'PdoUpload' not in already_processed:
            already_processed.add('PdoUpload')
            if value in ('true', '1'):
                self.PdoUpload = True
            elif value in ('false', '0'):
                self.PdoUpload = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('EdsFile', node)
        if value is not None and 'EdsFile' not in already_processed:
            already_processed.add('EdsFile')
            self.EdsFile = value
        value = find_attr_value_('PdoAssign', node)
        if value is not None and 'PdoAssign' not in already_processed:
            already_processed.add('PdoAssign')
            if value in ('true', '1'):
                self.PdoAssign = True
            elif value in ('false', '0'):
                self.PdoAssign = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SegmentedSdo', node)
        if value is not None and 'SegmentedSdo' not in already_processed:
            already_processed.add('SegmentedSdo')
            if value in ('true', '1'):
                self.SegmentedSdo = True
            elif value in ('false', '0'):
                self.SegmentedSdo = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CompleteAccess', node)
        if value is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            if value in ('true', '1'):
                self.CompleteAccess = True
            elif value in ('false', '0'):
                self.CompleteAccess = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InitCmd':
            obj_ = InitCmdType40.factory()
            obj_.build(child_)
            self.InitCmd.append(obj_)
# end class CoEType39


class InitCmdType40(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompleteAccess=None, Fixed=None, Transition=None, Index=None, SubIndex=None, Data=None, Comment=None):
        self.CompleteAccess = _cast(bool, CompleteAccess)
        self.Fixed = _cast(bool, Fixed)
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        self.Index = Index
        self.SubIndex = SubIndex
        self.Data = Data
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if InitCmdType40.subclass:
            return InitCmdType40.subclass(*args_, **kwargs_)
        else:
            return InitCmdType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition(self, index, value): self.Transition[index] = value
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_SubIndex(self): return self.SubIndex
    def set_SubIndex(self, SubIndex): self.SubIndex = SubIndex
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_CompleteAccess(self): return self.CompleteAccess
    def set_CompleteAccess(self, CompleteAccess): self.CompleteAccess = CompleteAccess
    def get_Fixed(self): return self.Fixed
    def set_Fixed(self, Fixed): self.Fixed = Fixed
    def validate_TransitionType41(self, value):
        # Validate type TransitionType41, a restriction on xs:NMTOKEN.
        pass
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Transition or
            self.Index is not None or
            self.SubIndex is not None or
            self.Data is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitCmdType40', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitCmdType40')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitCmdType40'):
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            outfile.write(' CompleteAccess="%s"' % self.gds_format_boolean(self.CompleteAccess, input_name='CompleteAccess'))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            outfile.write(' Fixed="%s"' % self.gds_format_boolean(self.Fixed, input_name='Fixed'))
    def exportChildren(self, outfile, level, namespace_='', name_='InitCmdType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transition_ in self.Transition:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransition>%s</%sTransition>%s' % (namespace_, self.gds_format_string(quote_xml(Transition_).encode(ExternalEncoding), input_name='Transition'), namespace_, eol_))
        if self.Index is not None:
            self.Index.export(outfile, level, namespace_, name_='Index', pretty_print=pretty_print)
        if self.SubIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubIndex>%s</%sSubIndex>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubIndex).encode(ExternalEncoding), input_name='SubIndex'), namespace_, eol_))
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Comment).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InitCmdType40'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CompleteAccess is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            showIndent(outfile, level)
            outfile.write('CompleteAccess=%s,\n' % (self.CompleteAccess,))
        if self.Fixed is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            showIndent(outfile, level)
            outfile.write('Fixed=%s,\n' % (self.Fixed,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=model_.IndexType42(\n')
            self.Index.exportLiteral(outfile, level, name_='Index')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubIndex is not None:
            showIndent(outfile, level)
            outfile.write('SubIndex=%s,\n' % quote_python(self.SubIndex).encode(ExternalEncoding))
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataType43(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=%s,\n' % quote_python(self.Comment).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CompleteAccess', node)
        if value is not None and 'CompleteAccess' not in already_processed:
            already_processed.add('CompleteAccess')
            if value in ('true', '1'):
                self.CompleteAccess = True
            elif value in ('false', '0'):
                self.CompleteAccess = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Fixed', node)
        if value is not None and 'Fixed' not in already_processed:
            already_processed.add('Fixed')
            if value in ('true', '1'):
                self.Fixed = True
            elif value in ('false', '0'):
                self.Fixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transition':
            Transition_ = child_.text
            Transition_ = self.gds_validate_string(Transition_, node, 'Transition')
            self.Transition.append(Transition_)
            self.validate_TransitionType41(self.Transition)    # validate type TransitionType41
        elif nodeName_ == 'Index':
            obj_ = IndexType42.factory()
            obj_.build(child_)
            self.Index = obj_
        elif nodeName_ == 'SubIndex':
            SubIndex_ = child_.text
            SubIndex_ = self.gds_validate_string(SubIndex_, node, 'SubIndex')
            self.SubIndex = SubIndex_
            self.validate_HexDecValue(self.SubIndex)    # validate type HexDecValue
        elif nodeName_ == 'Data':
            obj_ = DataType43.factory()
            obj_.build(child_)
            self.Data = obj_
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
# end class InitCmdType40


class IndexType42(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DependOnSlot=None, DependOnSlotGroup=None, valueOf_=None):
        self.DependOnSlot = _cast(bool, DependOnSlot)
        self.DependOnSlotGroup = _cast(bool, DependOnSlotGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IndexType42.subclass:
            return IndexType42.subclass(*args_, **kwargs_)
        else:
            return IndexType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DependOnSlot(self): return self.DependOnSlot
    def set_DependOnSlot(self, DependOnSlot): self.DependOnSlot = DependOnSlot
    def get_DependOnSlotGroup(self): return self.DependOnSlotGroup
    def set_DependOnSlotGroup(self, DependOnSlotGroup): self.DependOnSlotGroup = DependOnSlotGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndexType42', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexType42')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndexType42'):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            outfile.write(' DependOnSlot="%s"' % self.gds_format_boolean(self.DependOnSlot, input_name='DependOnSlot'))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            outfile.write(' DependOnSlotGroup="%s"' % self.gds_format_boolean(self.DependOnSlotGroup, input_name='DependOnSlotGroup'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndexType42', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IndexType42'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DependOnSlot is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            showIndent(outfile, level)
            outfile.write('DependOnSlot=%s,\n' % (self.DependOnSlot,))
        if self.DependOnSlotGroup is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            showIndent(outfile, level)
            outfile.write('DependOnSlotGroup=%s,\n' % (self.DependOnSlotGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DependOnSlot', node)
        if value is not None and 'DependOnSlot' not in already_processed:
            already_processed.add('DependOnSlot')
            if value in ('true', '1'):
                self.DependOnSlot = True
            elif value in ('false', '0'):
                self.DependOnSlot = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DependOnSlotGroup', node)
        if value is not None and 'DependOnSlotGroup' not in already_processed:
            already_processed.add('DependOnSlotGroup')
            if value in ('true', '1'):
                self.DependOnSlotGroup = True
            elif value in ('false', '0'):
                self.DependOnSlotGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndexType42


class DataType43(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdaptAutomatically=None, valueOf_=None):
        self.AdaptAutomatically = _cast(bool, AdaptAutomatically)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DataType43.subclass:
            return DataType43.subclass(*args_, **kwargs_)
        else:
            return DataType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdaptAutomatically(self): return self.AdaptAutomatically
    def set_AdaptAutomatically(self, AdaptAutomatically): self.AdaptAutomatically = AdaptAutomatically
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataType43', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataType43')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataType43'):
        if self.AdaptAutomatically is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            outfile.write(' AdaptAutomatically="%s"' % self.gds_format_boolean(self.AdaptAutomatically, input_name='AdaptAutomatically'))
    def exportChildren(self, outfile, level, namespace_='', name_='DataType43', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DataType43'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AdaptAutomatically is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            showIndent(outfile, level)
            outfile.write('AdaptAutomatically=%s,\n' % (self.AdaptAutomatically,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AdaptAutomatically', node)
        if value is not None and 'AdaptAutomatically' not in already_processed:
            already_processed.add('AdaptAutomatically')
            if value in ('true', '1'):
                self.AdaptAutomatically = True
            elif value in ('false', '0'):
                self.AdaptAutomatically = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataType43


class DiagMessageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TextId=None, MessageText=None, Description=None, Flags=None, CauseRemedy=None, Info=None, Hint=None, URL=None):
        self.TextId = TextId
        if MessageText is None:
            self.MessageText = []
        else:
            self.MessageText = MessageText
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Flags = Flags
        if CauseRemedy is None:
            self.CauseRemedy = []
        else:
            self.CauseRemedy = CauseRemedy
        if Info is None:
            self.Info = []
        else:
            self.Info = Info
        if Hint is None:
            self.Hint = []
        else:
            self.Hint = Hint
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
    def factory(*args_, **kwargs_):
        if DiagMessageType.subclass:
            return DiagMessageType.subclass(*args_, **kwargs_)
        else:
            return DiagMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextId(self): return self.TextId
    def set_TextId(self, TextId): self.TextId = TextId
    def get_MessageText(self): return self.MessageText
    def set_MessageText(self, MessageText): self.MessageText = MessageText
    def add_MessageText(self, value): self.MessageText.append(value)
    def insert_MessageText(self, index, value): self.MessageText[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_Flags(self): return self.Flags
    def set_Flags(self, Flags): self.Flags = Flags
    def get_CauseRemedy(self): return self.CauseRemedy
    def set_CauseRemedy(self, CauseRemedy): self.CauseRemedy = CauseRemedy
    def add_CauseRemedy(self, value): self.CauseRemedy.append(value)
    def insert_CauseRemedy(self, index, value): self.CauseRemedy[index] = value
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def add_Info(self, value): self.Info.append(value)
    def insert_Info(self, index, value): self.Info[index] = value
    def get_Hint(self): return self.Hint
    def set_Hint(self, Hint): self.Hint = Hint
    def add_Hint(self, value): self.Hint.append(value)
    def insert_Hint(self, index, value): self.Hint[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL(self, index, value): self.URL[index] = value
    def validate_HexDecValue(self, value):
        # Validate type HexDecValue, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TextId is not None or
            self.MessageText or
            self.Description or
            self.Flags is not None or
            self.CauseRemedy or
            self.Info or
            self.Hint or
            self.URL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiagMessageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiagMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiagMessageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DiagMessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTextId>%s</%sTextId>%s' % (namespace_, self.gds_format_string(quote_xml(self.TextId).encode(ExternalEncoding), input_name='TextId'), namespace_, eol_))
        for MessageText_ in self.MessageText:
            MessageText_.export(outfile, level, namespace_, name_='MessageText', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Flags is not None:
            self.Flags.export(outfile, level, namespace_, name_='Flags', pretty_print=pretty_print)
        for CauseRemedy_ in self.CauseRemedy:
            CauseRemedy_.export(outfile, level, namespace_, name_='CauseRemedy', pretty_print=pretty_print)
        for Info_ in self.Info:
            Info_.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
        for Hint_ in self.Hint:
            Hint_.export(outfile, level, namespace_, name_='Hint', pretty_print=pretty_print)
        for URL_ in self.URL:
            URL_.export(outfile, level, namespace_, name_='URL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiagMessageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextId is not None:
            showIndent(outfile, level)
            outfile.write('TextId=%s,\n' % quote_python(self.TextId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('MessageText=[\n')
        level += 1
        for MessageText_ in self.MessageText:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            MessageText_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Description_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Flags is not None:
            showIndent(outfile, level)
            outfile.write('Flags=model_.FlagsType44(\n')
            self.Flags.exportLiteral(outfile, level, name_='Flags')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CauseRemedy=[\n')
        level += 1
        for CauseRemedy_ in self.CauseRemedy:
            showIndent(outfile, level)
            outfile.write('model_.CauseRemedyType(\n')
            CauseRemedy_.exportLiteral(outfile, level, name_='CauseRemedyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Info=[\n')
        level += 1
        for Info_ in self.Info:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Info_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hint=[\n')
        level += 1
        for Hint_ in self.Hint:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Hint_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            URL_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextId':
            TextId_ = child_.text
            TextId_ = self.gds_validate_string(TextId_, node, 'TextId')
            self.TextId = TextId_
            self.validate_HexDecValue(self.TextId)    # validate type HexDecValue
        elif nodeName_ == 'MessageText':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.MessageText.append(obj_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'Flags':
            obj_ = FlagsType44.factory()
            obj_.build(child_)
            self.Flags = obj_
        elif nodeName_ == 'CauseRemedy':
            obj_ = CauseRemedyType.factory()
            obj_.build(child_)
            self.CauseRemedy.append(obj_)
        elif nodeName_ == 'Info':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Info.append(obj_)
        elif nodeName_ == 'Hint':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Hint.append(obj_)
        elif nodeName_ == 'URL':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.URL.append(obj_)
# end class DiagMessageType


class FlagsType44(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiagClass=None, DiagReset=None, DiagReaction=None, DiagType=None):
        self.DiagClass = DiagClass
        self.DiagReset = DiagReset
        self.DiagReaction = DiagReaction
        self.DiagType = DiagType
    def factory(*args_, **kwargs_):
        if FlagsType44.subclass:
            return FlagsType44.subclass(*args_, **kwargs_)
        else:
            return FlagsType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiagClass(self): return self.DiagClass
    def set_DiagClass(self, DiagClass): self.DiagClass = DiagClass
    def get_DiagReset(self): return self.DiagReset
    def set_DiagReset(self, DiagReset): self.DiagReset = DiagReset
    def get_DiagReaction(self): return self.DiagReaction
    def set_DiagReaction(self, DiagReaction): self.DiagReaction = DiagReaction
    def get_DiagType(self): return self.DiagType
    def set_DiagType(self, DiagType): self.DiagType = DiagType
    def validate_DiagClassType(self, value):
        # Validate type DiagClassType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.DiagClass is not None or
            self.DiagReset is not None or
            self.DiagReaction is not None or
            self.DiagType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlagsType44', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlagsType44')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlagsType44'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlagsType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiagClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiagClass>%s</%sDiagClass>%s' % (namespace_, self.gds_format_string(quote_xml(self.DiagClass).encode(ExternalEncoding), input_name='DiagClass'), namespace_, eol_))
        if self.DiagReset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiagReset>%s</%sDiagReset>%s' % (namespace_, self.gds_format_integer(self.DiagReset, input_name='DiagReset'), namespace_, eol_))
        if self.DiagReaction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiagReaction>%s</%sDiagReaction>%s' % (namespace_, self.gds_format_integer(self.DiagReaction, input_name='DiagReaction'), namespace_, eol_))
        if self.DiagType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiagType>%s</%sDiagType>%s' % (namespace_, self.gds_format_integer(self.DiagType, input_name='DiagType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FlagsType44'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DiagClass is not None:
            showIndent(outfile, level)
            outfile.write('DiagClass=%s,\n' % quote_python(self.DiagClass).encode(ExternalEncoding))
        if self.DiagReset is not None:
            showIndent(outfile, level)
            outfile.write('DiagReset=%d,\n' % self.DiagReset)
        if self.DiagReaction is not None:
            showIndent(outfile, level)
            outfile.write('DiagReaction=%d,\n' % self.DiagReaction)
        if self.DiagType is not None:
            showIndent(outfile, level)
            outfile.write('DiagType=%d,\n' % self.DiagType)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiagClass':
            DiagClass_ = child_.text
            DiagClass_ = self.gds_validate_string(DiagClass_, node, 'DiagClass')
            self.DiagClass = DiagClass_
            self.validate_DiagClassType(self.DiagClass)    # validate type DiagClassType
        elif nodeName_ == 'DiagReset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DiagReset')
            self.DiagReset = ival_
        elif nodeName_ == 'DiagReaction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DiagReaction')
            self.DiagReaction = ival_
        elif nodeName_ == 'DiagType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DiagType')
            self.DiagType = ival_
# end class FlagsType44


class CauseRemedyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Idx=None, Cause=None, Remedy=None):
        self.Idx = _cast(None, Idx)
        if Cause is None:
            self.Cause = []
        else:
            self.Cause = Cause
        if Remedy is None:
            self.Remedy = []
        else:
            self.Remedy = Remedy
    def factory(*args_, **kwargs_):
        if CauseRemedyType.subclass:
            return CauseRemedyType.subclass(*args_, **kwargs_)
        else:
            return CauseRemedyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cause(self): return self.Cause
    def set_Cause(self, Cause): self.Cause = Cause
    def add_Cause(self, value): self.Cause.append(value)
    def insert_Cause(self, index, value): self.Cause[index] = value
    def get_Remedy(self): return self.Remedy
    def set_Remedy(self, Remedy): self.Remedy = Remedy
    def add_Remedy(self, value): self.Remedy.append(value)
    def insert_Remedy(self, index, value): self.Remedy[index] = value
    def get_Idx(self): return self.Idx
    def set_Idx(self, Idx): self.Idx = Idx
    def hasContent_(self):
        if (
            self.Cause or
            self.Remedy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CauseRemedyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CauseRemedyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CauseRemedyType'):
        if self.Idx is not None and 'Idx' not in already_processed:
            already_processed.add('Idx')
            outfile.write(' Idx=%s' % (self.gds_format_string(quote_attrib(self.Idx).encode(ExternalEncoding), input_name='Idx'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CauseRemedyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Cause_ in self.Cause:
            Cause_.export(outfile, level, namespace_, name_='Cause', pretty_print=pretty_print)
        for Remedy_ in self.Remedy:
            Remedy_.export(outfile, level, namespace_, name_='Remedy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CauseRemedyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Idx is not None and 'Idx' not in already_processed:
            already_processed.add('Idx')
            showIndent(outfile, level)
            outfile.write('Idx="%s",\n' % (self.Idx,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Cause=[\n')
        level += 1
        for Cause_ in self.Cause:
            showIndent(outfile, level)
            outfile.write('model_.CauseType(\n')
            Cause_.exportLiteral(outfile, level, name_='CauseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Remedy=[\n')
        level += 1
        for Remedy_ in self.Remedy:
            showIndent(outfile, level)
            outfile.write('model_.RemedyType(\n')
            Remedy_.exportLiteral(outfile, level, name_='RemedyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Idx', node)
        if value is not None and 'Idx' not in already_processed:
            already_processed.add('Idx')
            self.Idx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cause':
            obj_ = CauseType.factory()
            obj_.build(child_)
            self.Cause.append(obj_)
        elif nodeName_ == 'Remedy':
            obj_ = RemedyType.factory()
            obj_.build(child_)
            self.Remedy.append(obj_)
# end class CauseRemedyType


class CauseType(NameType):
    subclass = None
    superclass = NameType
    def __init__(self, LcId=1033, valueOf_=None):
        super(CauseType, self).__init__(LcId, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CauseType.subclass:
            return CauseType.subclass(*args_, **kwargs_)
        else:
            return CauseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CauseType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CauseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CauseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CauseType'):
        super(CauseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CauseType')
    def exportChildren(self, outfile, level, namespace_='', name_='CauseType', fromsubclass_=False, pretty_print=True):
        super(CauseType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CauseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CauseType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CauseType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CauseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CauseType


class RemedyType(NameType):
    subclass = None
    superclass = NameType
    def __init__(self, LcId=1033, valueOf_=None):
        super(RemedyType, self).__init__(LcId, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RemedyType.subclass:
            return RemedyType.subclass(*args_, **kwargs_)
        else:
            return RemedyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RemedyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RemedyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemedyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RemedyType'):
        super(RemedyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RemedyType')
    def exportChildren(self, outfile, level, namespace_='', name_='RemedyType', fromsubclass_=False, pretty_print=True):
        super(RemedyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RemedyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RemedyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RemedyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RemedyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RemedyType


GDSClassesMapping = {
    'Xml': XmlType31,
    'Timeout': TimeoutType18,
    'CauseRemedy': CauseRemedyType,
    'Access': AccessType25,
    'SubDevice': SubDeviceType,
    'Object': ObjectType,
    'ExecutionUnit': ExecutionUnitType,
    'SubItem': SubItemType32,
    'CycleTime': CycleTimeType,
    'URL': NameType,
    'Register': RegisterType,
    'EtherCATController': EtherCATControllerType,
    'DiagMessage': DiagMessageType,
    'DiagType': EnumInfoType,
    'ShiftTimeSync0': ShiftTimeSync0Type,
    'ShiftTimeSync1': ShiftTimeSync1Type,
    'InitCmd': InitCmdType40,
    'Electrical': ElectricalType,
    'SafetyParaMapping': PdoType,
    'Index': IndexType42,
    'AoE': AoEType,
    'DisplayName': NameType,
    'ModulePdoGroup': ModulePdoGroupType,
    'HideType': HideTypeType,
    'Type': TypeType37,
    'Vendor': VendorType1,
    'Mailbox': MailboxType38,
    'FoE': FoEType,
    'ArrayInfo': ArrayInfoType,
    'Desc': NameType,
    'TxPdo': PdoType,
    'ChannelInfo': ChannelInfoType,
    'DiagReaction': EnumInfoType,
    'ModuleClass': ModuleClassType,
    'Pdo': PdoType15,
    'Behavior': BehaviorType,
    'Property': PropertyType,
    'Remedy': RemedyType,
    'Comment': NameType,
    'Dictionary': DictionaryType,
    'EoE': EoEType,
    'MessageText': NameType,
    'SlotSelections': SlotSelectionsType,
    'RxPdo': PdoType,
    'ModuleIdent': ModuleIdentType,
    'OpMode': OpModeType,
    'UnitTypes': UnitTypesType,
    'Category': CategoryType,
    'Group': GroupType2,
    'DiagMessages': DiagMessagesType,
    'CatNo': CatNoType,
    'Scalings': ScalingsType,
    'StateMachine': StateMachineType,
    'EnumInfo': EnumInfoType,
    'Hint': NameType,
    'Scaling': ScalingType,
    'Groups': GroupsType,
    'Device': DeviceType3,
    'Data': DataType43,
    'Properties': PropertiesType30,
    'ShiftTime': ShiftTimeType,
    'Fmmu': FmmuType,
    'Su': SuType,
    'Sm': SmType14,
    'Eeprom': EepromType16,
    'Text': NameType,
    'Flags': FlagsType44,
    'AlternativeType': AlternativeTypeType,
    'Exclude': ExcludeType,
    'Unit': UnitTypeType,
    'Slot': SlotType,
    'VoE': VoEType,
    'Cause': CauseType,
    'CycleTimeSync0': CycleTimeSync0Type,
    'CycleTimeSync1': CycleTimeSync1Type,
    'Profile': ProfileType,
    'Description': NameType,
    'DeviceFeature': DeviceFeatureType,
    'Info': NameType,
    'Dc': DcType,
    'UnitType': UnitTypeType,
    'Objects': ObjectsType,
    'Descriptions': DescriptionsType,
    'SoE': SoEType,
    'Name': NameType,
    'Modules': ModulesType,
    'ESC': ESCType,
    'Devices': DevicesType,
    'Entry': EntryType36,
    'DataTypes': DataTypesType,
    'VendorSpecific': VendorSpecificType,
    'DataType': DataTypeType,
    'DiagReset': EnumInfoType,
    'Module': ModuleType4,
    'CoE': CoEType39,
    'Slots': SlotsType,
    'Port': PortType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EtherCATInfo'
        rootClass = EtherCATInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EtherCATInfo'
        rootClass = EtherCATInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = EtherCATInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="EtherCATInfo",
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EtherCATInfo'
        rootClass = EtherCATInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ethercatinfo import *\n\n')
        sys.stdout.write('import ethercatinfo as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccessType",
    "AccessType21",
    "AccessType25",
    "AlternativeTypeType",
    "AoEType",
    "ArrayInfoType",
    "BehaviorType",
    "CatNoType",
    "CategoryType",
    "CauseRemedyType",
    "CauseType",
    "ChannelInfoType",
    "CoEType",
    "CoEType39",
    "CycleTimeSync0Type",
    "CycleTimeSync1Type",
    "CycleTimeType",
    "DataType11",
    "DataType43",
    "DataTypeType",
    "DataTypeType34",
    "DataTypesType",
    "DcType",
    "DescriptionsType",
    "DeviceFeatureType",
    "DeviceType",
    "DeviceType3",
    "DevicesType",
    "DiagMessageType",
    "DiagMessagesType",
    "DiagnosticsType",
    "DictionaryType",
    "ESCType",
    "EepromType",
    "EepromType16",
    "ElectricalType",
    "EntryType",
    "EntryType36",
    "EnumInfoType",
    "EoEType",
    "EtherCATControllerType",
    "EtherCATInfo",
    "ExcludeType",
    "ExecutionUnitType",
    "FlagsType",
    "FlagsType24",
    "FlagsType44",
    "FmmuType",
    "FoEType",
    "GroupType",
    "GroupType2",
    "GroupsType",
    "HideTypeType",
    "IndexType",
    "IndexType33",
    "IndexType35",
    "IndexType42",
    "InfoType",
    "InitCmdType",
    "InitCmdType12",
    "InitCmdType40",
    "InitCmdType6",
    "InitCmdType9",
    "MailboxType",
    "MailboxType17",
    "MailboxType38",
    "ModuleClassType",
    "ModuleIdentType",
    "ModulePdoGroupType",
    "ModuleType",
    "ModuleType4",
    "ModulesType",
    "NameType",
    "ObjectInfoType",
    "ObjectType",
    "ObjectType8",
    "ObjectsType",
    "OpModeType",
    "PdoType",
    "PdoType15",
    "PortType",
    "ProfileType",
    "ProfileType5",
    "PropertiesType",
    "PropertiesType30",
    "PropertyType",
    "RegisterType",
    "RemedyType",
    "ScalingType",
    "ScalingsType",
    "ShiftTimeSync0Type",
    "ShiftTimeSync1Type",
    "ShiftTimeType",
    "SlotSelectionsType",
    "SlotType",
    "SlotsType",
    "SmType",
    "SmType14",
    "SoEType",
    "StateMachineType",
    "SuType",
    "SubDeviceType",
    "SubItemType",
    "SubItemType32",
    "TimeoutType",
    "TimeoutType18",
    "TypeType",
    "TypeType37",
    "UnitTypeType",
    "UnitTypesType",
    "VendorSpecificType",
    "VendorType",
    "VendorType1",
    "VoEType",
    "XmlType",
    "XmlType23",
    "XmlType31"
]
